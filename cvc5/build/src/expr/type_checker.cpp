/******************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2010-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * This file was automatically generated by:
 *
 *     ../../../src/expr/mkexpr /home/aaa/fp-solver/cvc5/src/expr/type_checker_template.cpp /home/aaa/fp-solver/cvc5/src/theory/builtin/kinds /home/aaa/fp-solver/cvc5/src/theory/booleans/kinds /home/aaa/fp-solver/cvc5/src/theory/uf/kinds /home/aaa/fp-solver/cvc5/src/theory/arith/kinds /home/aaa/fp-solver/cvc5/src/theory/bv/kinds /home/aaa/fp-solver/cvc5/src/theory/ff/kinds /home/aaa/fp-solver/cvc5/src/theory/fp/kinds /home/aaa/fp-solver/cvc5/src/theory/arrays/kinds /home/aaa/fp-solver/cvc5/src/theory/datatypes/kinds /home/aaa/fp-solver/cvc5/src/theory/sep/kinds /home/aaa/fp-solver/cvc5/src/theory/sets/kinds /home/aaa/fp-solver/cvc5/src/theory/bags/kinds /home/aaa/fp-solver/cvc5/src/theory/strings/kinds /home/aaa/fp-solver/cvc5/src/theory/quantifiers/kinds
 *
 * for the cvc5 project.
 */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/aaa/fp-solver/cvc5/src/expr/type_checker_template.cpp */

/******************************************************************************
 * Top contributors (to current version):
 *   Morgan Deters, Aina Niemetz, Mathias Preiner
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * TypeChecker implementation.
 */

#include <sstream>

#include "expr/node_manager.h"
#include "expr/node_manager_attributes.h"
#include "expr/type_checker.h"
#include "expr/type_checker_util.h"

// clang-format off

#include "theory/builtin/theory_builtin_type_rules.h"
#include "theory/booleans/theory_bool_type_rules.h"
#include "theory/uf/theory_uf_type_rules.h"
#include "theory/arith/theory_arith_type_rules.h"
#include "theory/bv/theory_bv_type_rules.h"
#include "theory/ff/theory_ff_type_rules.h"
#include "theory/fp/theory_fp_type_rules.h"
#include "theory/arrays/theory_arrays_type_rules.h"
#include "theory/datatypes/theory_datatypes_type_rules.h"
#include "theory/sep/theory_sep_type_rules.h"
#include "theory/sets/theory_sets_type_rules.h"
#include "theory/bags/theory_bags_type_rules.h"
#include "theory/strings/theory_strings_type_rules.h"
#include "theory/quantifiers/theory_quantifiers_type_rules.h"
// clang-format on

namespace cvc5::internal {
namespace expr {

TypeNode TypeChecker::preComputeType(NodeManager* nodeManager, TNode n)
{
  TypeNode typeNode;

  // Infer the type
  switch (n.getKind())
  {
    case kind::VARIABLE:
    case kind::SKOLEM:
    case kind::BOUND_VARIABLE:
    case kind::INST_CONSTANT:
    case kind::BOOLEAN_TERM_VARIABLE:
    case kind::RAW_SYMBOL:
      // variable kinds have their type marked as an attribute upon construction
      typeNode = nodeManager->getAttribute(n, TypeAttr());
      break;
    case kind::BUILTIN:
      typeNode = nodeManager->builtinOperatorType();
      break;

      // !!! will auto-generate preComputeType rules when they are available

    default:
      // not handled
      break;
  }
  return typeNode;
}

TypeNode TypeChecker::computeType(NodeManager* nodeManager,
                                  TNode n,
                                  bool check,
                                  std::ostream* errOut)
{
  TypeNode typeNode;

  // Infer the type
  switch (n.getKind())
  {
    case kind::VARIABLE:
    case kind::SKOLEM:
      typeNode = nodeManager->getAttribute(n, TypeAttr());
      break;
    case kind::BUILTIN:
      typeNode = nodeManager->builtinOperatorType();
      break;

      // clang-format off

  case kind::UNINTERPRETED_SORT_VALUE:
    typeNode = ::cvc5::internal::theory::builtin::UninterpretedSortValueTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::EQUAL:
    typeNode = ::cvc5::internal::theory::builtin::EqualityTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DISTINCT:
    typeNode = ::cvc5::internal::theory::builtin::DistinctTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEXPR:
    typeNode = ::cvc5::internal::theory::builtin::SExprTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::WITNESS:
    typeNode = ::cvc5::internal::theory::builtin::WitnessTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_INDEXED_SYMBOLIC_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_INDEXED_SYMBOLIC:
    typeNode = ::cvc5::internal::theory::builtin::ApplyIndexedSymbolicTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_BOOLEAN:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::NOT:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::AND:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::IMPLIES:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::OR:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::XOR:
    typeNode = ::cvc5::internal::theory::boolean::BooleanTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ITE:
    typeNode = ::cvc5::internal::theory::boolean::IteTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_UF:
    typeNode = ::cvc5::internal::theory::uf::UfTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::LAMBDA:
    typeNode = ::cvc5::internal::theory::uf::LambdaTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::HO_APPLY:
    typeNode = ::cvc5::internal::theory::uf::HoApplyTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CARDINALITY_CONSTRAINT_OP:
    typeNode = ::cvc5::internal::theory::uf::CardinalityConstraintOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CARDINALITY_CONSTRAINT:
    typeNode = ::cvc5::internal::theory::uf::CardinalityConstraintTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::COMBINED_CARDINALITY_CONSTRAINT_OP:
    typeNode = ::cvc5::internal::theory::uf::CombinedCardinalityConstraintOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::COMBINED_CARDINALITY_CONSTRAINT:
    typeNode = ::cvc5::internal::theory::uf::CombinedCardinalityConstraintTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FUNCTION_ARRAY_CONST:
    typeNode = ::cvc5::internal::theory::uf::FunctionArrayConstTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_TO_NAT:
    typeNode = ::cvc5::internal::theory::uf::BitVectorConversionTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INT_TO_BITVECTOR_OP:
    typeNode = ::cvc5::internal::theory::uf::IntToBitVectorOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INT_TO_BITVECTOR:
    typeNode = ::cvc5::internal::theory::uf::BitVectorConversionTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ADD:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::MULT:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::NONLINEAR_MULT:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SUB:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::NEG:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DIVISION:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::POW:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_RATIONAL:
    typeNode = ::cvc5::internal::theory::arith::ArithConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_INTEGER:
    typeNode = ::cvc5::internal::theory::arith::ArithConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REAL_ALGEBRAIC_NUMBER_OP:
    typeNode = ::cvc5::internal::theory::arith::ArithRealAlgebraicNumberOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REAL_ALGEBRAIC_NUMBER:
    typeNode = ::cvc5::internal::theory::arith::ArithRealAlgebraicNumberTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::LT:
    typeNode = ::cvc5::internal::theory::arith::ArithRelationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::LEQ:
    typeNode = ::cvc5::internal::theory::arith::ArithRelationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::GT:
    typeNode = ::cvc5::internal::theory::arith::ArithRelationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::GEQ:
    typeNode = ::cvc5::internal::theory::arith::ArithRelationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INDEXED_ROOT_PREDICATE_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INDEXED_ROOT_PREDICATE:
    typeNode = ::cvc5::internal::theory::arith::IndexedRootPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TO_REAL:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TO_INTEGER:
    typeNode = SimpleTypeRule<RInteger, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::IS_INTEGER:
    typeNode = SimpleTypeRule<RBool, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ABS:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INTS_DIVISION:
    typeNode = SimpleTypeRule<RInteger, AInteger, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INTS_MODULUS:
    typeNode = SimpleTypeRule<RInteger, AInteger, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DIVISIBLE:
    typeNode = SimpleTypeRule<RBool, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DIVISIBLE_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DIVISION_TOTAL:
    typeNode = ::cvc5::internal::theory::arith::ArithOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INTS_DIVISION_TOTAL:
    typeNode = SimpleTypeRule<RInteger, AInteger, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INTS_MODULUS_TOTAL:
    typeNode = SimpleTypeRule<RInteger, AInteger, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::EXPONENTIAL:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SINE:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::COSINE:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TANGENT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::COSECANT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SECANT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::COTANGENT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCSINE:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCCOSINE:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCTANGENT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCCOSECANT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCSECANT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARCCOTANGENT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::POW2:
    typeNode = SimpleTypeRule<RInteger, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SQRT:
    typeNode = SimpleTypeRule<RReal, ARealOrInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::PI:
    typeNode = ::cvc5::internal::theory::arith::RealNullaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::IAND_OP:
    typeNode = ::cvc5::internal::theory::arith::IAndOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::IAND:
    typeNode = ::cvc5::internal::theory::arith::IAndTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_BITVECTOR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_BB_TERM:
    typeNode = ::cvc5::internal::theory::bv::BitVectorToBVTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_CONCAT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorConcatTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_AND:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_COMP:
    typeNode = ::cvc5::internal::theory::bv::BitVectorBVPredTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_NAND:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_NOR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_NOT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_OR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_XNOR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_XOR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_MULT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_NEG:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ADD:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SUB:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UDIV:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UREM:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SDIV:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SMOD:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SREM:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ASHR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_LSHR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SHL:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ULE:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ULT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UGE:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UGT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SLE:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SLT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SGE:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SGT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ULTBV:
    typeNode = ::cvc5::internal::theory::bv::BitVectorBVPredTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SLTBV:
    typeNode = ::cvc5::internal::theory::bv::BitVectorBVPredTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ITE:
    typeNode = ::cvc5::internal::theory::bv::BitVectorITETypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_REDAND:
    typeNode = ::cvc5::internal::theory::bv::BitVectorRedTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_REDOR:
    typeNode = ::cvc5::internal::theory::bv::BitVectorRedTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UADDO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SADDO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_UMULO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SMULO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_USUBO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SSUBO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SDIVO:
    typeNode = ::cvc5::internal::theory::bv::BitVectorPredicateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ACKERMANNIZE_UDIV:
    typeNode = ::cvc5::internal::theory::bv::BitVectorAckermanizationUdivTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ACKERMANNIZE_UREM:
    typeNode = ::cvc5::internal::theory::bv::BitVectorAckermanizationUremTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_EAGER_ATOM:
    typeNode = ::cvc5::internal::theory::bv::BitVectorEagerAtomTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_BITOF_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_BITOF:
    typeNode = ::cvc5::internal::theory::bv::BitVectorBitOfTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_EXTRACT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_EXTRACT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorExtractTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_REPEAT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_REPEAT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorRepeatTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ROTATE_LEFT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ROTATE_LEFT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ROTATE_RIGHT:
    typeNode = ::cvc5::internal::theory::bv::BitVectorFixedWidthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SIGN_EXTEND_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_SIGN_EXTEND:
    typeNode = ::cvc5::internal::theory::bv::BitVectorExtendTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ZERO_EXTEND_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BITVECTOR_ZERO_EXTEND:
    typeNode = ::cvc5::internal::theory::bv::BitVectorExtendTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_FINITE_FIELD:
    typeNode = ::cvc5::internal::theory::ff::FiniteFieldConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FINITE_FIELD_MULT:
    typeNode = ::cvc5::internal::theory::ff::FiniteFieldFixedFieldTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FINITE_FIELD_NEG:
    typeNode = ::cvc5::internal::theory::ff::FiniteFieldFixedFieldTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FINITE_FIELD_ADD:
    typeNode = ::cvc5::internal::theory::ff::FiniteFieldFixedFieldTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_FLOATINGPOINT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_ROUNDINGMODE:
    typeNode = ::cvc5::internal::theory::fp::RoundingModeConstantTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_FP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointFPTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_EQ:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_ABS:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_NEG:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_ADD:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_SUB:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_MULT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_DIV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_FMA:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_SQRT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_REM:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_RTI:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointRoundingOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_MIN:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_MAX:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_MIN_TOTAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointPartialOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_MAX_TOTAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointPartialOperationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_LEQ:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_LT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_GEQ:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_GT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_NORMAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_SUBNORMAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_ZERO:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_INF:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_NAN:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_NEG:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_IS_POS:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointTestTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToFPIEEEBitVectorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_FP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToFPFloatingPointTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_REAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToFPRealTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_SBV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToFPSignedBitVectorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_UBV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToFPUnsignedBitVectorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_UBV_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_UBV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToUBVTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_UBV_TOTAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToUBVTotalTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_SBV_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_SBV:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToSBVTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointParametricOpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_SBV_TOTAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToSBVTotalTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_REAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToRealTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_TO_REAL_TOTAL:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointToRealTotalTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_NAN:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentBit::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_INF:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentBit::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_ZERO:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentBit::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_SIGN:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentBit::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_EXPONENT:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentExponent::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND:
    typeNode = ::cvc5::internal::theory::fp::FloatingPointComponentSignificand::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ROUNDINGMODE_BITBLAST:
    typeNode = ::cvc5::internal::theory::fp::RoundingModeBitBlast::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SELECT:
    typeNode = ::cvc5::internal::theory::arrays::ArraySelectTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STORE:
    typeNode = ::cvc5::internal::theory::arrays::ArrayStoreTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STORE_ALL:
    typeNode = ::cvc5::internal::theory::arrays::ArrayStoreTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ARRAY_LAMBDA:
    typeNode = ::cvc5::internal::theory::arrays::ArrayLambdaTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::EQ_RANGE:
    typeNode = ::cvc5::internal::theory::arrays::ArrayEqRangeTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_CONSTRUCTOR:
    typeNode = ::cvc5::internal::theory::datatypes::DatatypeConstructorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_SELECTOR:
    typeNode = ::cvc5::internal::theory::datatypes::DatatypeSelectorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_TESTER:
    typeNode = ::cvc5::internal::theory::datatypes::DatatypeTesterTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_UPDATER:
    typeNode = ::cvc5::internal::theory::datatypes::DatatypeUpdateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::APPLY_TYPE_ASCRIPTION:
    typeNode = ::cvc5::internal::theory::datatypes::DatatypeAscriptionTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DT_SIZE:
    typeNode = ::cvc5::internal::theory::datatypes::DtSizeTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DT_HEIGHT_BOUND:
    typeNode = ::cvc5::internal::theory::datatypes::DtBoundTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DT_SIZE_BOUND:
    typeNode = ::cvc5::internal::theory::datatypes::DtBoundTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DT_SYGUS_BOUND:
    typeNode = ::cvc5::internal::theory::datatypes::DtBoundTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::DT_SYGUS_EVAL:
    typeNode = ::cvc5::internal::theory::datatypes::DtSygusEvalTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::MATCH:
    typeNode = ::cvc5::internal::theory::datatypes::MatchTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::MATCH_CASE:
    typeNode = ::cvc5::internal::theory::datatypes::MatchCaseTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::MATCH_BIND_CASE:
    typeNode = ::cvc5::internal::theory::datatypes::MatchBindCaseTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TUPLE_PROJECT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TUPLE_PROJECT:
    typeNode = ::cvc5::internal::theory::datatypes::TupleProjectTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CODATATYPE_BOUND_VARIABLE:
    typeNode = ::cvc5::internal::theory::datatypes::CodatatypeBoundVariableTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_EMP:
    typeNode = ::cvc5::internal::theory::sep::SepEmpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_PTO:
    typeNode = ::cvc5::internal::theory::sep::SepPtoTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_STAR:
    typeNode = ::cvc5::internal::theory::sep::SepStarTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_WAND:
    typeNode = ::cvc5::internal::theory::sep::SepWandTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_LABEL:
    typeNode = ::cvc5::internal::theory::sep::SepLabelTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEP_NIL:
    typeNode = ::cvc5::internal::theory::sep::SepNilTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_UNION:
    typeNode = ::cvc5::internal::theory::sets::SetsBinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_INTER:
    typeNode = ::cvc5::internal::theory::sets::SetsBinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_MINUS:
    typeNode = ::cvc5::internal::theory::sets::SetsBinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_SUBSET:
    typeNode = ::cvc5::internal::theory::sets::SubsetTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_MEMBER:
    typeNode = ::cvc5::internal::theory::sets::MemberTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_SINGLETON:
    typeNode = ::cvc5::internal::theory::sets::SingletonTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_EMPTY:
    typeNode = ::cvc5::internal::theory::sets::EmptySetTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_INSERT:
    typeNode = ::cvc5::internal::theory::sets::InsertTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_CARD:
    typeNode = ::cvc5::internal::theory::sets::CardTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_COMPLEMENT:
    typeNode = ::cvc5::internal::theory::sets::ComplementTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_UNIVERSE:
    typeNode = ::cvc5::internal::theory::sets::UniverseSetTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_COMPREHENSION:
    typeNode = ::cvc5::internal::theory::sets::ComprehensionTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_CHOOSE:
    typeNode = ::cvc5::internal::theory::sets::ChooseTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_IS_SINGLETON:
    typeNode = ::cvc5::internal::theory::sets::IsSingletonTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_MAP:
    typeNode = ::cvc5::internal::theory::sets::SetMapTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_FILTER:
    typeNode = ::cvc5::internal::theory::sets::SetFilterTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SET_FOLD:
    typeNode = ::cvc5::internal::theory::sets::SetFoldTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_JOIN:
    typeNode = ::cvc5::internal::theory::sets::RelBinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_PRODUCT:
    typeNode = ::cvc5::internal::theory::sets::RelBinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_TRANSPOSE:
    typeNode = ::cvc5::internal::theory::sets::RelTransposeTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_TCLOSURE:
    typeNode = ::cvc5::internal::theory::sets::RelTransClosureTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_JOIN_IMAGE:
    typeNode = ::cvc5::internal::theory::sets::JoinImageTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_IDEN:
    typeNode = ::cvc5::internal::theory::sets::RelIdenTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_GROUP_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_GROUP:
    typeNode = ::cvc5::internal::theory::sets::RelationGroupTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_AGGREGATE_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_AGGREGATE:
    typeNode = ::cvc5::internal::theory::sets::RelationAggregateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_PROJECT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::RELATION_PROJECT:
    typeNode = ::cvc5::internal::theory::sets::RelationProjectTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_UNION_MAX:
    typeNode = ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_UNION_DISJOINT:
    typeNode = ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_INTER_MIN:
    typeNode = ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_DIFFERENCE_SUBTRACT:
    typeNode = ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_DIFFERENCE_REMOVE:
    typeNode = ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_SUBBAG:
    typeNode = ::cvc5::internal::theory::bags::SubBagTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_COUNT:
    typeNode = ::cvc5::internal::theory::bags::CountTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_MEMBER:
    typeNode = ::cvc5::internal::theory::bags::MemberTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_DUPLICATE_REMOVAL:
    typeNode = ::cvc5::internal::theory::bags::DuplicateRemovalTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_MAKE:
    typeNode = ::cvc5::internal::theory::bags::BagMakeTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_EMPTY:
    typeNode = ::cvc5::internal::theory::bags::EmptyBagTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_CARD:
    typeNode = ::cvc5::internal::theory::bags::CardTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_CHOOSE:
    typeNode = ::cvc5::internal::theory::bags::ChooseTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_IS_SINGLETON:
    typeNode = ::cvc5::internal::theory::bags::IsSingletonTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_FROM_SET:
    typeNode = ::cvc5::internal::theory::bags::FromSetTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_TO_SET:
    typeNode = ::cvc5::internal::theory::bags::ToSetTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_MAP:
    typeNode = ::cvc5::internal::theory::bags::BagMapTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_FILTER:
    typeNode = ::cvc5::internal::theory::bags::BagFilterTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_FOLD:
    typeNode = ::cvc5::internal::theory::bags::BagFoldTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BAG_PARTITION:
    typeNode = ::cvc5::internal::theory::bags::BagPartitionTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_PRODUCT:
    typeNode = ::cvc5::internal::theory::bags::TableProductTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_PROJECT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_PROJECT:
    typeNode = ::cvc5::internal::theory::bags::TableProjectTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_AGGREGATE_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_AGGREGATE:
    typeNode = ::cvc5::internal::theory::bags::TableAggregateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_JOIN_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_JOIN:
    typeNode = ::cvc5::internal::theory::bags::TableJoinTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_GROUP_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::TABLE_GROUP:
    typeNode = ::cvc5::internal::theory::bags::TableGroupTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_RV:
    typeNode = SimpleTypeRule<RRegExp, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_CONCAT:
    typeNode = SimpleTypeRuleVar<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_UNION:
    typeNode = SimpleTypeRuleVar<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_INTER:
    typeNode = SimpleTypeRuleVar<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_DIFF:
    typeNode = SimpleTypeRuleVar<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_STAR:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_PLUS:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_OPT:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_RANGE:
    typeNode = ::cvc5::internal::theory::strings::RegExpRangeTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_REPEAT_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_REPEAT:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_LOOP_OP:
    typeNode = SimpleTypeRule<RBuiltinOperator>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_LOOP:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_COMPLEMENT:
    typeNode = SimpleTypeRule<RRegExp, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_TO_REGEXP:
    typeNode = ::cvc5::internal::theory::strings::StringToRegExpTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_IN_REGEXP:
    typeNode = SimpleTypeRule<RBool, AString, ARegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_NONE:
    typeNode = SimpleTypeRule<RRegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_ALL:
    typeNode = SimpleTypeRule<RRegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::REGEXP_ALLCHAR:
    typeNode = SimpleTypeRule<RRegExp>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_CONCAT:
    typeNode = ::cvc5::internal::theory::strings::StringConcatTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_LENGTH:
    typeNode = ::cvc5::internal::theory::strings::StringStrToIntTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_SUBSTR:
    typeNode = ::cvc5::internal::theory::strings::StringSubstrTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_UPDATE:
    typeNode = ::cvc5::internal::theory::strings::StringUpdateTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_CHARAT:
    typeNode = ::cvc5::internal::theory::strings::StringAtTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_CONTAINS:
    typeNode = ::cvc5::internal::theory::strings::StringRelationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_INDEXOF:
    typeNode = ::cvc5::internal::theory::strings::StringIndexOfTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_INDEXOF_RE:
    typeNode = SimpleTypeRule<RInteger, AString, ARegExp, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_REPLACE:
    typeNode = ::cvc5::internal::theory::strings::StringReplaceTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_REPLACE_ALL:
    typeNode = ::cvc5::internal::theory::strings::StringReplaceTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_REPLACE_RE:
    typeNode = SimpleTypeRule<RString, AString, ARegExp, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_REPLACE_RE_ALL:
    typeNode = SimpleTypeRule<RString, AString, ARegExp, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_PREFIX:
    typeNode = ::cvc5::internal::theory::strings::StringStrToBoolTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_SUFFIX:
    typeNode = ::cvc5::internal::theory::strings::StringStrToBoolTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_REV:
    typeNode = ::cvc5::internal::theory::strings::StringStrToStrTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_STRING:
    typeNode = SimpleTypeRule<RString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_LT:
    typeNode = SimpleTypeRule<RBool, AString, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_LEQ:
    typeNode = SimpleTypeRule<RBool, AString, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_IS_DIGIT:
    typeNode = SimpleTypeRule<RBool, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_ITOS:
    typeNode = SimpleTypeRule<RString, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_STOI:
    typeNode = SimpleTypeRule<RInteger, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_TO_CODE:
    typeNode = SimpleTypeRule<RInteger, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_FROM_CODE:
    typeNode = SimpleTypeRule<RString, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_UNIT:
    typeNode = SimpleTypeRule<RString, AInteger>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_TO_UPPER:
    typeNode = SimpleTypeRule<RString, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::STRING_TO_LOWER:
    typeNode = SimpleTypeRule<RString, AString>::computeType(nodeManager, n, check, errOut);
    break;

  case kind::CONST_SEQUENCE:
    typeNode = ::cvc5::internal::theory::strings::ConstSequenceTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEQ_UNIT:
    typeNode = ::cvc5::internal::theory::strings::SeqUnitTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SEQ_NTH:
    typeNode = ::cvc5::internal::theory::strings::SeqNthTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::FORALL:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::EXISTS:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::BOUND_VAR_LIST:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierBoundVarListTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_PATTERN_LIST:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierInstPatternListTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::ORACLE_FORMULA_GEN:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierOracleFormulaGenTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_PATTERN:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierInstPatternTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_NO_PATTERN:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierAnnotationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_ATTRIBUTE:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierAnnotationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_POOL:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierAnnotationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::INST_ADD_TO_POOL:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierAnnotationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

  case kind::SKOLEM_ADD_TO_POOL:
    typeNode = ::cvc5::internal::theory::quantifiers::QuantifierAnnotationTypeRule::computeType(nodeManager, n, check, errOut);
    break;

      // clang-format on

    default:
      Trace("getType") << "FAILURE" << std::endl;
      Unhandled() << " " << n.getKind();
  }

  nodeManager->setAttribute(n, TypeAttr(), typeNode);
  nodeManager->setAttribute(n, TypeCheckedAttr(),
                            check || nodeManager->getAttribute(n, TypeCheckedAttr()));

  return typeNode;

} /* TypeChecker::computeType */

bool TypeChecker::computeIsConst(NodeManager* nodeManager, TNode n)
{
  Assert(n.getMetaKind() == kind::metakind::OPERATOR
         || n.getMetaKind() == kind::metakind::PARAMETERIZED
         || n.getMetaKind() == kind::metakind::NULLARY_OPERATOR);

  switch (n.getKind())
  {
    // clang-format off

  case kind::STORE:
    return ::cvc5::internal::theory::arrays::ArrayStoreTypeRule::computeIsConst(nodeManager, n);

  case kind::APPLY_CONSTRUCTOR:
    return ::cvc5::internal::theory::datatypes::DatatypeConstructorTypeRule::computeIsConst(nodeManager, n);

  case kind::SET_UNION:
    return ::cvc5::internal::theory::sets::SetsBinaryOperatorTypeRule::computeIsConst(nodeManager, n);

  case kind::SET_SINGLETON:
    return ::cvc5::internal::theory::sets::SingletonTypeRule::computeIsConst(nodeManager, n);

  case kind::BAG_UNION_DISJOINT:
    return ::cvc5::internal::theory::bags::BinaryOperatorTypeRule::computeIsConst(nodeManager, n);

  case kind::BAG_MAKE:
    return ::cvc5::internal::theory::bags::BagMakeTypeRule::computeIsConst(nodeManager, n);

  case kind::STRING_TO_REGEXP:
    return ::cvc5::internal::theory::strings::StringToRegExpTypeRule::computeIsConst(nodeManager, n);

      // clang-format on

    default:;
  }

  return false;

}/* TypeChecker::computeIsConst */

}  // namespace expr
}  // namespace cvc5::internal
