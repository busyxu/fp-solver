/******************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2010-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * This header file was automatically generated by:
 *
 *     ../../../src/expr/mkkind /home/aaa/fp-solver/cvc5/src/expr/kind_template.h /home/aaa/fp-solver/cvc5/src/theory/builtin/kinds /home/aaa/fp-solver/cvc5/src/theory/booleans/kinds /home/aaa/fp-solver/cvc5/src/theory/uf/kinds /home/aaa/fp-solver/cvc5/src/theory/arith/kinds /home/aaa/fp-solver/cvc5/src/theory/bv/kinds /home/aaa/fp-solver/cvc5/src/theory/ff/kinds /home/aaa/fp-solver/cvc5/src/theory/fp/kinds /home/aaa/fp-solver/cvc5/src/theory/arrays/kinds /home/aaa/fp-solver/cvc5/src/theory/datatypes/kinds /home/aaa/fp-solver/cvc5/src/theory/sep/kinds /home/aaa/fp-solver/cvc5/src/theory/sets/kinds /home/aaa/fp-solver/cvc5/src/theory/bags/kinds /home/aaa/fp-solver/cvc5/src/theory/strings/kinds /home/aaa/fp-solver/cvc5/src/theory/quantifiers/kinds
 *
 * for the cvc5 project.
 */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/aaa/fp-solver/cvc5/src/expr/kind_template.h */

/******************************************************************************
 * Top contributors (to current version):
 *   Andres Noetzli, Mathias Preiner, Aina Niemetz
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Template for the Node kind header.
 */

#include "cvc5_public.h"

#ifndef CVC5__KIND_H
#define CVC5__KIND_H

#include <iosfwd>

#include "base/exception.h"
#include "theory/theory_id.h"

namespace cvc5::internal {
namespace kind {

enum Kind_t
{
  UNDEFINED_KIND = -1, /**< undefined */
  NULL_EXPR,           /**< Null kind */
  // clang-format off
  
  /* from builtin */
  SORT_TYPE, /**< specifies types of user-declared 'uninterpreted' sorts (1) */
  INSTANTIATED_SORT_TYPE, /**< instantiated uninterpreted sort (2) */
  UNINTERPRETED_SORT_VALUE, /**< util/uninterpreted_sort_value.h (3) */
  BUILTIN, /**< expr/kind.h (4) */
  EQUAL, /**< equality (two parameters only, sorts must match) (5) */
  DISTINCT, /**< disequality (N-ary, sorts must match) (6) */
  VARIABLE, /**< a variable (not permitted in bindings) (7) */
  BOUND_VARIABLE, /**< a bound variable (permitted in bindings and the associated lambda and quantifier bodies only) (8) */
  SKOLEM, /**< a Skolem variable (internal only) (9) */
  SEXPR, /**< a symbolic expression (any arity) (10) */
  WITNESS, /**< a witness expression; first parameter is a BOUND_VAR_LIST, second is the witness body (11) */
  TYPE_CONSTANT, /**< expr/kind.h (12) */
  RAW_SYMBOL, /**< a variable that is not quoted in the smt2 printer (internal only) (13) */
  ABSTRACT_TYPE, /**< theory/builtin/abstract_type.h (14) */
  APPLY_INDEXED_SYMBOLIC_OP, /**< theory/builtin/generic_op.h (15) */
  APPLY_INDEXED_SYMBOLIC, /**< generic indexed operator, whose arguments are the list of terms corresponding to (symbolic) indices to the operator followed by its normal arguments (16) */

  /* from booleans */
  CONST_BOOLEAN, /**< util/bool.h (17) */
  NOT, /**< logical not (18) */
  AND, /**< logical and (N-ary) (19) */
  IMPLIES, /**< logical implication (exactly two parameters) (20) */
  OR, /**< logical or (N-ary) (21) */
  XOR, /**< exclusive or (exactly two parameters) (22) */
  ITE, /**< if-then-else, used for both Boolean and term ITE constructs; first parameter is (Boolean-sorted) condition, second is 'then', third is 'else' and these two parameters must have same base sort (23) */

  /* from uf */
  APPLY_UF, /**< application of an uninterpreted function; first parameter is the function, remaining ones are parameters to that function (24) */
  FUNCTION_TYPE, /**< a function type (25) */
  LAMBDA, /**< a lambda expression; first parameter is a BOUND_VAR_LIST, second is lambda body (26) */
  BOOLEAN_TERM_VARIABLE, /**< Boolean term variable (27) */
  HO_APPLY, /**< higher-order (partial) function application (28) */
  CARDINALITY_CONSTRAINT_OP, /**< expr/cardinality_constraint.h (29) */
  CARDINALITY_CONSTRAINT, /**< a fixed upper bound on the cardinality of an uninterpreted sort (30) */
  COMBINED_CARDINALITY_CONSTRAINT_OP, /**< expr/cardinality_constraint.h (31) */
  COMBINED_CARDINALITY_CONSTRAINT, /**< a fixed upper bound on the sum of cardinalities of uninterpreted sorts (32) */
  FUNCTION_ARRAY_CONST, /**< expr/function_array_const.h (33) */
  BITVECTOR_TO_NAT, /**< bit-vector conversion to (nonnegative) integer; parameter is a bit-vector (34) */
  INT_TO_BITVECTOR_OP, /**< util/bitvector.h (35) */
  INT_TO_BITVECTOR, /**< integer conversion to bit-vector; first parameter is an INT_TO_BITVECTOR_OP, second is an integer term (36) */

  /* from arith */
  ADD, /**< arithmetic addition (N-ary) (37) */
  MULT, /**< arithmetic multiplication (N-ary) (38) */
  NONLINEAR_MULT, /**< synonym for MULT (39) */
  SUB, /**< arithmetic binary subtraction operator (40) */
  NEG, /**< arithmetic unary negation (41) */
  DIVISION, /**< real division, division by 0 undefined (user symbol) (42) */
  DIVISION_TOTAL, /**< real division with interpreted division by 0 (internal symbol) (43) */
  INTS_DIVISION, /**< integer division, division by 0 undefined (user symbol) (44) */
  INTS_DIVISION_TOTAL, /**< integer division with interpreted division by 0 (internal symbol) (45) */
  INTS_MODULUS, /**< integer modulus, division by 0 undefined (user symbol) (46) */
  INTS_MODULUS_TOTAL, /**< integer modulus with interpreted division by 0 (internal symbol) (47) */
  ABS, /**< absolute value (48) */
  DIVISIBLE, /**< divisibility-by-k predicate; first parameter is a DIVISIBLE_OP, second is integer term (49) */
  POW, /**< arithmetic power (50) */
  POW2, /**< arithmetic power of 2 (51) */
  EXPONENTIAL, /**< exponential (52) */
  SINE, /**< sine (53) */
  COSINE, /**< consine (54) */
  TANGENT, /**< tangent (55) */
  COSECANT, /**< cosecant (56) */
  SECANT, /**< secant (57) */
  COTANGENT, /**< cotangent (58) */
  ARCSINE, /**< arc sine (59) */
  ARCCOSINE, /**< arc consine (60) */
  ARCTANGENT, /**< arc tangent (61) */
  ARCCOSECANT, /**< arc cosecant (62) */
  ARCSECANT, /**< arc secant (63) */
  ARCCOTANGENT, /**< arc cotangent (64) */
  SQRT, /**< square root (65) */
  DIVISIBLE_OP, /**< util/divisible.h (66) */
  CONST_RATIONAL, /**< util/rational.h (67) */
  CONST_INTEGER, /**< util/rational.h (68) */
  REAL_ALGEBRAIC_NUMBER_OP, /**< util/real_algebraic_number.h (69) */
  REAL_ALGEBRAIC_NUMBER, /**< a real algebraic number constant; payload is an instance of the cvc5::internal::RealAlgebraicNumber class (70) */
  LT, /**< less than, x < y (71) */
  LEQ, /**< less than or equal, x <= y (72) */
  GT, /**< greater than, x > y (73) */
  GEQ, /**< greater than or equal, x >= y (74) */
  INDEXED_ROOT_PREDICATE_OP, /**< util/indexed_root_predicate.h (75) */
  INDEXED_ROOT_PREDICATE, /**< indexed root predicate; first parameter is a INDEXED_ROOT_PREDICATE_OP, second is a real variable compared to zero, third is a polynomial (76) */
  IS_INTEGER, /**< term-is-integer predicate (parameter is a real-sorted term) (77) */
  TO_INTEGER, /**< convert term to integer by the floor function (parameter is a real-sorted term) (78) */
  TO_REAL, /**< cast term to real (parameter is an integer-sorted term) (79) */
  PI, /**< pi (80) */
  IAND_OP, /**< util/iand.h (81) */
  IAND, /**< integer version of AND operator; first parameter is an IAND_OP, second and third are integer terms (82) */

  /* from bv */
  BITVECTOR_TYPE, /**< util/bitvector.h (83) */
  CONST_BITVECTOR, /**< util/bitvector.h (84) */
  BITVECTOR_BB_TERM, /**< create bit-vector from vector of Booleans (85) */
  BITVECTOR_CONCAT, /**< concatenation of two or more bit-vectors (86) */
  BITVECTOR_AND, /**< bitwise and of two or more bit-vectors (87) */
  BITVECTOR_COMP, /**< equality comparison of two bit-vectors (returns one bit) (88) */
  BITVECTOR_OR, /**< bitwise or of two or more bit-vectors (89) */
  BITVECTOR_XOR, /**< bitwise xor of two or more bit-vectors (90) */
  BITVECTOR_NOT, /**< bitwise not of a bit-vector (91) */
  BITVECTOR_NAND, /**< bitwise nand of two bit-vectors (92) */
  BITVECTOR_NOR, /**< bitwise nor of two bit-vectors (93) */
  BITVECTOR_XNOR, /**< bitwise xnor of two bit-vectors (94) */
  BITVECTOR_MULT, /**< multiplication of two or more bit-vectors (95) */
  BITVECTOR_NEG, /**< unary negation of a bit-vector (96) */
  BITVECTOR_ADD, /**< addition of two or more bit-vectors (97) */
  BITVECTOR_SUB, /**< subtraction of two bit-vectors (98) */
  BITVECTOR_UDIV, /**< unsigned division of two bit-vectors, truncating towards 0 (defined to be the all-ones bit pattern, if divisor is 0) (99) */
  BITVECTOR_UREM, /**< unsigned remainder from truncating division of two bit-vectors (defined to be equal to the dividend, if divisor is 0) (100) */
  BITVECTOR_SDIV, /**< 2's complement signed division (101) */
  BITVECTOR_SMOD, /**< 2's complement signed remainder (sign follows divisor) (102) */
  BITVECTOR_SREM, /**< 2's complement signed remainder (sign follows dividend) (103) */
  BITVECTOR_ASHR, /**< bit-vector arithmetic shift right (the two bit-vector parameters must have same width) (104) */
  BITVECTOR_LSHR, /**< bit-vector logical shift right (the two bit-vector parameters must have same width) (105) */
  BITVECTOR_SHL, /**< bit-vector shift left (the two bit-vector parameters must have same width) (106) */
  BITVECTOR_ULE, /**< bit-vector unsigned less than or equal (the two bit-vector parameters must have same width) (107) */
  BITVECTOR_ULT, /**< bit-vector unsigned less than (the two bit-vector parameters must have same width) (108) */
  BITVECTOR_UGE, /**< bit-vector unsigned greater than or equal (the two bit-vector parameters must have same width) (109) */
  BITVECTOR_UGT, /**< bit-vector unsigned greater than (the two bit-vector parameters must have same width) (110) */
  BITVECTOR_SLE, /**< bit-vector signed less than or equal (the two bit-vector parameters must have same width) (111) */
  BITVECTOR_SLT, /**< bit-vector signed less than (the two bit-vector parameters must have same width) (112) */
  BITVECTOR_SGE, /**< bit-vector signed greater than or equal (the two bit-vector parameters must have same width) (113) */
  BITVECTOR_SGT, /**< bit-vector signed greater than (the two bit-vector parameters must have same width) (114) */
  BITVECTOR_ULTBV, /**< bit-vector unsigned less than but returns bv of size 1 instead of boolean (115) */
  BITVECTOR_SLTBV, /**< bit-vector signed less than but returns bv of size 1 instead of boolean (116) */
  BITVECTOR_REDAND, /**< bit-vector redand (117) */
  BITVECTOR_REDOR, /**< bit-vector redor (118) */
  BITVECTOR_UADDO, /**< bit-vector unsigned addition overflow predicate (119) */
  BITVECTOR_SADDO, /**< bit-vector signed addition overflow predicate (120) */
  BITVECTOR_UMULO, /**< bit-vector unsigned multiplication overflow predicate (121) */
  BITVECTOR_SMULO, /**< bit-vector signed multiplication overflow predicate (122) */
  BITVECTOR_USUBO, /**< bit-vector unsigned subtraction overflow predicate (123) */
  BITVECTOR_SSUBO, /**< bit-vector signed subtraction overflow predicate (124) */
  BITVECTOR_SDIVO, /**< bit-vector signed division overflow predicate (125) */
  BITVECTOR_ITE, /**< same semantics as regular ITE, but condition is bv of size 1 instead of Boolean (126) */
  BITVECTOR_ACKERMANNIZE_UDIV, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvudiv (internal-only symbol) (127) */
  BITVECTOR_ACKERMANNIZE_UREM, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvurem (internal-only symbol) (128) */
  BITVECTOR_EAGER_ATOM, /**< formula to be treated as a bv atom via eager bit-blasting (internal-only symbol) (129) */
  BITVECTOR_BITOF_OP, /**< util/bitvector.h (130) */
  BITVECTOR_BITOF, /**< bit-vector boolean bit extract; first parameter is a BITVECTOR_BITOF_OP, second is a bit-vector term (131) */
  BITVECTOR_EXTRACT_OP, /**< util/bitvector.h (132) */
  BITVECTOR_EXTRACT, /**< bit-vector extract; first parameter is a BITVECTOR_EXTRACT_OP, second is a bit-vector term (133) */
  BITVECTOR_REPEAT_OP, /**< util/bitvector.h (134) */
  BITVECTOR_REPEAT, /**< bit-vector repeat; first parameter is a BITVECTOR_REPEAT_OP, second is a bit-vector term (135) */
  BITVECTOR_ROTATE_LEFT_OP, /**< util/bitvector.h (136) */
  BITVECTOR_ROTATE_LEFT, /**< bit-vector rotate left; first parameter is a BITVECTOR_ROTATE_LEFT_OP, second is a bit-vector term (137) */
  BITVECTOR_ROTATE_RIGHT_OP, /**< util/bitvector.h (138) */
  BITVECTOR_ROTATE_RIGHT, /**< bit-vector rotate right; first parameter is a BITVECTOR_ROTATE_RIGHT_OP, second is a bit-vector term (139) */
  BITVECTOR_SIGN_EXTEND_OP, /**< util/bitvector.h (140) */
  BITVECTOR_SIGN_EXTEND, /**< bit-vector sign-extend; first parameter is a BITVECTOR_SIGN_EXTEND_OP, second is a bit-vector term (141) */
  BITVECTOR_ZERO_EXTEND_OP, /**< util/bitvector.h (142) */
  BITVECTOR_ZERO_EXTEND, /**< bit-vector zero-extend; first parameter is a BITVECTOR_ZERO_EXTEND_OP, second is a bit-vector term (143) */

  /* from ff */
  FINITE_FIELD_TYPE, /**< util/finite_field_value.h (144) */
  CONST_FINITE_FIELD, /**< util/finite_field_value.h (145) */
  FINITE_FIELD_MULT, /**< multiplication of two or more field elements (146) */
  FINITE_FIELD_NEG, /**< unary negation of a field element (147) */
  FINITE_FIELD_ADD, /**< addition of two or more field elements (148) */

  /* from fp */
  CONST_FLOATINGPOINT, /**< util/floatingpoint.h (149) */
  CONST_ROUNDINGMODE, /**< util/roundingmode.h (150) */
  FLOATINGPOINT_TYPE, /**< util/floatingpoint.h (151) */
  FLOATINGPOINT_FP, /**< construct a floating-point literal from bit vectors (152) */
  FLOATINGPOINT_EQ, /**< floating-point equality (153) */
  FLOATINGPOINT_ABS, /**< floating-point absolute value (154) */
  FLOATINGPOINT_NEG, /**< floating-point negation (155) */
  FLOATINGPOINT_ADD, /**< floating-point addition (156) */
  FLOATINGPOINT_SUB, /**< floating-point sutraction (157) */
  FLOATINGPOINT_MULT, /**< floating-point multiply (158) */
  FLOATINGPOINT_DIV, /**< floating-point division (159) */
  FLOATINGPOINT_FMA, /**< floating-point fused multiply and add (160) */
  FLOATINGPOINT_SQRT, /**< floating-point square root (161) */
  FLOATINGPOINT_REM, /**< floating-point remainder (162) */
  FLOATINGPOINT_RTI, /**< floating-point round to integral (163) */
  FLOATINGPOINT_MIN, /**< floating-point minimum (164) */
  FLOATINGPOINT_MAX, /**< floating-point maximum (165) */
  FLOATINGPOINT_MIN_TOTAL, /**< floating-point minimum (defined for all inputs) (166) */
  FLOATINGPOINT_MAX_TOTAL, /**< floating-point maximum (defined for all inputs) (167) */
  FLOATINGPOINT_LEQ, /**< floating-point less than or equal (168) */
  FLOATINGPOINT_LT, /**< floating-point less than (169) */
  FLOATINGPOINT_GEQ, /**< floating-point greater than or equal (170) */
  FLOATINGPOINT_GT, /**< floating-point greater than (171) */
  FLOATINGPOINT_IS_NORMAL, /**< floating-point is normal (172) */
  FLOATINGPOINT_IS_SUBNORMAL, /**< floating-point is sub-normal (173) */
  FLOATINGPOINT_IS_ZERO, /**< floating-point is zero (174) */
  FLOATINGPOINT_IS_INF, /**< floating-point is infinite (175) */
  FLOATINGPOINT_IS_NAN, /**< floating-point is NaN (176) */
  FLOATINGPOINT_IS_NEG, /**< floating-point is negative (177) */
  FLOATINGPOINT_IS_POS, /**< floating-point is positive (178) */
  FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP, /**< util/floatingpoint.h (179) */
  FLOATINGPOINT_TO_FP_FROM_IEEE_BV, /**< convert an IEEE-754 bit vector to floating-point (180) */
  FLOATINGPOINT_TO_FP_FROM_FP_OP, /**< util/floatingpoint.h (181) */
  FLOATINGPOINT_TO_FP_FROM_FP, /**< convert between floating-point sorts (182) */
  FLOATINGPOINT_TO_FP_FROM_REAL_OP, /**< util/floatingpoint.h (183) */
  FLOATINGPOINT_TO_FP_FROM_REAL, /**< convert a real to floating-point (184) */
  FLOATINGPOINT_TO_FP_FROM_SBV_OP, /**< util/floatingpoint.h (185) */
  FLOATINGPOINT_TO_FP_FROM_SBV, /**< convert a signed bit vector to floating-point (186) */
  FLOATINGPOINT_TO_FP_FROM_UBV_OP, /**< util/floatingpoint.h (187) */
  FLOATINGPOINT_TO_FP_FROM_UBV, /**< convert an unsigned bit vector to floating-point (188) */
  FLOATINGPOINT_TO_UBV_OP, /**< util/floatingpoint.h (189) */
  FLOATINGPOINT_TO_UBV, /**< convert a floating-point value to an unsigned bit vector (190) */
  FLOATINGPOINT_TO_UBV_TOTAL_OP, /**< util/floatingpoint.h (191) */
  FLOATINGPOINT_TO_UBV_TOTAL, /**< convert a floating-point value to an unsigned bit vector (defined for all inputs) (192) */
  FLOATINGPOINT_TO_SBV_OP, /**< util/floatingpoint.h (193) */
  FLOATINGPOINT_TO_SBV, /**< convert a floating-point value to a signed bit vector (194) */
  FLOATINGPOINT_TO_SBV_TOTAL_OP, /**< util/floatingpoint.h (195) */
  FLOATINGPOINT_TO_SBV_TOTAL, /**< convert a floating-point value to a signed bit vector (defined for all inputs) (196) */
  FLOATINGPOINT_TO_REAL, /**< floating-point to real (197) */
  FLOATINGPOINT_TO_REAL_TOTAL, /**< floating-point to real (defined for all inputs) (198) */
  FLOATINGPOINT_COMPONENT_NAN, /**< NaN component of a word-blasted floating-point number (199) */
  FLOATINGPOINT_COMPONENT_INF, /**< Inf component of a word-blasted floating-point number (200) */
  FLOATINGPOINT_COMPONENT_ZERO, /**< Zero component of a word-blasted floating-point number (201) */
  FLOATINGPOINT_COMPONENT_SIGN, /**< Sign component of a word-blasted floating-point number (202) */
  FLOATINGPOINT_COMPONENT_EXPONENT, /**< Exponent component of a word-blasted floating-point number (203) */
  FLOATINGPOINT_COMPONENT_SIGNIFICAND, /**< Significand component of a word-blasted floating-point number (204) */
  ROUNDINGMODE_BITBLAST, /**< The bit-vector for a non-deterministic rounding mode (205) */

  /* from arrays */
  ARRAY_TYPE, /**< array type (206) */
  SELECT, /**< array select; first parameter is an array term, second is the selection index (207) */
  STORE, /**< array store; first parameter is an array term, second is the store index, third is the term to store at the index (208) */
  EQ_RANGE, /**< equality of two arrays over an index range lower/upper (209) */
  STORE_ALL, /**< expr/array_store_all.h (210) */
  ARRAY_LAMBDA, /**< array lambda (internal-only symbol) (211) */

  /* from datatypes */
  CONSTRUCTOR_TYPE, /**< constructor (212) */
  SELECTOR_TYPE, /**< selector (213) */
  TESTER_TYPE, /**< tester (214) */
  UPDATER_TYPE, /**< datatype update (215) */
  APPLY_CONSTRUCTOR, /**< constructor application; first parameter is the constructor, remaining parameters (if any) are parameters to the constructor (216) */
  APPLY_SELECTOR, /**< selector application; parameter is a datatype term (undefined if mis-applied) (217) */
  APPLY_TESTER, /**< tester application; first parameter is a tester, second is a datatype term (218) */
  APPLY_UPDATER, /**< datatype updater application; first parameter is an update, second is a datatype term to update, third is the value to update with (219) */
  DATATYPE_TYPE, /**<  (220) */
  PARAMETRIC_DATATYPE, /**< parametric datatype (221) */
  TUPLE_TYPE, /**< tuple type (222) */
  APPLY_TYPE_ASCRIPTION, /**< type ascription, for datatype constructor applications; first parameter is an ASCRIPTION_TYPE, second is the datatype constructor application being ascribed (223) */
  ASCRIPTION_TYPE, /**< expr/ascription_type.h (224) */
  DT_SIZE, /**< datatypes size (225) */
  DT_HEIGHT_BOUND, /**< datatypes height bound (226) */
  DT_SIZE_BOUND, /**< datatypes height bound (227) */
  DT_SYGUS_BOUND, /**< datatypes sygus bound (228) */
  DT_SYGUS_EVAL, /**< datatypes sygus evaluation function (229) */
  MATCH, /**< match construct (230) */
  MATCH_CASE, /**< a match case (231) */
  MATCH_BIND_CASE, /**< a match case with bound variables (232) */
  TUPLE_PROJECT_OP, /**< theory/datatypes/project_op.h (233) */
  TUPLE_PROJECT, /**< projects a tuple from an existing tuple using indices passed in TupleProjectOp (234) */
  CODATATYPE_BOUND_VARIABLE, /**< expr/codatatype_bound_variable.h (235) */

  /* from sep */
  SEP_NIL, /**< separation nil (236) */
  SEP_EMP, /**< separation logic empty heap constraint (237) */
  SEP_PTO, /**< points to relation (238) */
  SEP_STAR, /**< separation star (239) */
  SEP_WAND, /**< separation magic wand (240) */
  SEP_LABEL, /**< separation label (internal use only) (241) */

  /* from sets */
  SET_EMPTY, /**< expr/emptyset.h (242) */
  SET_TYPE, /**< set type, takes as parameter the type of the elements (243) */
  SET_UNION, /**< set union (244) */
  SET_INTER, /**< set intersection (245) */
  SET_MINUS, /**< set subtraction (246) */
  SET_SUBSET, /**< subset predicate; first parameter a subset of second (247) */
  SET_MEMBER, /**< set membership predicate; first parameter a member of second (248) */
  SET_SINGLETON, /**< constructs a set of a single element. First parameter is a term (249) */
  SET_INSERT, /**< set obtained by inserting elements (first N-1 parameters) into a set (the last parameter) (250) */
  SET_CARD, /**< set cardinality operator (251) */
  SET_COMPLEMENT, /**< set complement (with respect to finite universe) (252) */
  SET_UNIVERSE, /**< (finite) universe set, all set variables must be interpreted as subsets of it. (253) */
  SET_COMPREHENSION, /**< set comprehension specified by a bound variable list, a predicate, and a term. (254) */
  SET_CHOOSE, /**< return an element in the set given as a parameter (255) */
  SET_IS_SINGLETON, /**< return whether the given set is a singleton (256) */
  SET_MAP, /**< set map function (257) */
  SET_FILTER, /**< set filter operator (258) */
  SET_FOLD, /**< set fold operator (259) */
  RELATION_GROUP_OP, /**< theory/datatypes/project_op.h (260) */
  RELATION_GROUP, /**< relation group (261) */
  RELATION_AGGREGATE_OP, /**< theory/datatypes/project_op.h (262) */
  RELATION_AGGREGATE, /**< relation aggregate (263) */
  RELATION_PROJECT_OP, /**< theory/datatypes/project_op.h (264) */
  RELATION_PROJECT, /**< relation projection (265) */
  RELATION_JOIN, /**< relation join (266) */
  RELATION_PRODUCT, /**< relation cartesian product (267) */
  RELATION_TRANSPOSE, /**< relation transpose (268) */
  RELATION_TCLOSURE, /**< relation transitive closure (269) */
  RELATION_JOIN_IMAGE, /**< relation join image (270) */
  RELATION_IDEN, /**< relation identity (271) */

  /* from bags */
  BAG_EMPTY, /**< expr/emptybag.h (272) */
  BAG_TYPE, /**< bag type, takes as parameter the type of the elements (273) */
  BAG_UNION_MAX, /**< union for bags (max) (274) */
  BAG_UNION_DISJOINT, /**< disjoint union for bags (sum) (275) */
  BAG_INTER_MIN, /**< bag intersection (min) (276) */
  BAG_DIFFERENCE_SUBTRACT, /**< bag difference1 (subtracts multiplicities) (277) */
  BAG_DIFFERENCE_REMOVE, /**< bag difference remove (removes shared elements) (278) */
  BAG_SUBBAG, /**< inclusion predicate for bags (less than or equal multiplicities) (279) */
  BAG_COUNT, /**< multiplicity of an element in a bag (280) */
  BAG_MEMBER, /**< bag membership predicate; is first parameter a member of second? (281) */
  BAG_DUPLICATE_REMOVAL, /**< eliminate duplicates in a bag (also known as the delta operator,or the squash operator) (282) */
  BAG_MAKE, /**< constructs a bag from one element along with its multiplicity (283) */
  BAG_IS_SINGLETON, /**< return whether the given bag is a singleton (284) */
  BAG_CARD, /**< bag cardinality operator (285) */
  BAG_FROM_SET, /**< converts a set to a bag (286) */
  BAG_TO_SET, /**< converts a bag to a set (287) */
  BAG_CHOOSE, /**< return an element in the bag given as a parameter (288) */
  BAG_MAP, /**< bag map function (289) */
  BAG_FILTER, /**< bag filter operator (290) */
  BAG_FOLD, /**< bag fold operator (291) */
  BAG_PARTITION, /**< bag partition operator (292) */
  TABLE_PRODUCT, /**< table cross product (293) */
  TABLE_PROJECT_OP, /**< theory/datatypes/project_op.h (294) */
  TABLE_PROJECT, /**< table projection (295) */
  TABLE_AGGREGATE_OP, /**< theory/datatypes/project_op.h (296) */
  TABLE_AGGREGATE, /**< table aggregate (297) */
  TABLE_JOIN_OP, /**< theory/datatypes/project_op.h (298) */
  TABLE_JOIN, /**< table join (299) */
  TABLE_GROUP_OP, /**< theory/datatypes/project_op.h (300) */
  TABLE_GROUP, /**< table group (301) */

  /* from strings */
  STRING_CONCAT, /**< string concat (N-ary) (302) */
  STRING_IN_REGEXP, /**< membership (303) */
  STRING_LENGTH, /**< string length (304) */
  STRING_SUBSTR, /**< string substr (305) */
  STRING_UPDATE, /**< string update (306) */
  STRING_CHARAT, /**< string charat (307) */
  STRING_CONTAINS, /**< string contains (308) */
  STRING_LT, /**< string less than (309) */
  STRING_LEQ, /**< string less than or equal (310) */
  STRING_INDEXOF, /**< string index of substring (311) */
  STRING_INDEXOF_RE, /**< string index of regular expression match (312) */
  STRING_REPLACE, /**< string replace (313) */
  STRING_REPLACE_ALL, /**< string replace all (314) */
  STRING_REPLACE_RE, /**< string replace regular expression match (315) */
  STRING_REPLACE_RE_ALL, /**< string replace all regular expression matches (316) */
  STRING_PREFIX, /**< string prefixof (317) */
  STRING_SUFFIX, /**< string suffixof (318) */
  STRING_IS_DIGIT, /**< string isdigit, returns true if argument is a string of length one that represents a digit (319) */
  STRING_ITOS, /**< integer to string (320) */
  STRING_STOI, /**< string to integer (total function) (321) */
  STRING_TO_CODE, /**< string to code, returns the code of the first character of the string if it has length one, -1 otherwise (322) */
  STRING_FROM_CODE, /**< string from code, returns a string containing a single character whose code point matches the argument to this function, empty string if the argument is not a valid code point (323) */
  STRING_UNIT, /**< string unit, returns a string containing a single character whose code point matches the argument to this function, arbitrary string of length one if the argument is not a valid code point (324) */
  STRING_TO_LOWER, /**< string to lowercase conversion (325) */
  STRING_TO_UPPER, /**< string to uppercase conversion (326) */
  STRING_REV, /**< string reverse (327) */
  CONST_STRING, /**< util/string.h (328) */
  SEQUENCE_TYPE, /**< seuence type, takes as parameter the type of the elements (329) */
  CONST_SEQUENCE, /**< expr/sequence.h (330) */
  SEQ_UNIT, /**< a sequence of length one. First parameter is a term (331) */
  SEQ_NTH, /**< The nth element of a sequence (332) */
  STRING_TO_REGEXP, /**< convert string to regexp (333) */
  REGEXP_CONCAT, /**< regexp concat (334) */
  REGEXP_UNION, /**< regexp union (335) */
  REGEXP_INTER, /**< regexp intersection (336) */
  REGEXP_DIFF, /**< regexp difference (337) */
  REGEXP_STAR, /**< regexp * (338) */
  REGEXP_PLUS, /**< regexp + (339) */
  REGEXP_OPT, /**< regexp ? (340) */
  REGEXP_RANGE, /**< regexp range (341) */
  REGEXP_COMPLEMENT, /**< regexp complement (342) */
  REGEXP_NONE, /**< regexp empty (343) */
  REGEXP_ALL, /**< regexp all (344) */
  REGEXP_ALLCHAR, /**< regexp all characters (345) */
  REGEXP_REPEAT_OP, /**< util/regexp.h (346) */
  REGEXP_REPEAT, /**< regular expression repeat; first parameter is a REGEXP_REPEAT_OP, second is a regular expression term (347) */
  REGEXP_LOOP_OP, /**< util/regexp.h (348) */
  REGEXP_LOOP, /**< regular expression loop; first parameter is a REGEXP_LOOP_OP, second is a regular expression term (349) */
  REGEXP_RV, /**< regexp rv (internal use only) (350) */

  /* from quantifiers */
  FORALL, /**< universally quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (351) */
  EXISTS, /**< existentially quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (352) */
  INST_CONSTANT, /**< instantiation constant (353) */
  ORACLE, /**< oracle (354) */
  BOUND_VAR_LIST, /**< a list of bound variables (used to bind variables under a quantifier) (355) */
  INST_PATTERN, /**< instantiation pattern (356) */
  INST_NO_PATTERN, /**< instantiation no-pattern (357) */
  INST_ATTRIBUTE, /**< instantiation attribute (358) */
  INST_POOL, /**< instantiation pool (359) */
  INST_ADD_TO_POOL, /**< instantiation add to pool (360) */
  SKOLEM_ADD_TO_POOL, /**< skolemization add to pool (361) */
  ORACLE_FORMULA_GEN, /**< oracle interface (362) */
  INST_PATTERN_LIST, /**< a list of instantiation patterns (363) */
 LAST_KIND /**< marks the upper-bound of this enumeration */
  // clang-format on

}; /* enum Kind_t */

}  // namespace kind

// import Kind into the "cvc5" namespace but keep the individual kind
// constants under kind::
typedef cvc5::internal::kind::Kind_t Kind;

namespace kind {

/**
 * Converts an kind to a string. Note: This function is also used in
 * `safe_print()`. Changing this functions name or signature will result in
 * `safe_print()` printing "<unsupported>" instead of the proper strings for
 * the enum values.
 *
 * @param k The kind
 * @return The name of the kind
 */
const char* toString(cvc5::internal::Kind k);

/**
 * Writes a kind name to a stream.
 *
 * @param out The stream to write to
 * @param k The kind to write to the stream
 * @return The stream
 */
std::ostream& operator<<(std::ostream&, cvc5::internal::Kind);

/** Returns true if the given kind is associative. This is used by ExprManager to
 * decide whether it's safe to modify big expressions by changing the grouping of
 * the arguments. */
/* TODO: This could be generated. */
bool isAssociative(cvc5::internal::Kind k);
std::string kindToString(cvc5::internal::Kind k);

struct KindHashFunction
{
  inline size_t operator()(cvc5::internal::Kind k) const { return k; }
}; /* struct KindHashFunction */

}  // namespace kind

/**
 * The enumeration for the built-in atomic types.
 */
enum TypeConstant
{
  // clang-format off
    BUILTIN_OPERATOR_TYPE, /**< the type for built-in operators */
  SEXPR_TYPE, /**< the type of a symbolic expression */
  BOOLEAN_TYPE, /**< Boolean type */
  REAL_TYPE, /**< real type */
  INTEGER_TYPE, /**< integer type */
  ROUNDINGMODE_TYPE, /**< floating-point rounding mode */
  STRING_TYPE, /**< String type */
  REGEXP_TYPE, /**< RegExp type */
  BOUND_VAR_LIST_TYPE, /**< the type of bound variable lists */
  INST_PATTERN_TYPE, /**< instantiation pattern type */
  INST_PATTERN_LIST_TYPE, /**< the type of instantiation pattern lists */
 LAST_TYPE
  // clang-format on
}; /* enum TypeConstant */

/**
 * We hash the constants with their values.
 */
struct TypeConstantHashFunction
{
  inline size_t operator()(TypeConstant tc) const { return tc; }
}; /* struct TypeConstantHashFunction */

const char* toString(TypeConstant tc);
std::ostream& operator<<(std::ostream& out, TypeConstant typeConstant);

namespace theory {

cvc5::internal::theory::TheoryId kindToTheoryId(cvc5::internal::Kind k);
cvc5::internal::theory::TheoryId typeConstantToTheoryId(
    cvc5::internal::TypeConstant typeConstant);

}  // namespace theory
}  // namespace cvc5::internal

#endif /* CVC5__KIND_H */
