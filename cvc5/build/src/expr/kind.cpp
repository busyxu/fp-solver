/******************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2010-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * This header file was automatically generated by:
 *
 *     ../../../src/expr/mkkind /home/aaa/fp-solver/cvc5/src/expr/kind_template.cpp /home/aaa/fp-solver/cvc5/src/theory/builtin/kinds /home/aaa/fp-solver/cvc5/src/theory/booleans/kinds /home/aaa/fp-solver/cvc5/src/theory/uf/kinds /home/aaa/fp-solver/cvc5/src/theory/arith/kinds /home/aaa/fp-solver/cvc5/src/theory/bv/kinds /home/aaa/fp-solver/cvc5/src/theory/ff/kinds /home/aaa/fp-solver/cvc5/src/theory/fp/kinds /home/aaa/fp-solver/cvc5/src/theory/arrays/kinds /home/aaa/fp-solver/cvc5/src/theory/datatypes/kinds /home/aaa/fp-solver/cvc5/src/theory/sep/kinds /home/aaa/fp-solver/cvc5/src/theory/sets/kinds /home/aaa/fp-solver/cvc5/src/theory/bags/kinds /home/aaa/fp-solver/cvc5/src/theory/strings/kinds /home/aaa/fp-solver/cvc5/src/theory/quantifiers/kinds
 *
 * for the cvc5 project.
 */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/aaa/fp-solver/cvc5/src/expr/kind_template.cpp */

/******************************************************************************
 * Top contributors (to current version):
 *   Andres Noetzli, Aina Niemetz, Mathias Preiner
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * [[ Add one-line brief description here ]]
 *
 * [[ Add lengthier description here ]]
 * \todo document this file
 */

#include <sstream>

#include "expr/kind.h"
#include "printer/printer.h"

namespace cvc5::internal {
namespace kind {

const char* toString(cvc5::internal::Kind k)
{
  using namespace cvc5::internal::kind;

  switch (k)
  {
    /* special cases */
    case UNDEFINED_KIND: return "UNDEFINED_KIND";
    case NULL_EXPR: return "NULL";
      // clang-format off
    
  /* from builtin */
  case SORT_TYPE: return "SORT_TYPE";
  case INSTANTIATED_SORT_TYPE: return "INSTANTIATED_SORT_TYPE";
  case UNINTERPRETED_SORT_VALUE: return "UNINTERPRETED_SORT_VALUE";
  case BUILTIN: return "BUILTIN";
  case EQUAL: return "EQUAL";
  case DISTINCT: return "DISTINCT";
  case VARIABLE: return "VARIABLE";
  case BOUND_VARIABLE: return "BOUND_VARIABLE";
  case SKOLEM: return "SKOLEM";
  case SEXPR: return "SEXPR";
  case WITNESS: return "WITNESS";
  case TYPE_CONSTANT: return "TYPE_CONSTANT";
  case RAW_SYMBOL: return "RAW_SYMBOL";
  case ABSTRACT_TYPE: return "ABSTRACT_TYPE";
  case APPLY_INDEXED_SYMBOLIC_OP: return "APPLY_INDEXED_SYMBOLIC_OP";
  case APPLY_INDEXED_SYMBOLIC: return "APPLY_INDEXED_SYMBOLIC";

  /* from booleans */
  case CONST_BOOLEAN: return "CONST_BOOLEAN";
  case NOT: return "NOT";
  case AND: return "AND";
  case IMPLIES: return "IMPLIES";
  case OR: return "OR";
  case XOR: return "XOR";
  case ITE: return "ITE";

  /* from uf */
  case APPLY_UF: return "APPLY_UF";
  case FUNCTION_TYPE: return "FUNCTION_TYPE";
  case LAMBDA: return "LAMBDA";
  case BOOLEAN_TERM_VARIABLE: return "BOOLEAN_TERM_VARIABLE";
  case HO_APPLY: return "HO_APPLY";
  case CARDINALITY_CONSTRAINT_OP: return "CARDINALITY_CONSTRAINT_OP";
  case CARDINALITY_CONSTRAINT: return "CARDINALITY_CONSTRAINT";
  case COMBINED_CARDINALITY_CONSTRAINT_OP: return "COMBINED_CARDINALITY_CONSTRAINT_OP";
  case COMBINED_CARDINALITY_CONSTRAINT: return "COMBINED_CARDINALITY_CONSTRAINT";
  case FUNCTION_ARRAY_CONST: return "FUNCTION_ARRAY_CONST";
  case BITVECTOR_TO_NAT: return "BITVECTOR_TO_NAT";
  case INT_TO_BITVECTOR_OP: return "INT_TO_BITVECTOR_OP";
  case INT_TO_BITVECTOR: return "INT_TO_BITVECTOR";

  /* from arith */
  case ADD: return "ADD";
  case MULT: return "MULT";
  case NONLINEAR_MULT: return "NONLINEAR_MULT";
  case SUB: return "SUB";
  case NEG: return "NEG";
  case DIVISION: return "DIVISION";
  case DIVISION_TOTAL: return "DIVISION_TOTAL";
  case INTS_DIVISION: return "INTS_DIVISION";
  case INTS_DIVISION_TOTAL: return "INTS_DIVISION_TOTAL";
  case INTS_MODULUS: return "INTS_MODULUS";
  case INTS_MODULUS_TOTAL: return "INTS_MODULUS_TOTAL";
  case ABS: return "ABS";
  case DIVISIBLE: return "DIVISIBLE";
  case POW: return "POW";
  case POW2: return "POW2";
  case EXPONENTIAL: return "EXPONENTIAL";
  case SINE: return "SINE";
  case COSINE: return "COSINE";
  case TANGENT: return "TANGENT";
  case COSECANT: return "COSECANT";
  case SECANT: return "SECANT";
  case COTANGENT: return "COTANGENT";
  case ARCSINE: return "ARCSINE";
  case ARCCOSINE: return "ARCCOSINE";
  case ARCTANGENT: return "ARCTANGENT";
  case ARCCOSECANT: return "ARCCOSECANT";
  case ARCSECANT: return "ARCSECANT";
  case ARCCOTANGENT: return "ARCCOTANGENT";
  case SQRT: return "SQRT";
  case DIVISIBLE_OP: return "DIVISIBLE_OP";
  case CONST_RATIONAL: return "CONST_RATIONAL";
  case CONST_INTEGER: return "CONST_INTEGER";
  case REAL_ALGEBRAIC_NUMBER_OP: return "REAL_ALGEBRAIC_NUMBER_OP";
  case REAL_ALGEBRAIC_NUMBER: return "REAL_ALGEBRAIC_NUMBER";
  case LT: return "LT";
  case LEQ: return "LEQ";
  case GT: return "GT";
  case GEQ: return "GEQ";
  case INDEXED_ROOT_PREDICATE_OP: return "INDEXED_ROOT_PREDICATE_OP";
  case INDEXED_ROOT_PREDICATE: return "INDEXED_ROOT_PREDICATE";
  case IS_INTEGER: return "IS_INTEGER";
  case TO_INTEGER: return "TO_INTEGER";
  case TO_REAL: return "TO_REAL";
  case PI: return "PI";
  case IAND_OP: return "IAND_OP";
  case IAND: return "IAND";

  /* from bv */
  case BITVECTOR_TYPE: return "BITVECTOR_TYPE";
  case CONST_BITVECTOR: return "CONST_BITVECTOR";
  case BITVECTOR_BB_TERM: return "BITVECTOR_BB_TERM";
  case BITVECTOR_CONCAT: return "BITVECTOR_CONCAT";
  case BITVECTOR_AND: return "BITVECTOR_AND";
  case BITVECTOR_COMP: return "BITVECTOR_COMP";
  case BITVECTOR_OR: return "BITVECTOR_OR";
  case BITVECTOR_XOR: return "BITVECTOR_XOR";
  case BITVECTOR_NOT: return "BITVECTOR_NOT";
  case BITVECTOR_NAND: return "BITVECTOR_NAND";
  case BITVECTOR_NOR: return "BITVECTOR_NOR";
  case BITVECTOR_XNOR: return "BITVECTOR_XNOR";
  case BITVECTOR_MULT: return "BITVECTOR_MULT";
  case BITVECTOR_NEG: return "BITVECTOR_NEG";
  case BITVECTOR_ADD: return "BITVECTOR_ADD";
  case BITVECTOR_SUB: return "BITVECTOR_SUB";
  case BITVECTOR_UDIV: return "BITVECTOR_UDIV";
  case BITVECTOR_UREM: return "BITVECTOR_UREM";
  case BITVECTOR_SDIV: return "BITVECTOR_SDIV";
  case BITVECTOR_SMOD: return "BITVECTOR_SMOD";
  case BITVECTOR_SREM: return "BITVECTOR_SREM";
  case BITVECTOR_ASHR: return "BITVECTOR_ASHR";
  case BITVECTOR_LSHR: return "BITVECTOR_LSHR";
  case BITVECTOR_SHL: return "BITVECTOR_SHL";
  case BITVECTOR_ULE: return "BITVECTOR_ULE";
  case BITVECTOR_ULT: return "BITVECTOR_ULT";
  case BITVECTOR_UGE: return "BITVECTOR_UGE";
  case BITVECTOR_UGT: return "BITVECTOR_UGT";
  case BITVECTOR_SLE: return "BITVECTOR_SLE";
  case BITVECTOR_SLT: return "BITVECTOR_SLT";
  case BITVECTOR_SGE: return "BITVECTOR_SGE";
  case BITVECTOR_SGT: return "BITVECTOR_SGT";
  case BITVECTOR_ULTBV: return "BITVECTOR_ULTBV";
  case BITVECTOR_SLTBV: return "BITVECTOR_SLTBV";
  case BITVECTOR_REDAND: return "BITVECTOR_REDAND";
  case BITVECTOR_REDOR: return "BITVECTOR_REDOR";
  case BITVECTOR_UADDO: return "BITVECTOR_UADDO";
  case BITVECTOR_SADDO: return "BITVECTOR_SADDO";
  case BITVECTOR_UMULO: return "BITVECTOR_UMULO";
  case BITVECTOR_SMULO: return "BITVECTOR_SMULO";
  case BITVECTOR_USUBO: return "BITVECTOR_USUBO";
  case BITVECTOR_SSUBO: return "BITVECTOR_SSUBO";
  case BITVECTOR_SDIVO: return "BITVECTOR_SDIVO";
  case BITVECTOR_ITE: return "BITVECTOR_ITE";
  case BITVECTOR_ACKERMANNIZE_UDIV: return "BITVECTOR_ACKERMANNIZE_UDIV";
  case BITVECTOR_ACKERMANNIZE_UREM: return "BITVECTOR_ACKERMANNIZE_UREM";
  case BITVECTOR_EAGER_ATOM: return "BITVECTOR_EAGER_ATOM";
  case BITVECTOR_BITOF_OP: return "BITVECTOR_BITOF_OP";
  case BITVECTOR_BITOF: return "BITVECTOR_BITOF";
  case BITVECTOR_EXTRACT_OP: return "BITVECTOR_EXTRACT_OP";
  case BITVECTOR_EXTRACT: return "BITVECTOR_EXTRACT";
  case BITVECTOR_REPEAT_OP: return "BITVECTOR_REPEAT_OP";
  case BITVECTOR_REPEAT: return "BITVECTOR_REPEAT";
  case BITVECTOR_ROTATE_LEFT_OP: return "BITVECTOR_ROTATE_LEFT_OP";
  case BITVECTOR_ROTATE_LEFT: return "BITVECTOR_ROTATE_LEFT";
  case BITVECTOR_ROTATE_RIGHT_OP: return "BITVECTOR_ROTATE_RIGHT_OP";
  case BITVECTOR_ROTATE_RIGHT: return "BITVECTOR_ROTATE_RIGHT";
  case BITVECTOR_SIGN_EXTEND_OP: return "BITVECTOR_SIGN_EXTEND_OP";
  case BITVECTOR_SIGN_EXTEND: return "BITVECTOR_SIGN_EXTEND";
  case BITVECTOR_ZERO_EXTEND_OP: return "BITVECTOR_ZERO_EXTEND_OP";
  case BITVECTOR_ZERO_EXTEND: return "BITVECTOR_ZERO_EXTEND";

  /* from ff */
  case FINITE_FIELD_TYPE: return "FINITE_FIELD_TYPE";
  case CONST_FINITE_FIELD: return "CONST_FINITE_FIELD";
  case FINITE_FIELD_MULT: return "FINITE_FIELD_MULT";
  case FINITE_FIELD_NEG: return "FINITE_FIELD_NEG";
  case FINITE_FIELD_ADD: return "FINITE_FIELD_ADD";

  /* from fp */
  case CONST_FLOATINGPOINT: return "CONST_FLOATINGPOINT";
  case CONST_ROUNDINGMODE: return "CONST_ROUNDINGMODE";
  case FLOATINGPOINT_TYPE: return "FLOATINGPOINT_TYPE";
  case FLOATINGPOINT_FP: return "FLOATINGPOINT_FP";
  case FLOATINGPOINT_EQ: return "FLOATINGPOINT_EQ";
  case FLOATINGPOINT_ABS: return "FLOATINGPOINT_ABS";
  case FLOATINGPOINT_NEG: return "FLOATINGPOINT_NEG";
  case FLOATINGPOINT_ADD: return "FLOATINGPOINT_ADD";
  case FLOATINGPOINT_SUB: return "FLOATINGPOINT_SUB";
  case FLOATINGPOINT_MULT: return "FLOATINGPOINT_MULT";
  case FLOATINGPOINT_DIV: return "FLOATINGPOINT_DIV";
  case FLOATINGPOINT_FMA: return "FLOATINGPOINT_FMA";
  case FLOATINGPOINT_SQRT: return "FLOATINGPOINT_SQRT";
  case FLOATINGPOINT_REM: return "FLOATINGPOINT_REM";
  case FLOATINGPOINT_RTI: return "FLOATINGPOINT_RTI";
  case FLOATINGPOINT_MIN: return "FLOATINGPOINT_MIN";
  case FLOATINGPOINT_MAX: return "FLOATINGPOINT_MAX";
  case FLOATINGPOINT_MIN_TOTAL: return "FLOATINGPOINT_MIN_TOTAL";
  case FLOATINGPOINT_MAX_TOTAL: return "FLOATINGPOINT_MAX_TOTAL";
  case FLOATINGPOINT_LEQ: return "FLOATINGPOINT_LEQ";
  case FLOATINGPOINT_LT: return "FLOATINGPOINT_LT";
  case FLOATINGPOINT_GEQ: return "FLOATINGPOINT_GEQ";
  case FLOATINGPOINT_GT: return "FLOATINGPOINT_GT";
  case FLOATINGPOINT_IS_NORMAL: return "FLOATINGPOINT_IS_NORMAL";
  case FLOATINGPOINT_IS_SUBNORMAL: return "FLOATINGPOINT_IS_SUBNORMAL";
  case FLOATINGPOINT_IS_ZERO: return "FLOATINGPOINT_IS_ZERO";
  case FLOATINGPOINT_IS_INF: return "FLOATINGPOINT_IS_INF";
  case FLOATINGPOINT_IS_NAN: return "FLOATINGPOINT_IS_NAN";
  case FLOATINGPOINT_IS_NEG: return "FLOATINGPOINT_IS_NEG";
  case FLOATINGPOINT_IS_POS: return "FLOATINGPOINT_IS_POS";
  case FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP: return "FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP";
  case FLOATINGPOINT_TO_FP_FROM_IEEE_BV: return "FLOATINGPOINT_TO_FP_FROM_IEEE_BV";
  case FLOATINGPOINT_TO_FP_FROM_FP_OP: return "FLOATINGPOINT_TO_FP_FROM_FP_OP";
  case FLOATINGPOINT_TO_FP_FROM_FP: return "FLOATINGPOINT_TO_FP_FROM_FP";
  case FLOATINGPOINT_TO_FP_FROM_REAL_OP: return "FLOATINGPOINT_TO_FP_FROM_REAL_OP";
  case FLOATINGPOINT_TO_FP_FROM_REAL: return "FLOATINGPOINT_TO_FP_FROM_REAL";
  case FLOATINGPOINT_TO_FP_FROM_SBV_OP: return "FLOATINGPOINT_TO_FP_FROM_SBV_OP";
  case FLOATINGPOINT_TO_FP_FROM_SBV: return "FLOATINGPOINT_TO_FP_FROM_SBV";
  case FLOATINGPOINT_TO_FP_FROM_UBV_OP: return "FLOATINGPOINT_TO_FP_FROM_UBV_OP";
  case FLOATINGPOINT_TO_FP_FROM_UBV: return "FLOATINGPOINT_TO_FP_FROM_UBV";
  case FLOATINGPOINT_TO_UBV_OP: return "FLOATINGPOINT_TO_UBV_OP";
  case FLOATINGPOINT_TO_UBV: return "FLOATINGPOINT_TO_UBV";
  case FLOATINGPOINT_TO_UBV_TOTAL_OP: return "FLOATINGPOINT_TO_UBV_TOTAL_OP";
  case FLOATINGPOINT_TO_UBV_TOTAL: return "FLOATINGPOINT_TO_UBV_TOTAL";
  case FLOATINGPOINT_TO_SBV_OP: return "FLOATINGPOINT_TO_SBV_OP";
  case FLOATINGPOINT_TO_SBV: return "FLOATINGPOINT_TO_SBV";
  case FLOATINGPOINT_TO_SBV_TOTAL_OP: return "FLOATINGPOINT_TO_SBV_TOTAL_OP";
  case FLOATINGPOINT_TO_SBV_TOTAL: return "FLOATINGPOINT_TO_SBV_TOTAL";
  case FLOATINGPOINT_TO_REAL: return "FLOATINGPOINT_TO_REAL";
  case FLOATINGPOINT_TO_REAL_TOTAL: return "FLOATINGPOINT_TO_REAL_TOTAL";
  case FLOATINGPOINT_COMPONENT_NAN: return "FLOATINGPOINT_COMPONENT_NAN";
  case FLOATINGPOINT_COMPONENT_INF: return "FLOATINGPOINT_COMPONENT_INF";
  case FLOATINGPOINT_COMPONENT_ZERO: return "FLOATINGPOINT_COMPONENT_ZERO";
  case FLOATINGPOINT_COMPONENT_SIGN: return "FLOATINGPOINT_COMPONENT_SIGN";
  case FLOATINGPOINT_COMPONENT_EXPONENT: return "FLOATINGPOINT_COMPONENT_EXPONENT";
  case FLOATINGPOINT_COMPONENT_SIGNIFICAND: return "FLOATINGPOINT_COMPONENT_SIGNIFICAND";
  case ROUNDINGMODE_BITBLAST: return "ROUNDINGMODE_BITBLAST";

  /* from arrays */
  case ARRAY_TYPE: return "ARRAY_TYPE";
  case SELECT: return "SELECT";
  case STORE: return "STORE";
  case EQ_RANGE: return "EQ_RANGE";
  case STORE_ALL: return "STORE_ALL";
  case ARRAY_LAMBDA: return "ARRAY_LAMBDA";

  /* from datatypes */
  case CONSTRUCTOR_TYPE: return "CONSTRUCTOR_TYPE";
  case SELECTOR_TYPE: return "SELECTOR_TYPE";
  case TESTER_TYPE: return "TESTER_TYPE";
  case UPDATER_TYPE: return "UPDATER_TYPE";
  case APPLY_CONSTRUCTOR: return "APPLY_CONSTRUCTOR";
  case APPLY_SELECTOR: return "APPLY_SELECTOR";
  case APPLY_TESTER: return "APPLY_TESTER";
  case APPLY_UPDATER: return "APPLY_UPDATER";
  case DATATYPE_TYPE: return "DATATYPE_TYPE";
  case PARAMETRIC_DATATYPE: return "PARAMETRIC_DATATYPE";
  case TUPLE_TYPE: return "TUPLE_TYPE";
  case APPLY_TYPE_ASCRIPTION: return "APPLY_TYPE_ASCRIPTION";
  case ASCRIPTION_TYPE: return "ASCRIPTION_TYPE";
  case DT_SIZE: return "DT_SIZE";
  case DT_HEIGHT_BOUND: return "DT_HEIGHT_BOUND";
  case DT_SIZE_BOUND: return "DT_SIZE_BOUND";
  case DT_SYGUS_BOUND: return "DT_SYGUS_BOUND";
  case DT_SYGUS_EVAL: return "DT_SYGUS_EVAL";
  case MATCH: return "MATCH";
  case MATCH_CASE: return "MATCH_CASE";
  case MATCH_BIND_CASE: return "MATCH_BIND_CASE";
  case TUPLE_PROJECT_OP: return "TUPLE_PROJECT_OP";
  case TUPLE_PROJECT: return "TUPLE_PROJECT";
  case CODATATYPE_BOUND_VARIABLE: return "CODATATYPE_BOUND_VARIABLE";

  /* from sep */
  case SEP_NIL: return "SEP_NIL";
  case SEP_EMP: return "SEP_EMP";
  case SEP_PTO: return "SEP_PTO";
  case SEP_STAR: return "SEP_STAR";
  case SEP_WAND: return "SEP_WAND";
  case SEP_LABEL: return "SEP_LABEL";

  /* from sets */
  case SET_EMPTY: return "SET_EMPTY";
  case SET_TYPE: return "SET_TYPE";
  case SET_UNION: return "SET_UNION";
  case SET_INTER: return "SET_INTER";
  case SET_MINUS: return "SET_MINUS";
  case SET_SUBSET: return "SET_SUBSET";
  case SET_MEMBER: return "SET_MEMBER";
  case SET_SINGLETON: return "SET_SINGLETON";
  case SET_INSERT: return "SET_INSERT";
  case SET_CARD: return "SET_CARD";
  case SET_COMPLEMENT: return "SET_COMPLEMENT";
  case SET_UNIVERSE: return "SET_UNIVERSE";
  case SET_COMPREHENSION: return "SET_COMPREHENSION";
  case SET_CHOOSE: return "SET_CHOOSE";
  case SET_IS_SINGLETON: return "SET_IS_SINGLETON";
  case SET_MAP: return "SET_MAP";
  case SET_FILTER: return "SET_FILTER";
  case SET_FOLD: return "SET_FOLD";
  case RELATION_GROUP_OP: return "RELATION_GROUP_OP";
  case RELATION_GROUP: return "RELATION_GROUP";
  case RELATION_AGGREGATE_OP: return "RELATION_AGGREGATE_OP";
  case RELATION_AGGREGATE: return "RELATION_AGGREGATE";
  case RELATION_PROJECT_OP: return "RELATION_PROJECT_OP";
  case RELATION_PROJECT: return "RELATION_PROJECT";
  case RELATION_JOIN: return "RELATION_JOIN";
  case RELATION_PRODUCT: return "RELATION_PRODUCT";
  case RELATION_TRANSPOSE: return "RELATION_TRANSPOSE";
  case RELATION_TCLOSURE: return "RELATION_TCLOSURE";
  case RELATION_JOIN_IMAGE: return "RELATION_JOIN_IMAGE";
  case RELATION_IDEN: return "RELATION_IDEN";

  /* from bags */
  case BAG_EMPTY: return "BAG_EMPTY";
  case BAG_TYPE: return "BAG_TYPE";
  case BAG_UNION_MAX: return "BAG_UNION_MAX";
  case BAG_UNION_DISJOINT: return "BAG_UNION_DISJOINT";
  case BAG_INTER_MIN: return "BAG_INTER_MIN";
  case BAG_DIFFERENCE_SUBTRACT: return "BAG_DIFFERENCE_SUBTRACT";
  case BAG_DIFFERENCE_REMOVE: return "BAG_DIFFERENCE_REMOVE";
  case BAG_SUBBAG: return "BAG_SUBBAG";
  case BAG_COUNT: return "BAG_COUNT";
  case BAG_MEMBER: return "BAG_MEMBER";
  case BAG_DUPLICATE_REMOVAL: return "BAG_DUPLICATE_REMOVAL";
  case BAG_MAKE: return "BAG_MAKE";
  case BAG_IS_SINGLETON: return "BAG_IS_SINGLETON";
  case BAG_CARD: return "BAG_CARD";
  case BAG_FROM_SET: return "BAG_FROM_SET";
  case BAG_TO_SET: return "BAG_TO_SET";
  case BAG_CHOOSE: return "BAG_CHOOSE";
  case BAG_MAP: return "BAG_MAP";
  case BAG_FILTER: return "BAG_FILTER";
  case BAG_FOLD: return "BAG_FOLD";
  case BAG_PARTITION: return "BAG_PARTITION";
  case TABLE_PRODUCT: return "TABLE_PRODUCT";
  case TABLE_PROJECT_OP: return "TABLE_PROJECT_OP";
  case TABLE_PROJECT: return "TABLE_PROJECT";
  case TABLE_AGGREGATE_OP: return "TABLE_AGGREGATE_OP";
  case TABLE_AGGREGATE: return "TABLE_AGGREGATE";
  case TABLE_JOIN_OP: return "TABLE_JOIN_OP";
  case TABLE_JOIN: return "TABLE_JOIN";
  case TABLE_GROUP_OP: return "TABLE_GROUP_OP";
  case TABLE_GROUP: return "TABLE_GROUP";

  /* from strings */
  case STRING_CONCAT: return "STRING_CONCAT";
  case STRING_IN_REGEXP: return "STRING_IN_REGEXP";
  case STRING_LENGTH: return "STRING_LENGTH";
  case STRING_SUBSTR: return "STRING_SUBSTR";
  case STRING_UPDATE: return "STRING_UPDATE";
  case STRING_CHARAT: return "STRING_CHARAT";
  case STRING_CONTAINS: return "STRING_CONTAINS";
  case STRING_LT: return "STRING_LT";
  case STRING_LEQ: return "STRING_LEQ";
  case STRING_INDEXOF: return "STRING_INDEXOF";
  case STRING_INDEXOF_RE: return "STRING_INDEXOF_RE";
  case STRING_REPLACE: return "STRING_REPLACE";
  case STRING_REPLACE_ALL: return "STRING_REPLACE_ALL";
  case STRING_REPLACE_RE: return "STRING_REPLACE_RE";
  case STRING_REPLACE_RE_ALL: return "STRING_REPLACE_RE_ALL";
  case STRING_PREFIX: return "STRING_PREFIX";
  case STRING_SUFFIX: return "STRING_SUFFIX";
  case STRING_IS_DIGIT: return "STRING_IS_DIGIT";
  case STRING_ITOS: return "STRING_ITOS";
  case STRING_STOI: return "STRING_STOI";
  case STRING_TO_CODE: return "STRING_TO_CODE";
  case STRING_FROM_CODE: return "STRING_FROM_CODE";
  case STRING_UNIT: return "STRING_UNIT";
  case STRING_TO_LOWER: return "STRING_TO_LOWER";
  case STRING_TO_UPPER: return "STRING_TO_UPPER";
  case STRING_REV: return "STRING_REV";
  case CONST_STRING: return "CONST_STRING";
  case SEQUENCE_TYPE: return "SEQUENCE_TYPE";
  case CONST_SEQUENCE: return "CONST_SEQUENCE";
  case SEQ_UNIT: return "SEQ_UNIT";
  case SEQ_NTH: return "SEQ_NTH";
  case STRING_TO_REGEXP: return "STRING_TO_REGEXP";
  case REGEXP_CONCAT: return "REGEXP_CONCAT";
  case REGEXP_UNION: return "REGEXP_UNION";
  case REGEXP_INTER: return "REGEXP_INTER";
  case REGEXP_DIFF: return "REGEXP_DIFF";
  case REGEXP_STAR: return "REGEXP_STAR";
  case REGEXP_PLUS: return "REGEXP_PLUS";
  case REGEXP_OPT: return "REGEXP_OPT";
  case REGEXP_RANGE: return "REGEXP_RANGE";
  case REGEXP_COMPLEMENT: return "REGEXP_COMPLEMENT";
  case REGEXP_NONE: return "REGEXP_NONE";
  case REGEXP_ALL: return "REGEXP_ALL";
  case REGEXP_ALLCHAR: return "REGEXP_ALLCHAR";
  case REGEXP_REPEAT_OP: return "REGEXP_REPEAT_OP";
  case REGEXP_REPEAT: return "REGEXP_REPEAT";
  case REGEXP_LOOP_OP: return "REGEXP_LOOP_OP";
  case REGEXP_LOOP: return "REGEXP_LOOP";
  case REGEXP_RV: return "REGEXP_RV";

  /* from quantifiers */
  case FORALL: return "FORALL";
  case EXISTS: return "EXISTS";
  case INST_CONSTANT: return "INST_CONSTANT";
  case ORACLE: return "ORACLE";
  case BOUND_VAR_LIST: return "BOUND_VAR_LIST";
  case INST_PATTERN: return "INST_PATTERN";
  case INST_NO_PATTERN: return "INST_NO_PATTERN";
  case INST_ATTRIBUTE: return "INST_ATTRIBUTE";
  case INST_POOL: return "INST_POOL";
  case INST_ADD_TO_POOL: return "INST_ADD_TO_POOL";
  case SKOLEM_ADD_TO_POOL: return "SKOLEM_ADD_TO_POOL";
  case ORACLE_FORMULA_GEN: return "ORACLE_FORMULA_GEN";
  case INST_PATTERN_LIST: return "INST_PATTERN_LIST";

      // clang-format on
    case LAST_KIND: return "LAST_KIND";
    default: return "?";
  }
}

std::ostream& operator<<(std::ostream& out, cvc5::internal::Kind k)
{
  Printer::getPrinter(out)->toStream(out, k);
  return out;
}

/** Returns true if the given kind is associative. This is used by ExprManager to
 * decide whether it's safe to modify big expressions by changing the grouping of
 * the arguments. */
/* TODO: This could be generated. */
bool isAssociative(cvc5::internal::Kind k)
{
  switch(k) {
  case kind::AND:
  case kind::OR:
  case kind::MULT:
  case kind::ADD: return true;

  default:
    return false;
  }
}

std::string kindToString(cvc5::internal::Kind k) { return toString(k); }

}  // namespace kind

const char* toString(TypeConstant tc)
{
  switch (tc)
  {
    // clang-format off
      case BUILTIN_OPERATOR_TYPE: return "the type for built-in operators";
  case SEXPR_TYPE: return "the type of a symbolic expression";
  case BOOLEAN_TYPE: return "Boolean type";
  case REAL_TYPE: return "real type";
  case INTEGER_TYPE: return "integer type";
  case ROUNDINGMODE_TYPE: return "floating-point rounding mode";
  case STRING_TYPE: return "String type";
  case REGEXP_TYPE: return "RegExp type";
  case BOUND_VAR_LIST_TYPE: return "the type of bound variable lists";
  case INST_PATTERN_TYPE: return "instantiation pattern type";
  case INST_PATTERN_LIST_TYPE: return "the type of instantiation pattern lists";

      // clang-format on
    default: return "UNKNOWN_TYPE_CONSTANT";
  }
}
std::ostream& operator<<(std::ostream& out, TypeConstant typeConstant)
{
  return out << toString(typeConstant);
}

namespace theory {

TheoryId kindToTheoryId(cvc5::internal::Kind k)
{
  switch (k)
  {
    case kind::UNDEFINED_KIND:
    case kind::NULL_EXPR:
      break;
      // clang-format off
  case kind::SORT_TYPE: return THEORY_BUILTIN;
  case kind::INSTANTIATED_SORT_TYPE: return THEORY_BUILTIN;
  case kind::UNINTERPRETED_SORT_VALUE: return THEORY_BUILTIN;
  case kind::BUILTIN: return THEORY_BUILTIN;
  case kind::EQUAL: return THEORY_BUILTIN;
  case kind::DISTINCT: return THEORY_BUILTIN;
  case kind::VARIABLE: return THEORY_BUILTIN;
  case kind::BOUND_VARIABLE: return THEORY_BUILTIN;
  case kind::SKOLEM: return THEORY_BUILTIN;
  case kind::SEXPR: return THEORY_BUILTIN;
  case kind::WITNESS: return THEORY_BUILTIN;
  case kind::TYPE_CONSTANT: return THEORY_BUILTIN;
  case kind::RAW_SYMBOL: return THEORY_BUILTIN;
  case kind::ABSTRACT_TYPE: return THEORY_BUILTIN;
  case kind::APPLY_INDEXED_SYMBOLIC_OP: return THEORY_BUILTIN;
  case kind::APPLY_INDEXED_SYMBOLIC: return THEORY_BUILTIN;
  case kind::CONST_BOOLEAN: return THEORY_BOOL;
  case kind::NOT: return THEORY_BOOL;
  case kind::AND: return THEORY_BOOL;
  case kind::IMPLIES: return THEORY_BOOL;
  case kind::OR: return THEORY_BOOL;
  case kind::XOR: return THEORY_BOOL;
  case kind::ITE: return THEORY_BOOL;
  case kind::APPLY_UF: return THEORY_UF;
  case kind::FUNCTION_TYPE: return THEORY_UF;
  case kind::LAMBDA: return THEORY_UF;
  case kind::BOOLEAN_TERM_VARIABLE: return THEORY_UF;
  case kind::HO_APPLY: return THEORY_UF;
  case kind::CARDINALITY_CONSTRAINT_OP: return THEORY_UF;
  case kind::CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::COMBINED_CARDINALITY_CONSTRAINT_OP: return THEORY_UF;
  case kind::COMBINED_CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::FUNCTION_ARRAY_CONST: return THEORY_UF;
  case kind::BITVECTOR_TO_NAT: return THEORY_UF;
  case kind::INT_TO_BITVECTOR_OP: return THEORY_UF;
  case kind::INT_TO_BITVECTOR: return THEORY_UF;
  case kind::ADD: return THEORY_ARITH;
  case kind::MULT: return THEORY_ARITH;
  case kind::NONLINEAR_MULT: return THEORY_ARITH;
  case kind::SUB: return THEORY_ARITH;
  case kind::NEG: return THEORY_ARITH;
  case kind::DIVISION: return THEORY_ARITH;
  case kind::DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_DIVISION: return THEORY_ARITH;
  case kind::INTS_DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_MODULUS: return THEORY_ARITH;
  case kind::INTS_MODULUS_TOTAL: return THEORY_ARITH;
  case kind::ABS: return THEORY_ARITH;
  case kind::DIVISIBLE: return THEORY_ARITH;
  case kind::POW: return THEORY_ARITH;
  case kind::POW2: return THEORY_ARITH;
  case kind::EXPONENTIAL: return THEORY_ARITH;
  case kind::SINE: return THEORY_ARITH;
  case kind::COSINE: return THEORY_ARITH;
  case kind::TANGENT: return THEORY_ARITH;
  case kind::COSECANT: return THEORY_ARITH;
  case kind::SECANT: return THEORY_ARITH;
  case kind::COTANGENT: return THEORY_ARITH;
  case kind::ARCSINE: return THEORY_ARITH;
  case kind::ARCCOSINE: return THEORY_ARITH;
  case kind::ARCTANGENT: return THEORY_ARITH;
  case kind::ARCCOSECANT: return THEORY_ARITH;
  case kind::ARCSECANT: return THEORY_ARITH;
  case kind::ARCCOTANGENT: return THEORY_ARITH;
  case kind::SQRT: return THEORY_ARITH;
  case kind::DIVISIBLE_OP: return THEORY_ARITH;
  case kind::CONST_RATIONAL: return THEORY_ARITH;
  case kind::CONST_INTEGER: return THEORY_ARITH;
  case kind::REAL_ALGEBRAIC_NUMBER_OP: return THEORY_ARITH;
  case kind::REAL_ALGEBRAIC_NUMBER: return THEORY_ARITH;
  case kind::LT: return THEORY_ARITH;
  case kind::LEQ: return THEORY_ARITH;
  case kind::GT: return THEORY_ARITH;
  case kind::GEQ: return THEORY_ARITH;
  case kind::INDEXED_ROOT_PREDICATE_OP: return THEORY_ARITH;
  case kind::INDEXED_ROOT_PREDICATE: return THEORY_ARITH;
  case kind::IS_INTEGER: return THEORY_ARITH;
  case kind::TO_INTEGER: return THEORY_ARITH;
  case kind::TO_REAL: return THEORY_ARITH;
  case kind::PI: return THEORY_ARITH;
  case kind::IAND_OP: return THEORY_ARITH;
  case kind::IAND: return THEORY_ARITH;
  case kind::BITVECTOR_TYPE: return THEORY_BV;
  case kind::CONST_BITVECTOR: return THEORY_BV;
  case kind::BITVECTOR_BB_TERM: return THEORY_BV;
  case kind::BITVECTOR_CONCAT: return THEORY_BV;
  case kind::BITVECTOR_AND: return THEORY_BV;
  case kind::BITVECTOR_COMP: return THEORY_BV;
  case kind::BITVECTOR_OR: return THEORY_BV;
  case kind::BITVECTOR_XOR: return THEORY_BV;
  case kind::BITVECTOR_NOT: return THEORY_BV;
  case kind::BITVECTOR_NAND: return THEORY_BV;
  case kind::BITVECTOR_NOR: return THEORY_BV;
  case kind::BITVECTOR_XNOR: return THEORY_BV;
  case kind::BITVECTOR_MULT: return THEORY_BV;
  case kind::BITVECTOR_NEG: return THEORY_BV;
  case kind::BITVECTOR_ADD: return THEORY_BV;
  case kind::BITVECTOR_SUB: return THEORY_BV;
  case kind::BITVECTOR_UDIV: return THEORY_BV;
  case kind::BITVECTOR_UREM: return THEORY_BV;
  case kind::BITVECTOR_SDIV: return THEORY_BV;
  case kind::BITVECTOR_SMOD: return THEORY_BV;
  case kind::BITVECTOR_SREM: return THEORY_BV;
  case kind::BITVECTOR_ASHR: return THEORY_BV;
  case kind::BITVECTOR_LSHR: return THEORY_BV;
  case kind::BITVECTOR_SHL: return THEORY_BV;
  case kind::BITVECTOR_ULE: return THEORY_BV;
  case kind::BITVECTOR_ULT: return THEORY_BV;
  case kind::BITVECTOR_UGE: return THEORY_BV;
  case kind::BITVECTOR_UGT: return THEORY_BV;
  case kind::BITVECTOR_SLE: return THEORY_BV;
  case kind::BITVECTOR_SLT: return THEORY_BV;
  case kind::BITVECTOR_SGE: return THEORY_BV;
  case kind::BITVECTOR_SGT: return THEORY_BV;
  case kind::BITVECTOR_ULTBV: return THEORY_BV;
  case kind::BITVECTOR_SLTBV: return THEORY_BV;
  case kind::BITVECTOR_REDAND: return THEORY_BV;
  case kind::BITVECTOR_REDOR: return THEORY_BV;
  case kind::BITVECTOR_UADDO: return THEORY_BV;
  case kind::BITVECTOR_SADDO: return THEORY_BV;
  case kind::BITVECTOR_UMULO: return THEORY_BV;
  case kind::BITVECTOR_SMULO: return THEORY_BV;
  case kind::BITVECTOR_USUBO: return THEORY_BV;
  case kind::BITVECTOR_SSUBO: return THEORY_BV;
  case kind::BITVECTOR_SDIVO: return THEORY_BV;
  case kind::BITVECTOR_ITE: return THEORY_BV;
  case kind::BITVECTOR_ACKERMANNIZE_UDIV: return THEORY_BV;
  case kind::BITVECTOR_ACKERMANNIZE_UREM: return THEORY_BV;
  case kind::BITVECTOR_EAGER_ATOM: return THEORY_BV;
  case kind::BITVECTOR_BITOF_OP: return THEORY_BV;
  case kind::BITVECTOR_BITOF: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT_OP: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT: return THEORY_BV;
  case kind::BITVECTOR_REPEAT_OP: return THEORY_BV;
  case kind::BITVECTOR_REPEAT: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND: return THEORY_BV;
  case kind::FINITE_FIELD_TYPE: return THEORY_FF;
  case kind::CONST_FINITE_FIELD: return THEORY_FF;
  case kind::FINITE_FIELD_MULT: return THEORY_FF;
  case kind::FINITE_FIELD_NEG: return THEORY_FF;
  case kind::FINITE_FIELD_ADD: return THEORY_FF;
  case kind::CONST_FLOATINGPOINT: return THEORY_FP;
  case kind::CONST_ROUNDINGMODE: return THEORY_FP;
  case kind::FLOATINGPOINT_TYPE: return THEORY_FP;
  case kind::FLOATINGPOINT_FP: return THEORY_FP;
  case kind::FLOATINGPOINT_EQ: return THEORY_FP;
  case kind::FLOATINGPOINT_ABS: return THEORY_FP;
  case kind::FLOATINGPOINT_NEG: return THEORY_FP;
  case kind::FLOATINGPOINT_ADD: return THEORY_FP;
  case kind::FLOATINGPOINT_SUB: return THEORY_FP;
  case kind::FLOATINGPOINT_MULT: return THEORY_FP;
  case kind::FLOATINGPOINT_DIV: return THEORY_FP;
  case kind::FLOATINGPOINT_FMA: return THEORY_FP;
  case kind::FLOATINGPOINT_SQRT: return THEORY_FP;
  case kind::FLOATINGPOINT_REM: return THEORY_FP;
  case kind::FLOATINGPOINT_RTI: return THEORY_FP;
  case kind::FLOATINGPOINT_MIN: return THEORY_FP;
  case kind::FLOATINGPOINT_MAX: return THEORY_FP;
  case kind::FLOATINGPOINT_MIN_TOTAL: return THEORY_FP;
  case kind::FLOATINGPOINT_MAX_TOTAL: return THEORY_FP;
  case kind::FLOATINGPOINT_LEQ: return THEORY_FP;
  case kind::FLOATINGPOINT_LT: return THEORY_FP;
  case kind::FLOATINGPOINT_GEQ: return THEORY_FP;
  case kind::FLOATINGPOINT_GT: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_NORMAL: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_SUBNORMAL: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_ZERO: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_INF: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_NAN: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_NEG: return THEORY_FP;
  case kind::FLOATINGPOINT_IS_POS: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_FP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_REAL: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_SBV: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_FP_FROM_UBV: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_UBV_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_UBV: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_UBV_TOTAL: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_SBV_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_SBV: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_SBV_TOTAL: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_REAL: return THEORY_FP;
  case kind::FLOATINGPOINT_TO_REAL_TOTAL: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_NAN: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_INF: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_ZERO: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_SIGN: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_EXPONENT: return THEORY_FP;
  case kind::FLOATINGPOINT_COMPONENT_SIGNIFICAND: return THEORY_FP;
  case kind::ROUNDINGMODE_BITBLAST: return THEORY_FP;
  case kind::ARRAY_TYPE: return THEORY_ARRAYS;
  case kind::SELECT: return THEORY_ARRAYS;
  case kind::STORE: return THEORY_ARRAYS;
  case kind::EQ_RANGE: return THEORY_ARRAYS;
  case kind::STORE_ALL: return THEORY_ARRAYS;
  case kind::ARRAY_LAMBDA: return THEORY_ARRAYS;
  case kind::CONSTRUCTOR_TYPE: return THEORY_DATATYPES;
  case kind::SELECTOR_TYPE: return THEORY_DATATYPES;
  case kind::TESTER_TYPE: return THEORY_DATATYPES;
  case kind::UPDATER_TYPE: return THEORY_DATATYPES;
  case kind::APPLY_CONSTRUCTOR: return THEORY_DATATYPES;
  case kind::APPLY_SELECTOR: return THEORY_DATATYPES;
  case kind::APPLY_TESTER: return THEORY_DATATYPES;
  case kind::APPLY_UPDATER: return THEORY_DATATYPES;
  case kind::DATATYPE_TYPE: return THEORY_DATATYPES;
  case kind::PARAMETRIC_DATATYPE: return THEORY_DATATYPES;
  case kind::TUPLE_TYPE: return THEORY_DATATYPES;
  case kind::APPLY_TYPE_ASCRIPTION: return THEORY_DATATYPES;
  case kind::ASCRIPTION_TYPE: return THEORY_DATATYPES;
  case kind::DT_SIZE: return THEORY_DATATYPES;
  case kind::DT_HEIGHT_BOUND: return THEORY_DATATYPES;
  case kind::DT_SIZE_BOUND: return THEORY_DATATYPES;
  case kind::DT_SYGUS_BOUND: return THEORY_DATATYPES;
  case kind::DT_SYGUS_EVAL: return THEORY_DATATYPES;
  case kind::MATCH: return THEORY_DATATYPES;
  case kind::MATCH_CASE: return THEORY_DATATYPES;
  case kind::MATCH_BIND_CASE: return THEORY_DATATYPES;
  case kind::TUPLE_PROJECT_OP: return THEORY_DATATYPES;
  case kind::TUPLE_PROJECT: return THEORY_DATATYPES;
  case kind::CODATATYPE_BOUND_VARIABLE: return THEORY_DATATYPES;
  case kind::SEP_NIL: return THEORY_SEP;
  case kind::SEP_EMP: return THEORY_SEP;
  case kind::SEP_PTO: return THEORY_SEP;
  case kind::SEP_STAR: return THEORY_SEP;
  case kind::SEP_WAND: return THEORY_SEP;
  case kind::SEP_LABEL: return THEORY_SEP;
  case kind::SET_EMPTY: return THEORY_SETS;
  case kind::SET_TYPE: return THEORY_SETS;
  case kind::SET_UNION: return THEORY_SETS;
  case kind::SET_INTER: return THEORY_SETS;
  case kind::SET_MINUS: return THEORY_SETS;
  case kind::SET_SUBSET: return THEORY_SETS;
  case kind::SET_MEMBER: return THEORY_SETS;
  case kind::SET_SINGLETON: return THEORY_SETS;
  case kind::SET_INSERT: return THEORY_SETS;
  case kind::SET_CARD: return THEORY_SETS;
  case kind::SET_COMPLEMENT: return THEORY_SETS;
  case kind::SET_UNIVERSE: return THEORY_SETS;
  case kind::SET_COMPREHENSION: return THEORY_SETS;
  case kind::SET_CHOOSE: return THEORY_SETS;
  case kind::SET_IS_SINGLETON: return THEORY_SETS;
  case kind::SET_MAP: return THEORY_SETS;
  case kind::SET_FILTER: return THEORY_SETS;
  case kind::SET_FOLD: return THEORY_SETS;
  case kind::RELATION_GROUP_OP: return THEORY_SETS;
  case kind::RELATION_GROUP: return THEORY_SETS;
  case kind::RELATION_AGGREGATE_OP: return THEORY_SETS;
  case kind::RELATION_AGGREGATE: return THEORY_SETS;
  case kind::RELATION_PROJECT_OP: return THEORY_SETS;
  case kind::RELATION_PROJECT: return THEORY_SETS;
  case kind::RELATION_JOIN: return THEORY_SETS;
  case kind::RELATION_PRODUCT: return THEORY_SETS;
  case kind::RELATION_TRANSPOSE: return THEORY_SETS;
  case kind::RELATION_TCLOSURE: return THEORY_SETS;
  case kind::RELATION_JOIN_IMAGE: return THEORY_SETS;
  case kind::RELATION_IDEN: return THEORY_SETS;
  case kind::BAG_EMPTY: return THEORY_BAGS;
  case kind::BAG_TYPE: return THEORY_BAGS;
  case kind::BAG_UNION_MAX: return THEORY_BAGS;
  case kind::BAG_UNION_DISJOINT: return THEORY_BAGS;
  case kind::BAG_INTER_MIN: return THEORY_BAGS;
  case kind::BAG_DIFFERENCE_SUBTRACT: return THEORY_BAGS;
  case kind::BAG_DIFFERENCE_REMOVE: return THEORY_BAGS;
  case kind::BAG_SUBBAG: return THEORY_BAGS;
  case kind::BAG_COUNT: return THEORY_BAGS;
  case kind::BAG_MEMBER: return THEORY_BAGS;
  case kind::BAG_DUPLICATE_REMOVAL: return THEORY_BAGS;
  case kind::BAG_MAKE: return THEORY_BAGS;
  case kind::BAG_IS_SINGLETON: return THEORY_BAGS;
  case kind::BAG_CARD: return THEORY_BAGS;
  case kind::BAG_FROM_SET: return THEORY_BAGS;
  case kind::BAG_TO_SET: return THEORY_BAGS;
  case kind::BAG_CHOOSE: return THEORY_BAGS;
  case kind::BAG_MAP: return THEORY_BAGS;
  case kind::BAG_FILTER: return THEORY_BAGS;
  case kind::BAG_FOLD: return THEORY_BAGS;
  case kind::BAG_PARTITION: return THEORY_BAGS;
  case kind::TABLE_PRODUCT: return THEORY_BAGS;
  case kind::TABLE_PROJECT_OP: return THEORY_BAGS;
  case kind::TABLE_PROJECT: return THEORY_BAGS;
  case kind::TABLE_AGGREGATE_OP: return THEORY_BAGS;
  case kind::TABLE_AGGREGATE: return THEORY_BAGS;
  case kind::TABLE_JOIN_OP: return THEORY_BAGS;
  case kind::TABLE_JOIN: return THEORY_BAGS;
  case kind::TABLE_GROUP_OP: return THEORY_BAGS;
  case kind::TABLE_GROUP: return THEORY_BAGS;
  case kind::STRING_CONCAT: return THEORY_STRINGS;
  case kind::STRING_IN_REGEXP: return THEORY_STRINGS;
  case kind::STRING_LENGTH: return THEORY_STRINGS;
  case kind::STRING_SUBSTR: return THEORY_STRINGS;
  case kind::STRING_UPDATE: return THEORY_STRINGS;
  case kind::STRING_CHARAT: return THEORY_STRINGS;
  case kind::STRING_CONTAINS: return THEORY_STRINGS;
  case kind::STRING_LT: return THEORY_STRINGS;
  case kind::STRING_LEQ: return THEORY_STRINGS;
  case kind::STRING_INDEXOF: return THEORY_STRINGS;
  case kind::STRING_INDEXOF_RE: return THEORY_STRINGS;
  case kind::STRING_REPLACE: return THEORY_STRINGS;
  case kind::STRING_REPLACE_ALL: return THEORY_STRINGS;
  case kind::STRING_REPLACE_RE: return THEORY_STRINGS;
  case kind::STRING_REPLACE_RE_ALL: return THEORY_STRINGS;
  case kind::STRING_PREFIX: return THEORY_STRINGS;
  case kind::STRING_SUFFIX: return THEORY_STRINGS;
  case kind::STRING_IS_DIGIT: return THEORY_STRINGS;
  case kind::STRING_ITOS: return THEORY_STRINGS;
  case kind::STRING_STOI: return THEORY_STRINGS;
  case kind::STRING_TO_CODE: return THEORY_STRINGS;
  case kind::STRING_FROM_CODE: return THEORY_STRINGS;
  case kind::STRING_UNIT: return THEORY_STRINGS;
  case kind::STRING_TO_LOWER: return THEORY_STRINGS;
  case kind::STRING_TO_UPPER: return THEORY_STRINGS;
  case kind::STRING_REV: return THEORY_STRINGS;
  case kind::CONST_STRING: return THEORY_STRINGS;
  case kind::SEQUENCE_TYPE: return THEORY_STRINGS;
  case kind::CONST_SEQUENCE: return THEORY_STRINGS;
  case kind::SEQ_UNIT: return THEORY_STRINGS;
  case kind::SEQ_NTH: return THEORY_STRINGS;
  case kind::STRING_TO_REGEXP: return THEORY_STRINGS;
  case kind::REGEXP_CONCAT: return THEORY_STRINGS;
  case kind::REGEXP_UNION: return THEORY_STRINGS;
  case kind::REGEXP_INTER: return THEORY_STRINGS;
  case kind::REGEXP_DIFF: return THEORY_STRINGS;
  case kind::REGEXP_STAR: return THEORY_STRINGS;
  case kind::REGEXP_PLUS: return THEORY_STRINGS;
  case kind::REGEXP_OPT: return THEORY_STRINGS;
  case kind::REGEXP_RANGE: return THEORY_STRINGS;
  case kind::REGEXP_COMPLEMENT: return THEORY_STRINGS;
  case kind::REGEXP_NONE: return THEORY_STRINGS;
  case kind::REGEXP_ALL: return THEORY_STRINGS;
  case kind::REGEXP_ALLCHAR: return THEORY_STRINGS;
  case kind::REGEXP_REPEAT_OP: return THEORY_STRINGS;
  case kind::REGEXP_REPEAT: return THEORY_STRINGS;
  case kind::REGEXP_LOOP_OP: return THEORY_STRINGS;
  case kind::REGEXP_LOOP: return THEORY_STRINGS;
  case kind::REGEXP_RV: return THEORY_STRINGS;
  case kind::FORALL: return THEORY_QUANTIFIERS;
  case kind::EXISTS: return THEORY_QUANTIFIERS;
  case kind::INST_CONSTANT: return THEORY_QUANTIFIERS;
  case kind::ORACLE: return THEORY_QUANTIFIERS;
  case kind::BOUND_VAR_LIST: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN: return THEORY_QUANTIFIERS;
  case kind::INST_NO_PATTERN: return THEORY_QUANTIFIERS;
  case kind::INST_ATTRIBUTE: return THEORY_QUANTIFIERS;
  case kind::INST_POOL: return THEORY_QUANTIFIERS;
  case kind::INST_ADD_TO_POOL: return THEORY_QUANTIFIERS;
  case kind::SKOLEM_ADD_TO_POOL: return THEORY_QUANTIFIERS;
  case kind::ORACLE_FORMULA_GEN: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN_LIST: return THEORY_QUANTIFIERS;

      // clang-format on
    case kind::LAST_KIND: break;
  }
  throw IllegalArgumentException("", "k", __PRETTY_FUNCTION__, "bad kind");
}

TheoryId typeConstantToTheoryId(cvc5::internal::TypeConstant typeConstant)
{
  switch (typeConstant)
  {
    // clang-format off
  case BUILTIN_OPERATOR_TYPE: return THEORY_BUILTIN;
  case SEXPR_TYPE: return THEORY_BUILTIN;
  case BOOLEAN_TYPE: return THEORY_BOOL;
  case REAL_TYPE: return THEORY_ARITH;
  case INTEGER_TYPE: return THEORY_ARITH;
  case ROUNDINGMODE_TYPE: return THEORY_FP;
  case STRING_TYPE: return THEORY_STRINGS;
  case REGEXP_TYPE: return THEORY_STRINGS;
  case BOUND_VAR_LIST_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_LIST_TYPE: return THEORY_QUANTIFIERS;

      // clang-format on
    case LAST_TYPE: break;
  }
  throw IllegalArgumentException(
      "", "k", __PRETTY_FUNCTION__, "bad type constant");
}

}  // namespace theory
}  // namespace cvc5::internal
