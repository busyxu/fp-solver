/******************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2010-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * This header file was automatically generated by:
 *
 *     ../../../src/expr/mkkind /home/aaa/fp-solver/cvc5/src/expr/type_properties_template.h /home/aaa/fp-solver/cvc5/src/theory/builtin/kinds /home/aaa/fp-solver/cvc5/src/theory/booleans/kinds /home/aaa/fp-solver/cvc5/src/theory/uf/kinds /home/aaa/fp-solver/cvc5/src/theory/arith/kinds /home/aaa/fp-solver/cvc5/src/theory/bv/kinds /home/aaa/fp-solver/cvc5/src/theory/ff/kinds /home/aaa/fp-solver/cvc5/src/theory/fp/kinds /home/aaa/fp-solver/cvc5/src/theory/arrays/kinds /home/aaa/fp-solver/cvc5/src/theory/datatypes/kinds /home/aaa/fp-solver/cvc5/src/theory/sep/kinds /home/aaa/fp-solver/cvc5/src/theory/sets/kinds /home/aaa/fp-solver/cvc5/src/theory/bags/kinds /home/aaa/fp-solver/cvc5/src/theory/strings/kinds /home/aaa/fp-solver/cvc5/src/theory/quantifiers/kinds
 *
 * for the cvc5 project.
 */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/aaa/fp-solver/cvc5/src/expr/type_properties_template.h */

/******************************************************************************
 * Top contributors (to current version):
 *   Morgan Deters, Mathias Preiner, Aina Niemetz
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Template for the Type properties header.
 */

#include "cvc5_private.h"

#ifndef CVC5__TYPE_PROPERTIES_H
#define CVC5__TYPE_PROPERTIES_H

#include <sstream>

#include "base/check.h"
#include "expr/kind.h"
#include "expr/node.h"
#include "expr/type_node.h"
#include "options/language.h"

// clang-format off

#include "theory/builtin/theory_builtin_type_rules.h"

#include "theory/builtin/theory_builtin_type_rules.h"

#include "expr/node_manager.h"

#include "theory/uf/theory_uf_type_rules.h"

#include "theory/uf/theory_uf_type_rules.h"

#include "expr/node_manager.h"

#include "expr/node_manager.h"

#include "theory/bv/theory_bv_type_rules.h"

#include "theory/type_enumerator.h"

#include "theory/ff/theory_ff_type_rules.h"

#include "theory/type_enumerator.h"

#include "expr/node_manager.h"

#include "theory/fp/theory_fp_type_rules.h"

#include "theory/type_enumerator.h"

#include "theory/arrays/theory_arrays_type_rules.h"

#include "theory/arrays/theory_arrays_type_rules.h"

#include "theory/datatypes/theory_datatypes_type_rules.h"

#include "theory/uf/theory_uf_type_rules.h"

#include "theory/uf/theory_uf_type_rules.h"

#include "theory/uf/theory_uf_type_rules.h"

#include "expr/dtype.h"

#include "expr/dtype.h"

#include "expr/dtype.h"

#include "expr/dtype.h"

#include "expr/dtype.h"

#include "expr/dtype.h"

#include "theory/sets/theory_sets_type_rules.h"

#include "theory/sets/theory_sets_type_rules.h"

#include "theory/bags/theory_bags_type_rules.h"

#include "theory/bags/theory_bags_type_rules.h"

#include "util/string.h"

#include "util/string.h"

#include "theory/strings/theory_strings_type_rules.h"

#include "theory/strings/theory_strings_type_rules.h"

// clang-format on

namespace cvc5::internal {
namespace kind {

/**
 * Return the cardinality of the type constant represented by the
 * TypeConstant argument.  This function is auto-generated from Theory
 * "kinds" files, so includes contributions from each theory regarding
 * that theory's types.
 */
inline Cardinality getCardinality(TypeConstant tc)
{
  switch (tc)
  {
    // clang-format off

  case BUILTIN_OPERATOR_TYPE: return Cardinality(Cardinality::INTEGERS);

  case SEXPR_TYPE: return Cardinality(Cardinality::INTEGERS);

  case BOOLEAN_TYPE: return Cardinality(2);

  case REAL_TYPE: return Cardinality(Cardinality::REALS);

  case INTEGER_TYPE: return Cardinality(Cardinality::INTEGERS);

  case ROUNDINGMODE_TYPE: return Cardinality(5);

  case STRING_TYPE: return Cardinality(Cardinality::INTEGERS);

  case REGEXP_TYPE: return Cardinality(Cardinality::INTEGERS);

  case BOUND_VAR_LIST_TYPE: return Cardinality(Cardinality::INTEGERS);

  case INST_PATTERN_TYPE: return Cardinality(Cardinality::INTEGERS);

  case INST_PATTERN_LIST_TYPE: return Cardinality(Cardinality::INTEGERS);

      // clang-format on
    default: InternalError() << "No cardinality known for type constant " << tc;
  }
} /* getCardinality(TypeConstant) */

/**
 * Return the cardinality of the type represented by the TypeNode
 * argument.  This function is auto-generated from Theory "kinds"
 * files, so includes contributions from each theory regarding that
 * theory's types.
 */
inline Cardinality getCardinality(TypeNode typeNode) {
  AssertArgument(!typeNode.isNull(), typeNode);
  switch(Kind k = typeNode.getKind()) {
  case TYPE_CONSTANT:
    return getCardinality(typeNode.getConst<TypeConstant>());
    // clang-format off

  case SORT_TYPE: return Cardinality(Cardinality::INTEGERS);

  case INSTANTIATED_SORT_TYPE: return Cardinality(Cardinality::INTEGERS);

  case ABSTRACT_TYPE: return Cardinality(Cardinality::INTEGERS);

  case FUNCTION_TYPE: return ::cvc5::internal::theory::uf::FunctionProperties::computeCardinality(typeNode);

  case BITVECTOR_TYPE: return ::cvc5::internal::theory::bv::CardinalityComputer::computeCardinality(typeNode);

  case FINITE_FIELD_TYPE: return ::cvc5::internal::theory::ff::FiniteFieldProperties::computeCardinality(typeNode);

  case FLOATINGPOINT_TYPE: return ::cvc5::internal::theory::fp::CardinalityComputer::computeCardinality(typeNode);

  case ARRAY_TYPE: return ::cvc5::internal::theory::arrays::ArraysProperties::computeCardinality(typeNode);

  case CONSTRUCTOR_TYPE: return ::cvc5::internal::theory::datatypes::ConstructorProperties::computeCardinality(typeNode);

  case SELECTOR_TYPE: return ::cvc5::internal::theory::uf::FunctionProperties::computeCardinality(typeNode);

  case TESTER_TYPE: return ::cvc5::internal::theory::uf::FunctionProperties::computeCardinality(typeNode);

  case UPDATER_TYPE: return ::cvc5::internal::theory::uf::FunctionProperties::computeCardinality(typeNode);

  case DATATYPE_TYPE: return typeNode.getDType().getCardinality(typeNode);

  case PARAMETRIC_DATATYPE: return typeNode.getDType().getCardinality(typeNode);

  case TUPLE_TYPE: return typeNode.getDType().getCardinality(typeNode);

  case SET_TYPE: return ::cvc5::internal::theory::sets::SetsProperties::computeCardinality(typeNode);

  case BAG_TYPE: return ::cvc5::internal::theory::bags::BagsProperties::computeCardinality(typeNode);

  case SEQUENCE_TYPE: return ::cvc5::internal::theory::strings::SequenceProperties::computeCardinality(typeNode);

    // clang-format on
  default:
    InternalError() << "A theory kinds file did not provide a cardinality "
                    << "or cardinality computer for type:\n"
                    << typeNode << "\nof kind " << k;
  }
}/* getCardinality(TypeNode) */

inline bool isWellFounded(TypeConstant tc) {
  switch(tc) {
    // clang-format off

  case BUILTIN_OPERATOR_TYPE: return false;

  case SEXPR_TYPE: return false;

  case BOOLEAN_TYPE: return true;

  case REAL_TYPE: return true;

  case INTEGER_TYPE: return true;

  case ROUNDINGMODE_TYPE: return true;

  case STRING_TYPE: return true;

  case REGEXP_TYPE: return true;

  case BOUND_VAR_LIST_TYPE: return false;

  case INST_PATTERN_TYPE: return false;

  case INST_PATTERN_LIST_TYPE: return false;

    // clang-format on
    default:
      InternalError() << "No well-foundedness status known for type constant: "
                      << tc;
  }
}/* isWellFounded(TypeConstant) */

inline bool isWellFounded(TypeNode typeNode) {
  AssertArgument(!typeNode.isNull(), typeNode);
  switch(Kind k = typeNode.getKind()) {
  case TYPE_CONSTANT:
    return isWellFounded(typeNode.getConst<TypeConstant>());
    // clang-format off

  case SORT_TYPE: return ::cvc5::internal::theory::builtin::SortProperties::isWellFounded(typeNode);

  case INSTANTIATED_SORT_TYPE: return ::cvc5::internal::theory::builtin::SortProperties::isWellFounded(typeNode);

  case FUNCTION_TYPE: return ::cvc5::internal::theory::uf::FunctionProperties::isWellFounded(typeNode);

  case BITVECTOR_TYPE: return true;

  case FINITE_FIELD_TYPE: return true;

  case FLOATINGPOINT_TYPE: return true;

  case ARRAY_TYPE: return ::cvc5::internal::theory::arrays::ArraysProperties::isWellFounded(typeNode);

  case DATATYPE_TYPE: return typeNode.getDType().isWellFounded();

  case PARAMETRIC_DATATYPE: return typeNode.getDType().isWellFounded();

  case TUPLE_TYPE: return typeNode.getDType().isWellFounded();

  case SET_TYPE: return ::cvc5::internal::theory::sets::SetsProperties::isWellFounded(typeNode);

  case BAG_TYPE: return ::cvc5::internal::theory::bags::BagsProperties::isWellFounded(typeNode);

  case SEQUENCE_TYPE: return ::cvc5::internal::theory::strings::SequenceProperties::isWellFounded(typeNode);

    // clang-format on
  default:
    InternalError() << "A theory kinds file did not provide a well-foundedness "
                    << "or well-foundedness computer for type:\n"
                    << typeNode << "\nof kind " << k;
  }
}/* isWellFounded(TypeNode) */

Node mkGroundTerm(TypeConstant tc);
Node mkGroundTerm(TypeNode typeNode);

}  // namespace kind
}  // namespace cvc5::internal

#endif /* CVC5__TYPE_PROPERTIES_H */
