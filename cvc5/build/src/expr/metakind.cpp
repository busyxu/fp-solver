/******************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2010-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * This header file was automatically generated by:
 *
 *     ../../../src/expr/mkmetakind /home/aaa/fp-solver/cvc5/src/expr/metakind_template.cpp /home/aaa/fp-solver/cvc5/src/theory/builtin/kinds /home/aaa/fp-solver/cvc5/src/theory/booleans/kinds /home/aaa/fp-solver/cvc5/src/theory/uf/kinds /home/aaa/fp-solver/cvc5/src/theory/arith/kinds /home/aaa/fp-solver/cvc5/src/theory/bv/kinds /home/aaa/fp-solver/cvc5/src/theory/ff/kinds /home/aaa/fp-solver/cvc5/src/theory/fp/kinds /home/aaa/fp-solver/cvc5/src/theory/arrays/kinds /home/aaa/fp-solver/cvc5/src/theory/datatypes/kinds /home/aaa/fp-solver/cvc5/src/theory/sep/kinds /home/aaa/fp-solver/cvc5/src/theory/sets/kinds /home/aaa/fp-solver/cvc5/src/theory/bags/kinds /home/aaa/fp-solver/cvc5/src/theory/strings/kinds /home/aaa/fp-solver/cvc5/src/theory/quantifiers/kinds
 *
 * for the cvc5 project.
 */

/******************************************************************************
 * Top contributors (to current version):
 *   Andres Noetzli, Morgan Deters, Mathias Preiner
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * [[ Add one-line brief description here ]]
 *
 * [[ Add lengthier description here ]]
 * \todo document this file
 */

#include <iostream>

#include "expr/metakind.h"
#include "expr/node_manager.h"
#include "expr/node_value.h"

// clang-format off

// #include "theory/builtin/::cvc5::internal::theory::builtin::TheoryBuiltin"
#include "util/uninterpreted_sort_value.h"
#include "expr/kind.h"
#include "theory/builtin/abstract_type.h"
#include "theory/builtin/generic_op.h"
// #include "theory/booleans/::cvc5::internal::theory::booleans::TheoryBool"
#include "util/bool.h"
// #include "theory/uf/::cvc5::internal::theory::uf::TheoryUF"
#include "expr/cardinality_constraint.h"
#include "expr/function_array_const.h"
#include "util/bitvector.h"
// #include "theory/arith/::cvc5::internal::theory::arith::TheoryArith"
#include "util/divisible.h"
#include "util/rational.h"
#include "util/real_algebraic_number.h"
#include "util/indexed_root_predicate.h"
#include "util/iand.h"
// #include "theory/bv/::cvc5::internal::theory::bv::TheoryBV"
// #include "theory/ff/::cvc5::internal::theory::ff::TheoryFiniteFields"
#include "util/finite_field_value.h"
// #include "theory/fp/::cvc5::internal::theory::fp::TheoryFp"
#include "util/floatingpoint.h"
#include "util/roundingmode.h"
// #include "theory/arrays/::cvc5::internal::theory::arrays::TheoryArrays"
#include "expr/array_store_all.h"
// #include "theory/datatypes/::cvc5::internal::theory::datatypes::TheoryDatatypes"
#include "expr/ascription_type.h"
#include "theory/datatypes/project_op.h"
#include "expr/codatatype_bound_variable.h"
// #include "theory/sep/::cvc5::internal::theory::sep::TheorySep"
// #include "theory/sets/::cvc5::internal::theory::sets::TheorySets"
#include "expr/emptyset.h"
// #include "theory/bags/::cvc5::internal::theory::bags::TheoryBags"
#include "expr/emptybag.h"
// #include "theory/strings/::cvc5::internal::theory::strings::TheoryStrings"
#include "util/string.h"
#include "expr/sequence.h"
#include "util/regexp.h"
// #include "theory/quantifiers/::cvc5::internal::theory::quantifiers::TheoryQuantifiers"
// clang-format off

namespace cvc5::internal {
namespace expr {

// clang-format off

// The reinterpret_cast of d_children to "UninterpretedSortValue const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
UninterpretedSortValue const& NodeValue::getConst< UninterpretedSortValue >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::UNINTERPRETED_SORT_VALUE, *this,
  //               "Improper kind for getConst<UninterpretedSortValue>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< UninterpretedSortValue const* >(d_children)
    : *reinterpret_cast< UninterpretedSortValue const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "Kind const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
Kind const& NodeValue::getConst< Kind >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BUILTIN, *this,
  //               "Improper kind for getConst<Kind>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< Kind const* >(d_children)
    : *reinterpret_cast< Kind const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "TypeConstant const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
TypeConstant const& NodeValue::getConst< TypeConstant >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::TYPE_CONSTANT, *this,
  //               "Improper kind for getConst<TypeConstant>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< TypeConstant const* >(d_children)
    : *reinterpret_cast< TypeConstant const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "AbstractType const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
AbstractType const& NodeValue::getConst< AbstractType >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::ABSTRACT_TYPE, *this,
  //               "Improper kind for getConst<AbstractType>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< AbstractType const* >(d_children)
    : *reinterpret_cast< AbstractType const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "GenericOp const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
GenericOp const& NodeValue::getConst< GenericOp >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::APPLY_INDEXED_SYMBOLIC_OP, *this,
  //               "Improper kind for getConst<GenericOp>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< GenericOp const* >(d_children)
    : *reinterpret_cast< GenericOp const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "bool const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
bool const& NodeValue::getConst< bool >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_BOOLEAN, *this,
  //               "Improper kind for getConst<bool>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< bool const* >(d_children)
    : *reinterpret_cast< bool const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "CardinalityConstraint const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
CardinalityConstraint const& NodeValue::getConst< CardinalityConstraint >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CARDINALITY_CONSTRAINT_OP, *this,
  //               "Improper kind for getConst<CardinalityConstraint>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< CardinalityConstraint const* >(d_children)
    : *reinterpret_cast< CardinalityConstraint const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "CombinedCardinalityConstraint const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
CombinedCardinalityConstraint const& NodeValue::getConst< CombinedCardinalityConstraint >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::COMBINED_CARDINALITY_CONSTRAINT_OP, *this,
  //               "Improper kind for getConst<CombinedCardinalityConstraint>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< CombinedCardinalityConstraint const* >(d_children)
    : *reinterpret_cast< CombinedCardinalityConstraint const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FunctionArrayConst const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FunctionArrayConst const& NodeValue::getConst< FunctionArrayConst >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FUNCTION_ARRAY_CONST, *this,
  //               "Improper kind for getConst<FunctionArrayConst>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FunctionArrayConst const* >(d_children)
    : *reinterpret_cast< FunctionArrayConst const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "IntToBitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
IntToBitVector const& NodeValue::getConst< IntToBitVector >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::INT_TO_BITVECTOR_OP, *this,
  //               "Improper kind for getConst<IntToBitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< IntToBitVector const* >(d_children)
    : *reinterpret_cast< IntToBitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "Divisible const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
Divisible const& NodeValue::getConst< Divisible >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::DIVISIBLE_OP, *this,
  //               "Improper kind for getConst<Divisible>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< Divisible const* >(d_children)
    : *reinterpret_cast< Divisible const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "Rational const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
Rational const& NodeValue::getConst< Rational >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_RATIONAL, *this,
  //               "Improper kind for getConst<Rational>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< Rational const* >(d_children)
    : *reinterpret_cast< Rational const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "RealAlgebraicNumber const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
RealAlgebraicNumber const& NodeValue::getConst< RealAlgebraicNumber >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::REAL_ALGEBRAIC_NUMBER_OP, *this,
  //               "Improper kind for getConst<RealAlgebraicNumber>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< RealAlgebraicNumber const* >(d_children)
    : *reinterpret_cast< RealAlgebraicNumber const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "IndexedRootPredicate const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
IndexedRootPredicate const& NodeValue::getConst< IndexedRootPredicate >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::INDEXED_ROOT_PREDICATE_OP, *this,
  //               "Improper kind for getConst<IndexedRootPredicate>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< IndexedRootPredicate const* >(d_children)
    : *reinterpret_cast< IndexedRootPredicate const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "IntAnd const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
IntAnd const& NodeValue::getConst< IntAnd >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::IAND_OP, *this,
  //               "Improper kind for getConst<IntAnd>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< IntAnd const* >(d_children)
    : *reinterpret_cast< IntAnd const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorSize const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorSize const& NodeValue::getConst< BitVectorSize >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_TYPE, *this,
  //               "Improper kind for getConst<BitVectorSize>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorSize const* >(d_children)
    : *reinterpret_cast< BitVectorSize const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVector const& NodeValue::getConst< BitVector >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_BITVECTOR, *this,
  //               "Improper kind for getConst<BitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVector const* >(d_children)
    : *reinterpret_cast< BitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorBitOf const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorBitOf const& NodeValue::getConst< BitVectorBitOf >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_BITOF_OP, *this,
  //               "Improper kind for getConst<BitVectorBitOf>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorBitOf const* >(d_children)
    : *reinterpret_cast< BitVectorBitOf const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorExtract const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorExtract const& NodeValue::getConst< BitVectorExtract >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_EXTRACT_OP, *this,
  //               "Improper kind for getConst<BitVectorExtract>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorExtract const* >(d_children)
    : *reinterpret_cast< BitVectorExtract const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorRepeat const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorRepeat const& NodeValue::getConst< BitVectorRepeat >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_REPEAT_OP, *this,
  //               "Improper kind for getConst<BitVectorRepeat>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorRepeat const* >(d_children)
    : *reinterpret_cast< BitVectorRepeat const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorRotateLeft const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorRotateLeft const& NodeValue::getConst< BitVectorRotateLeft >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_ROTATE_LEFT_OP, *this,
  //               "Improper kind for getConst<BitVectorRotateLeft>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorRotateLeft const* >(d_children)
    : *reinterpret_cast< BitVectorRotateLeft const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorRotateRight const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorRotateRight const& NodeValue::getConst< BitVectorRotateRight >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_ROTATE_RIGHT_OP, *this,
  //               "Improper kind for getConst<BitVectorRotateRight>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorRotateRight const* >(d_children)
    : *reinterpret_cast< BitVectorRotateRight const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorSignExtend const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorSignExtend const& NodeValue::getConst< BitVectorSignExtend >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_SIGN_EXTEND_OP, *this,
  //               "Improper kind for getConst<BitVectorSignExtend>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorSignExtend const* >(d_children)
    : *reinterpret_cast< BitVectorSignExtend const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "BitVectorZeroExtend const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
BitVectorZeroExtend const& NodeValue::getConst< BitVectorZeroExtend >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BITVECTOR_ZERO_EXTEND_OP, *this,
  //               "Improper kind for getConst<BitVectorZeroExtend>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< BitVectorZeroExtend const* >(d_children)
    : *reinterpret_cast< BitVectorZeroExtend const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FfSize const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FfSize const& NodeValue::getConst< FfSize >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FINITE_FIELD_TYPE, *this,
  //               "Improper kind for getConst<FfSize>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FfSize const* >(d_children)
    : *reinterpret_cast< FfSize const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FiniteFieldValue const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FiniteFieldValue const& NodeValue::getConst< FiniteFieldValue >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_FINITE_FIELD, *this,
  //               "Improper kind for getConst<FiniteFieldValue>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FiniteFieldValue const* >(d_children)
    : *reinterpret_cast< FiniteFieldValue const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPoint const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPoint const& NodeValue::getConst< FloatingPoint >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_FLOATINGPOINT, *this,
  //               "Improper kind for getConst<FloatingPoint>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPoint const* >(d_children)
    : *reinterpret_cast< FloatingPoint const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "RoundingMode const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
RoundingMode const& NodeValue::getConst< RoundingMode >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_ROUNDINGMODE, *this,
  //               "Improper kind for getConst<RoundingMode>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< RoundingMode const* >(d_children)
    : *reinterpret_cast< RoundingMode const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointSize const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointSize const& NodeValue::getConst< FloatingPointSize >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TYPE, *this,
  //               "Improper kind for getConst<FloatingPointSize>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointSize const* >(d_children)
    : *reinterpret_cast< FloatingPointSize const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToFPIEEEBitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToFPIEEEBitVector const& NodeValue::getConst< FloatingPointToFPIEEEBitVector >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP, *this,
  //               "Improper kind for getConst<FloatingPointToFPIEEEBitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToFPIEEEBitVector const* >(d_children)
    : *reinterpret_cast< FloatingPointToFPIEEEBitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToFPFloatingPoint const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToFPFloatingPoint const& NodeValue::getConst< FloatingPointToFPFloatingPoint >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_FP_FROM_FP_OP, *this,
  //               "Improper kind for getConst<FloatingPointToFPFloatingPoint>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToFPFloatingPoint const* >(d_children)
    : *reinterpret_cast< FloatingPointToFPFloatingPoint const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToFPReal const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToFPReal const& NodeValue::getConst< FloatingPointToFPReal >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP, *this,
  //               "Improper kind for getConst<FloatingPointToFPReal>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToFPReal const* >(d_children)
    : *reinterpret_cast< FloatingPointToFPReal const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToFPSignedBitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToFPSignedBitVector const& NodeValue::getConst< FloatingPointToFPSignedBitVector >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP, *this,
  //               "Improper kind for getConst<FloatingPointToFPSignedBitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToFPSignedBitVector const* >(d_children)
    : *reinterpret_cast< FloatingPointToFPSignedBitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToFPUnsignedBitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToFPUnsignedBitVector const& NodeValue::getConst< FloatingPointToFPUnsignedBitVector >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP, *this,
  //               "Improper kind for getConst<FloatingPointToFPUnsignedBitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToFPUnsignedBitVector const* >(d_children)
    : *reinterpret_cast< FloatingPointToFPUnsignedBitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToUBV const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToUBV const& NodeValue::getConst< FloatingPointToUBV >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_UBV_OP, *this,
  //               "Improper kind for getConst<FloatingPointToUBV>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToUBV const* >(d_children)
    : *reinterpret_cast< FloatingPointToUBV const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToUBVTotal const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToUBVTotal const& NodeValue::getConst< FloatingPointToUBVTotal >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_UBV_TOTAL_OP, *this,
  //               "Improper kind for getConst<FloatingPointToUBVTotal>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToUBVTotal const* >(d_children)
    : *reinterpret_cast< FloatingPointToUBVTotal const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToSBV const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToSBV const& NodeValue::getConst< FloatingPointToSBV >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_SBV_OP, *this,
  //               "Improper kind for getConst<FloatingPointToSBV>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToSBV const* >(d_children)
    : *reinterpret_cast< FloatingPointToSBV const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "FloatingPointToSBVTotal const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
FloatingPointToSBVTotal const& NodeValue::getConst< FloatingPointToSBVTotal >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::FLOATINGPOINT_TO_SBV_TOTAL_OP, *this,
  //               "Improper kind for getConst<FloatingPointToSBVTotal>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< FloatingPointToSBVTotal const* >(d_children)
    : *reinterpret_cast< FloatingPointToSBVTotal const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "ArrayStoreAll const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
ArrayStoreAll const& NodeValue::getConst< ArrayStoreAll >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::STORE_ALL, *this,
  //               "Improper kind for getConst<ArrayStoreAll>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ArrayStoreAll const* >(d_children)
    : *reinterpret_cast< ArrayStoreAll const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "AscriptionType const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
AscriptionType const& NodeValue::getConst< AscriptionType >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::ASCRIPTION_TYPE, *this,
  //               "Improper kind for getConst<AscriptionType>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< AscriptionType const* >(d_children)
    : *reinterpret_cast< AscriptionType const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "ProjectOp const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
ProjectOp const& NodeValue::getConst< ProjectOp >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::TUPLE_PROJECT_OP, *this,
  //               "Improper kind for getConst<ProjectOp>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ProjectOp const* >(d_children)
    : *reinterpret_cast< ProjectOp const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "CodatatypeBoundVariable const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
CodatatypeBoundVariable const& NodeValue::getConst< CodatatypeBoundVariable >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CODATATYPE_BOUND_VARIABLE, *this,
  //               "Improper kind for getConst<CodatatypeBoundVariable>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< CodatatypeBoundVariable const* >(d_children)
    : *reinterpret_cast< CodatatypeBoundVariable const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "EmptySet const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
EmptySet const& NodeValue::getConst< EmptySet >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::SET_EMPTY, *this,
  //               "Improper kind for getConst<EmptySet>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< EmptySet const* >(d_children)
    : *reinterpret_cast< EmptySet const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "EmptyBag const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
EmptyBag const& NodeValue::getConst< EmptyBag >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::BAG_EMPTY, *this,
  //               "Improper kind for getConst<EmptyBag>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< EmptyBag const* >(d_children)
    : *reinterpret_cast< EmptyBag const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "String const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
String const& NodeValue::getConst< String >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_STRING, *this,
  //               "Improper kind for getConst<String>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< String const* >(d_children)
    : *reinterpret_cast< String const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "Sequence const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
Sequence const& NodeValue::getConst< Sequence >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::CONST_SEQUENCE, *this,
  //               "Improper kind for getConst<Sequence>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< Sequence const* >(d_children)
    : *reinterpret_cast< Sequence const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "RegExpRepeat const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
RegExpRepeat const& NodeValue::getConst< RegExpRepeat >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::REGEXP_REPEAT_OP, *this,
  //               "Improper kind for getConst<RegExpRepeat>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< RegExpRepeat const* >(d_children)
    : *reinterpret_cast< RegExpRepeat const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// The reinterpret_cast of d_children to "RegExpLoop const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
RegExpLoop const& NodeValue::getConst< RegExpLoop >() const {
  //AssertArgument(getKind() == ::cvc5::internal::kind::REGEXP_LOOP_OP, *this,
  //               "Improper kind for getConst<RegExpLoop>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< RegExpLoop const* >(d_children)
    : *reinterpret_cast< RegExpLoop const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"


// clang-format on

}  // namespace expr

namespace kind {

/**
 * Get the metakind for a particular kind.
 */
MetaKind metaKindOf(Kind k)
{
  static const MetaKind metaKinds[] = {
      metakind::INVALID, /* UNDEFINED_KIND */
      metakind::INVALID, /* NULL_EXPR */
      // clang-format off

    /* from builtin */
    metakind::VARIABLE, /* SORT_TYPE */
    metakind::OPERATOR, /* INSTANTIATED_SORT_TYPE */
    metakind::CONSTANT, /* UNINTERPRETED_SORT_VALUE */
    metakind::CONSTANT, /* BUILTIN */
    metakind::OPERATOR, /* EQUAL */
    metakind::OPERATOR, /* DISTINCT */
    metakind::VARIABLE, /* VARIABLE */
    metakind::VARIABLE, /* BOUND_VARIABLE */
    metakind::VARIABLE, /* SKOLEM */
    metakind::OPERATOR, /* SEXPR */
    metakind::OPERATOR, /* WITNESS */
    metakind::CONSTANT, /* TYPE_CONSTANT */
    metakind::VARIABLE, /* RAW_SYMBOL */
    metakind::CONSTANT, /* ABSTRACT_TYPE */
    metakind::CONSTANT, /* APPLY_INDEXED_SYMBOLIC_OP */
    metakind::PARAMETERIZED, /* APPLY_INDEXED_SYMBOLIC */

    /* from booleans */
    metakind::CONSTANT, /* CONST_BOOLEAN */
    metakind::OPERATOR, /* NOT */
    metakind::OPERATOR, /* AND */
    metakind::OPERATOR, /* IMPLIES */
    metakind::OPERATOR, /* OR */
    metakind::OPERATOR, /* XOR */
    metakind::OPERATOR, /* ITE */

    /* from uf */
    metakind::PARAMETERIZED, /* APPLY_UF */
    metakind::OPERATOR, /* FUNCTION_TYPE */
    metakind::OPERATOR, /* LAMBDA */
    metakind::VARIABLE, /* BOOLEAN_TERM_VARIABLE */
    metakind::OPERATOR, /* HO_APPLY */
    metakind::CONSTANT, /* CARDINALITY_CONSTRAINT_OP */
    metakind::PARAMETERIZED, /* CARDINALITY_CONSTRAINT */
    metakind::CONSTANT, /* COMBINED_CARDINALITY_CONSTRAINT_OP */
    metakind::PARAMETERIZED, /* COMBINED_CARDINALITY_CONSTRAINT */
    metakind::CONSTANT, /* FUNCTION_ARRAY_CONST */
    metakind::OPERATOR, /* BITVECTOR_TO_NAT */
    metakind::CONSTANT, /* INT_TO_BITVECTOR_OP */
    metakind::PARAMETERIZED, /* INT_TO_BITVECTOR */

    /* from arith */
    metakind::OPERATOR, /* ADD */
    metakind::OPERATOR, /* MULT */
    metakind::OPERATOR, /* NONLINEAR_MULT */
    metakind::OPERATOR, /* SUB */
    metakind::OPERATOR, /* NEG */
    metakind::OPERATOR, /* DIVISION */
    metakind::OPERATOR, /* DIVISION_TOTAL */
    metakind::OPERATOR, /* INTS_DIVISION */
    metakind::OPERATOR, /* INTS_DIVISION_TOTAL */
    metakind::OPERATOR, /* INTS_MODULUS */
    metakind::OPERATOR, /* INTS_MODULUS_TOTAL */
    metakind::OPERATOR, /* ABS */
    metakind::PARAMETERIZED, /* DIVISIBLE */
    metakind::OPERATOR, /* POW */
    metakind::OPERATOR, /* POW2 */
    metakind::OPERATOR, /* EXPONENTIAL */
    metakind::OPERATOR, /* SINE */
    metakind::OPERATOR, /* COSINE */
    metakind::OPERATOR, /* TANGENT */
    metakind::OPERATOR, /* COSECANT */
    metakind::OPERATOR, /* SECANT */
    metakind::OPERATOR, /* COTANGENT */
    metakind::OPERATOR, /* ARCSINE */
    metakind::OPERATOR, /* ARCCOSINE */
    metakind::OPERATOR, /* ARCTANGENT */
    metakind::OPERATOR, /* ARCCOSECANT */
    metakind::OPERATOR, /* ARCSECANT */
    metakind::OPERATOR, /* ARCCOTANGENT */
    metakind::OPERATOR, /* SQRT */
    metakind::CONSTANT, /* DIVISIBLE_OP */
    metakind::CONSTANT, /* CONST_RATIONAL */
    metakind::CONSTANT, /* CONST_INTEGER */
    metakind::CONSTANT, /* REAL_ALGEBRAIC_NUMBER_OP */
    metakind::PARAMETERIZED, /* REAL_ALGEBRAIC_NUMBER */
    metakind::OPERATOR, /* LT */
    metakind::OPERATOR, /* LEQ */
    metakind::OPERATOR, /* GT */
    metakind::OPERATOR, /* GEQ */
    metakind::CONSTANT, /* INDEXED_ROOT_PREDICATE_OP */
    metakind::PARAMETERIZED, /* INDEXED_ROOT_PREDICATE */
    metakind::OPERATOR, /* IS_INTEGER */
    metakind::OPERATOR, /* TO_INTEGER */
    metakind::OPERATOR, /* TO_REAL */
    metakind::NULLARY_OPERATOR, /* PI */
    metakind::CONSTANT, /* IAND_OP */
    metakind::PARAMETERIZED, /* IAND */

    /* from bv */
    metakind::CONSTANT, /* BITVECTOR_TYPE */
    metakind::CONSTANT, /* CONST_BITVECTOR */
    metakind::OPERATOR, /* BITVECTOR_BB_TERM */
    metakind::OPERATOR, /* BITVECTOR_CONCAT */
    metakind::OPERATOR, /* BITVECTOR_AND */
    metakind::OPERATOR, /* BITVECTOR_COMP */
    metakind::OPERATOR, /* BITVECTOR_OR */
    metakind::OPERATOR, /* BITVECTOR_XOR */
    metakind::OPERATOR, /* BITVECTOR_NOT */
    metakind::OPERATOR, /* BITVECTOR_NAND */
    metakind::OPERATOR, /* BITVECTOR_NOR */
    metakind::OPERATOR, /* BITVECTOR_XNOR */
    metakind::OPERATOR, /* BITVECTOR_MULT */
    metakind::OPERATOR, /* BITVECTOR_NEG */
    metakind::OPERATOR, /* BITVECTOR_ADD */
    metakind::OPERATOR, /* BITVECTOR_SUB */
    metakind::OPERATOR, /* BITVECTOR_UDIV */
    metakind::OPERATOR, /* BITVECTOR_UREM */
    metakind::OPERATOR, /* BITVECTOR_SDIV */
    metakind::OPERATOR, /* BITVECTOR_SMOD */
    metakind::OPERATOR, /* BITVECTOR_SREM */
    metakind::OPERATOR, /* BITVECTOR_ASHR */
    metakind::OPERATOR, /* BITVECTOR_LSHR */
    metakind::OPERATOR, /* BITVECTOR_SHL */
    metakind::OPERATOR, /* BITVECTOR_ULE */
    metakind::OPERATOR, /* BITVECTOR_ULT */
    metakind::OPERATOR, /* BITVECTOR_UGE */
    metakind::OPERATOR, /* BITVECTOR_UGT */
    metakind::OPERATOR, /* BITVECTOR_SLE */
    metakind::OPERATOR, /* BITVECTOR_SLT */
    metakind::OPERATOR, /* BITVECTOR_SGE */
    metakind::OPERATOR, /* BITVECTOR_SGT */
    metakind::OPERATOR, /* BITVECTOR_ULTBV */
    metakind::OPERATOR, /* BITVECTOR_SLTBV */
    metakind::OPERATOR, /* BITVECTOR_REDAND */
    metakind::OPERATOR, /* BITVECTOR_REDOR */
    metakind::OPERATOR, /* BITVECTOR_UADDO */
    metakind::OPERATOR, /* BITVECTOR_SADDO */
    metakind::OPERATOR, /* BITVECTOR_UMULO */
    metakind::OPERATOR, /* BITVECTOR_SMULO */
    metakind::OPERATOR, /* BITVECTOR_USUBO */
    metakind::OPERATOR, /* BITVECTOR_SSUBO */
    metakind::OPERATOR, /* BITVECTOR_SDIVO */
    metakind::OPERATOR, /* BITVECTOR_ITE */
    metakind::OPERATOR, /* BITVECTOR_ACKERMANNIZE_UDIV */
    metakind::OPERATOR, /* BITVECTOR_ACKERMANNIZE_UREM */
    metakind::OPERATOR, /* BITVECTOR_EAGER_ATOM */
    metakind::CONSTANT, /* BITVECTOR_BITOF_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_BITOF */
    metakind::CONSTANT, /* BITVECTOR_EXTRACT_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_EXTRACT */
    metakind::CONSTANT, /* BITVECTOR_REPEAT_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_REPEAT */
    metakind::CONSTANT, /* BITVECTOR_ROTATE_LEFT_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_ROTATE_LEFT */
    metakind::CONSTANT, /* BITVECTOR_ROTATE_RIGHT_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_ROTATE_RIGHT */
    metakind::CONSTANT, /* BITVECTOR_SIGN_EXTEND_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_SIGN_EXTEND */
    metakind::CONSTANT, /* BITVECTOR_ZERO_EXTEND_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_ZERO_EXTEND */

    /* from ff */
    metakind::CONSTANT, /* FINITE_FIELD_TYPE */
    metakind::CONSTANT, /* CONST_FINITE_FIELD */
    metakind::OPERATOR, /* FINITE_FIELD_MULT */
    metakind::OPERATOR, /* FINITE_FIELD_NEG */
    metakind::OPERATOR, /* FINITE_FIELD_ADD */

    /* from fp */
    metakind::CONSTANT, /* CONST_FLOATINGPOINT */
    metakind::CONSTANT, /* CONST_ROUNDINGMODE */
    metakind::CONSTANT, /* FLOATINGPOINT_TYPE */
    metakind::OPERATOR, /* FLOATINGPOINT_FP */
    metakind::OPERATOR, /* FLOATINGPOINT_EQ */
    metakind::OPERATOR, /* FLOATINGPOINT_ABS */
    metakind::OPERATOR, /* FLOATINGPOINT_NEG */
    metakind::OPERATOR, /* FLOATINGPOINT_ADD */
    metakind::OPERATOR, /* FLOATINGPOINT_SUB */
    metakind::OPERATOR, /* FLOATINGPOINT_MULT */
    metakind::OPERATOR, /* FLOATINGPOINT_DIV */
    metakind::OPERATOR, /* FLOATINGPOINT_FMA */
    metakind::OPERATOR, /* FLOATINGPOINT_SQRT */
    metakind::OPERATOR, /* FLOATINGPOINT_REM */
    metakind::OPERATOR, /* FLOATINGPOINT_RTI */
    metakind::OPERATOR, /* FLOATINGPOINT_MIN */
    metakind::OPERATOR, /* FLOATINGPOINT_MAX */
    metakind::OPERATOR, /* FLOATINGPOINT_MIN_TOTAL */
    metakind::OPERATOR, /* FLOATINGPOINT_MAX_TOTAL */
    metakind::OPERATOR, /* FLOATINGPOINT_LEQ */
    metakind::OPERATOR, /* FLOATINGPOINT_LT */
    metakind::OPERATOR, /* FLOATINGPOINT_GEQ */
    metakind::OPERATOR, /* FLOATINGPOINT_GT */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_NORMAL */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_SUBNORMAL */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_ZERO */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_INF */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_NAN */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_NEG */
    metakind::OPERATOR, /* FLOATINGPOINT_IS_POS */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_FP_FROM_FP_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_FP_FROM_FP */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_FP_FROM_REAL_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_FP_FROM_REAL */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_FP_FROM_SBV_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_FP_FROM_SBV */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_FP_FROM_UBV_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_FP_FROM_UBV */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_UBV_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_UBV */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_UBV_TOTAL_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_UBV_TOTAL */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_SBV_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_SBV */
    metakind::CONSTANT, /* FLOATINGPOINT_TO_SBV_TOTAL_OP */
    metakind::PARAMETERIZED, /* FLOATINGPOINT_TO_SBV_TOTAL */
    metakind::OPERATOR, /* FLOATINGPOINT_TO_REAL */
    metakind::OPERATOR, /* FLOATINGPOINT_TO_REAL_TOTAL */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_NAN */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_INF */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_ZERO */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_SIGN */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_EXPONENT */
    metakind::OPERATOR, /* FLOATINGPOINT_COMPONENT_SIGNIFICAND */
    metakind::OPERATOR, /* ROUNDINGMODE_BITBLAST */

    /* from arrays */
    metakind::OPERATOR, /* ARRAY_TYPE */
    metakind::OPERATOR, /* SELECT */
    metakind::OPERATOR, /* STORE */
    metakind::OPERATOR, /* EQ_RANGE */
    metakind::CONSTANT, /* STORE_ALL */
    metakind::OPERATOR, /* ARRAY_LAMBDA */

    /* from datatypes */
    metakind::OPERATOR, /* CONSTRUCTOR_TYPE */
    metakind::OPERATOR, /* SELECTOR_TYPE */
    metakind::OPERATOR, /* TESTER_TYPE */
    metakind::OPERATOR, /* UPDATER_TYPE */
    metakind::PARAMETERIZED, /* APPLY_CONSTRUCTOR */
    metakind::PARAMETERIZED, /* APPLY_SELECTOR */
    metakind::PARAMETERIZED, /* APPLY_TESTER */
    metakind::PARAMETERIZED, /* APPLY_UPDATER */
    metakind::VARIABLE, /* DATATYPE_TYPE */
    metakind::OPERATOR, /* PARAMETRIC_DATATYPE */
    metakind::OPERATOR, /* TUPLE_TYPE */
    metakind::PARAMETERIZED, /* APPLY_TYPE_ASCRIPTION */
    metakind::CONSTANT, /* ASCRIPTION_TYPE */
    metakind::OPERATOR, /* DT_SIZE */
    metakind::OPERATOR, /* DT_HEIGHT_BOUND */
    metakind::OPERATOR, /* DT_SIZE_BOUND */
    metakind::OPERATOR, /* DT_SYGUS_BOUND */
    metakind::OPERATOR, /* DT_SYGUS_EVAL */
    metakind::OPERATOR, /* MATCH */
    metakind::OPERATOR, /* MATCH_CASE */
    metakind::OPERATOR, /* MATCH_BIND_CASE */
    metakind::CONSTANT, /* TUPLE_PROJECT_OP */
    metakind::PARAMETERIZED, /* TUPLE_PROJECT */
    metakind::CONSTANT, /* CODATATYPE_BOUND_VARIABLE */

    /* from sep */
    metakind::NULLARY_OPERATOR, /* SEP_NIL */
    metakind::NULLARY_OPERATOR, /* SEP_EMP */
    metakind::OPERATOR, /* SEP_PTO */
    metakind::OPERATOR, /* SEP_STAR */
    metakind::OPERATOR, /* SEP_WAND */
    metakind::OPERATOR, /* SEP_LABEL */

    /* from sets */
    metakind::CONSTANT, /* SET_EMPTY */
    metakind::OPERATOR, /* SET_TYPE */
    metakind::OPERATOR, /* SET_UNION */
    metakind::OPERATOR, /* SET_INTER */
    metakind::OPERATOR, /* SET_MINUS */
    metakind::OPERATOR, /* SET_SUBSET */
    metakind::OPERATOR, /* SET_MEMBER */
    metakind::OPERATOR, /* SET_SINGLETON */
    metakind::OPERATOR, /* SET_INSERT */
    metakind::OPERATOR, /* SET_CARD */
    metakind::OPERATOR, /* SET_COMPLEMENT */
    metakind::NULLARY_OPERATOR, /* SET_UNIVERSE */
    metakind::OPERATOR, /* SET_COMPREHENSION */
    metakind::OPERATOR, /* SET_CHOOSE */
    metakind::OPERATOR, /* SET_IS_SINGLETON */
    metakind::OPERATOR, /* SET_MAP */
    metakind::OPERATOR, /* SET_FILTER */
    metakind::OPERATOR, /* SET_FOLD */
    metakind::CONSTANT, /* RELATION_GROUP_OP */
    metakind::PARAMETERIZED, /* RELATION_GROUP */
    metakind::CONSTANT, /* RELATION_AGGREGATE_OP */
    metakind::PARAMETERIZED, /* RELATION_AGGREGATE */
    metakind::CONSTANT, /* RELATION_PROJECT_OP */
    metakind::PARAMETERIZED, /* RELATION_PROJECT */
    metakind::OPERATOR, /* RELATION_JOIN */
    metakind::OPERATOR, /* RELATION_PRODUCT */
    metakind::OPERATOR, /* RELATION_TRANSPOSE */
    metakind::OPERATOR, /* RELATION_TCLOSURE */
    metakind::OPERATOR, /* RELATION_JOIN_IMAGE */
    metakind::OPERATOR, /* RELATION_IDEN */

    /* from bags */
    metakind::CONSTANT, /* BAG_EMPTY */
    metakind::OPERATOR, /* BAG_TYPE */
    metakind::OPERATOR, /* BAG_UNION_MAX */
    metakind::OPERATOR, /* BAG_UNION_DISJOINT */
    metakind::OPERATOR, /* BAG_INTER_MIN */
    metakind::OPERATOR, /* BAG_DIFFERENCE_SUBTRACT */
    metakind::OPERATOR, /* BAG_DIFFERENCE_REMOVE */
    metakind::OPERATOR, /* BAG_SUBBAG */
    metakind::OPERATOR, /* BAG_COUNT */
    metakind::OPERATOR, /* BAG_MEMBER */
    metakind::OPERATOR, /* BAG_DUPLICATE_REMOVAL */
    metakind::OPERATOR, /* BAG_MAKE */
    metakind::OPERATOR, /* BAG_IS_SINGLETON */
    metakind::OPERATOR, /* BAG_CARD */
    metakind::OPERATOR, /* BAG_FROM_SET */
    metakind::OPERATOR, /* BAG_TO_SET */
    metakind::OPERATOR, /* BAG_CHOOSE */
    metakind::OPERATOR, /* BAG_MAP */
    metakind::OPERATOR, /* BAG_FILTER */
    metakind::OPERATOR, /* BAG_FOLD */
    metakind::OPERATOR, /* BAG_PARTITION */
    metakind::OPERATOR, /* TABLE_PRODUCT */
    metakind::CONSTANT, /* TABLE_PROJECT_OP */
    metakind::PARAMETERIZED, /* TABLE_PROJECT */
    metakind::CONSTANT, /* TABLE_AGGREGATE_OP */
    metakind::PARAMETERIZED, /* TABLE_AGGREGATE */
    metakind::CONSTANT, /* TABLE_JOIN_OP */
    metakind::PARAMETERIZED, /* TABLE_JOIN */
    metakind::CONSTANT, /* TABLE_GROUP_OP */
    metakind::PARAMETERIZED, /* TABLE_GROUP */

    /* from strings */
    metakind::OPERATOR, /* STRING_CONCAT */
    metakind::OPERATOR, /* STRING_IN_REGEXP */
    metakind::OPERATOR, /* STRING_LENGTH */
    metakind::OPERATOR, /* STRING_SUBSTR */
    metakind::OPERATOR, /* STRING_UPDATE */
    metakind::OPERATOR, /* STRING_CHARAT */
    metakind::OPERATOR, /* STRING_CONTAINS */
    metakind::OPERATOR, /* STRING_LT */
    metakind::OPERATOR, /* STRING_LEQ */
    metakind::OPERATOR, /* STRING_INDEXOF */
    metakind::OPERATOR, /* STRING_INDEXOF_RE */
    metakind::OPERATOR, /* STRING_REPLACE */
    metakind::OPERATOR, /* STRING_REPLACE_ALL */
    metakind::OPERATOR, /* STRING_REPLACE_RE */
    metakind::OPERATOR, /* STRING_REPLACE_RE_ALL */
    metakind::OPERATOR, /* STRING_PREFIX */
    metakind::OPERATOR, /* STRING_SUFFIX */
    metakind::OPERATOR, /* STRING_IS_DIGIT */
    metakind::OPERATOR, /* STRING_ITOS */
    metakind::OPERATOR, /* STRING_STOI */
    metakind::OPERATOR, /* STRING_TO_CODE */
    metakind::OPERATOR, /* STRING_FROM_CODE */
    metakind::OPERATOR, /* STRING_UNIT */
    metakind::OPERATOR, /* STRING_TO_LOWER */
    metakind::OPERATOR, /* STRING_TO_UPPER */
    metakind::OPERATOR, /* STRING_REV */
    metakind::CONSTANT, /* CONST_STRING */
    metakind::OPERATOR, /* SEQUENCE_TYPE */
    metakind::CONSTANT, /* CONST_SEQUENCE */
    metakind::OPERATOR, /* SEQ_UNIT */
    metakind::OPERATOR, /* SEQ_NTH */
    metakind::OPERATOR, /* STRING_TO_REGEXP */
    metakind::OPERATOR, /* REGEXP_CONCAT */
    metakind::OPERATOR, /* REGEXP_UNION */
    metakind::OPERATOR, /* REGEXP_INTER */
    metakind::OPERATOR, /* REGEXP_DIFF */
    metakind::OPERATOR, /* REGEXP_STAR */
    metakind::OPERATOR, /* REGEXP_PLUS */
    metakind::OPERATOR, /* REGEXP_OPT */
    metakind::OPERATOR, /* REGEXP_RANGE */
    metakind::OPERATOR, /* REGEXP_COMPLEMENT */
    metakind::OPERATOR, /* REGEXP_NONE */
    metakind::OPERATOR, /* REGEXP_ALL */
    metakind::OPERATOR, /* REGEXP_ALLCHAR */
    metakind::CONSTANT, /* REGEXP_REPEAT_OP */
    metakind::PARAMETERIZED, /* REGEXP_REPEAT */
    metakind::CONSTANT, /* REGEXP_LOOP_OP */
    metakind::PARAMETERIZED, /* REGEXP_LOOP */
    metakind::OPERATOR, /* REGEXP_RV */

    /* from quantifiers */
    metakind::OPERATOR, /* FORALL */
    metakind::OPERATOR, /* EXISTS */
    metakind::VARIABLE, /* INST_CONSTANT */
    metakind::VARIABLE, /* ORACLE */
    metakind::OPERATOR, /* BOUND_VAR_LIST */
    metakind::OPERATOR, /* INST_PATTERN */
    metakind::OPERATOR, /* INST_NO_PATTERN */
    metakind::OPERATOR, /* INST_ATTRIBUTE */
    metakind::OPERATOR, /* INST_POOL */
    metakind::OPERATOR, /* INST_ADD_TO_POOL */
    metakind::OPERATOR, /* SKOLEM_ADD_TO_POOL */
    metakind::OPERATOR, /* ORACLE_FORMULA_GEN */
    metakind::OPERATOR, /* INST_PATTERN_LIST */
  // clang-format on
      metakind::INVALID  /* LAST_KIND */
  };                     /* metaKinds[] */

  Assert(k >= kind::NULL_EXPR && k < kind::LAST_KIND);

  // We've asserted that k >= NULL_EXPR (which is 0), but we still
  // handle the UNDEFINED_KIND (-1) case.  If we don't, the compiler
  // emits warnings for non-assertion builds, since the check isn't done.
  return metaKinds[k + 1];
} /* metaKindOf(k) */

namespace metakind {

/**
 * Static, compile-time mapping from CONSTANT kinds to comparison
 * functors on NodeValue*.  The single element of this structure is:
 *
 *   static bool NodeValueCompare<K, pool>::compare(NodeValue* x, NodeValue* y)
 *
 *     Compares x and y, given that they are both K-kinded (and the
 *     meta-kind of K is CONSTANT).  If pool == true, one of x and y
 *     (but not both) may be a "non-inlined" NodeValue.  If pool ==
 *     false, neither x nor y may be a "non-inlined" NodeValue.
 */
template <Kind k, class T, bool pool>
struct NodeValueConstCompare
{
  static bool compare(const cvc5::internal::expr::NodeValue* x,
                      const cvc5::internal::expr::NodeValue* y)
  {
    if (pool)
    {
      if (x->d_nchildren == 1)
      {
        Assert(y->d_nchildren == 0);
        return compare(y, x);
      }
      else if (y->d_nchildren == 1)
      {
        Assert(x->d_nchildren == 0);
        return x->getConst<T>() == *reinterpret_cast<T*>(y->d_children[0]);
      }
    }

    Assert(x->d_nchildren == 0);
    Assert(y->d_nchildren == 0);
    return x->getConst<T>() == y->getConst<T>();
  }

  static size_t constHash(const cvc5::internal::expr::NodeValue* nv)
  {
    return nv->getConst<T>().hash();
  }
};

size_t NodeValueCompare::constHash(const cvc5::internal::expr::NodeValue* nv)
{
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch (nv->d_kind)
  {
// clang-format off
    
  case kind::UNINTERPRETED_SORT_VALUE:
    return ::cvc5::internal::UninterpretedSortValueHashFunction()(nv->getConst< UninterpretedSortValue >());

  case kind::BUILTIN:
    return ::cvc5::internal::kind::KindHashFunction()(nv->getConst< Kind >());

  case kind::TYPE_CONSTANT:
    return ::cvc5::internal::TypeConstantHashFunction()(nv->getConst< TypeConstant >());

  case kind::ABSTRACT_TYPE:
    return ::cvc5::internal::AbstractTypeHashFunction()(nv->getConst< AbstractType >());

  case kind::APPLY_INDEXED_SYMBOLIC_OP:
    return ::cvc5::internal::GenericOpHashFunction()(nv->getConst< GenericOp >());

  case kind::CONST_BOOLEAN:
    return ::cvc5::internal::BoolHashFunction()(nv->getConst< bool >());

  case kind::CARDINALITY_CONSTRAINT_OP:
    return ::cvc5::internal::CardinalityConstraintHashFunction()(nv->getConst< CardinalityConstraint >());

  case kind::COMBINED_CARDINALITY_CONSTRAINT_OP:
    return ::cvc5::internal::CombinedCardinalityConstraintHashFunction()(nv->getConst< CombinedCardinalityConstraint >());

  case kind::FUNCTION_ARRAY_CONST:
    return ::cvc5::internal::FunctionArrayConstHashFunction()(nv->getConst< FunctionArrayConst >());

  case kind::INT_TO_BITVECTOR_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::IntToBitVector >()(nv->getConst< IntToBitVector >());

  case kind::DIVISIBLE_OP:
    return ::cvc5::internal::DivisibleHashFunction()(nv->getConst< Divisible >());

  case kind::CONST_RATIONAL:
    return ::cvc5::internal::RationalHashFunction()(nv->getConst< Rational >());

  case kind::CONST_INTEGER:
    return ::cvc5::internal::RationalHashFunction()(nv->getConst< Rational >());

  case kind::REAL_ALGEBRAIC_NUMBER_OP:
    return ::cvc5::internal::RealAlgebraicNumberHashFunction()(nv->getConst< RealAlgebraicNumber >());

  case kind::INDEXED_ROOT_PREDICATE_OP:
    return ::cvc5::internal::IndexedRootPredicateHashFunction()(nv->getConst< IndexedRootPredicate >());

  case kind::IAND_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::IntAnd >()(nv->getConst< IntAnd >());

  case kind::BITVECTOR_TYPE:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorSize >()(nv->getConst< BitVectorSize >());

  case kind::CONST_BITVECTOR:
    return ::cvc5::internal::BitVectorHashFunction()(nv->getConst< BitVector >());

  case kind::BITVECTOR_BITOF_OP:
    return ::cvc5::internal::BitVectorBitOfHashFunction()(nv->getConst< BitVectorBitOf >());

  case kind::BITVECTOR_EXTRACT_OP:
    return ::cvc5::internal::BitVectorExtractHashFunction()(nv->getConst< BitVectorExtract >());

  case kind::BITVECTOR_REPEAT_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorRepeat >()(nv->getConst< BitVectorRepeat >());

  case kind::BITVECTOR_ROTATE_LEFT_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorRotateLeft >()(nv->getConst< BitVectorRotateLeft >());

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorRotateRight >()(nv->getConst< BitVectorRotateRight >());

  case kind::BITVECTOR_SIGN_EXTEND_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorSignExtend >()(nv->getConst< BitVectorSignExtend >());

  case kind::BITVECTOR_ZERO_EXTEND_OP:
    return ::cvc5::internal::UnsignedHashFunction< ::cvc5::internal::BitVectorZeroExtend >()(nv->getConst< BitVectorZeroExtend >());

  case kind::FINITE_FIELD_TYPE:
    return ::cvc5::internal::FfSizeHashFunction()(nv->getConst< FfSize >());

  case kind::CONST_FINITE_FIELD:
    return ::cvc5::internal::FiniteFieldValueHashFunction()(nv->getConst< FiniteFieldValue >());

  case kind::CONST_FLOATINGPOINT:
    return ::cvc5::internal::FloatingPointHashFunction()(nv->getConst< FloatingPoint >());

  case kind::CONST_ROUNDINGMODE:
    return ::cvc5::internal::RoundingModeHashFunction()(nv->getConst< RoundingMode >());

  case kind::FLOATINGPOINT_TYPE:
    return ::cvc5::internal::FloatingPointSizeHashFunction()(nv->getConst< FloatingPointSize >());

  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP:
    return ::cvc5::internal::FloatingPointConvertSortHashFunction<0x1>()(nv->getConst< FloatingPointToFPIEEEBitVector >());

  case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP:
    return ::cvc5::internal::FloatingPointConvertSortHashFunction<0x2>()(nv->getConst< FloatingPointToFPFloatingPoint >());

  case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP:
    return ::cvc5::internal::FloatingPointConvertSortHashFunction<0x4>()(nv->getConst< FloatingPointToFPReal >());

  case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP:
    return ::cvc5::internal::FloatingPointConvertSortHashFunction<0x8>()(nv->getConst< FloatingPointToFPSignedBitVector >());

  case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP:
    return ::cvc5::internal::FloatingPointConvertSortHashFunction<0x10>()(nv->getConst< FloatingPointToFPUnsignedBitVector >());

  case kind::FLOATINGPOINT_TO_UBV_OP:
    return ::cvc5::internal::FloatingPointToBVHashFunction<0x1>()(nv->getConst< FloatingPointToUBV >());

  case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP:
    return ::cvc5::internal::FloatingPointToBVHashFunction<0x4>()(nv->getConst< FloatingPointToUBVTotal >());

  case kind::FLOATINGPOINT_TO_SBV_OP:
    return ::cvc5::internal::FloatingPointToBVHashFunction<0x2>()(nv->getConst< FloatingPointToSBV >());

  case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP:
    return ::cvc5::internal::FloatingPointToBVHashFunction<0x8>()(nv->getConst< FloatingPointToSBVTotal >());

  case kind::STORE_ALL:
    return ::cvc5::internal::ArrayStoreAllHashFunction()(nv->getConst< ArrayStoreAll >());

  case kind::ASCRIPTION_TYPE:
    return ::cvc5::internal::AscriptionTypeHashFunction()(nv->getConst< AscriptionType >());

  case kind::TUPLE_PROJECT_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::CODATATYPE_BOUND_VARIABLE:
    return ::cvc5::internal::CodatatypeBoundVariableHashFunction()(nv->getConst< CodatatypeBoundVariable >());

  case kind::SET_EMPTY:
    return ::cvc5::internal::EmptySetHashFunction()(nv->getConst< EmptySet >());

  case kind::RELATION_GROUP_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::RELATION_AGGREGATE_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::RELATION_PROJECT_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::BAG_EMPTY:
    return ::cvc5::internal::EmptyBagHashFunction()(nv->getConst< EmptyBag >());

  case kind::TABLE_PROJECT_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::TABLE_AGGREGATE_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::TABLE_JOIN_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::TABLE_GROUP_OP:
    return ::cvc5::internal::ProjectOpHashFunction()(nv->getConst< ProjectOp >());

  case kind::CONST_STRING:
    return ::cvc5::internal::strings::StringHashFunction()(nv->getConst< String >());

  case kind::CONST_SEQUENCE:
    return ::cvc5::internal::SequenceHashFunction()(nv->getConst< Sequence >());

  case kind::REGEXP_REPEAT_OP:
    return ::cvc5::internal::RegExpRepeatHashFunction()(nv->getConst< RegExpRepeat >());

  case kind::REGEXP_LOOP_OP:
    return ::cvc5::internal::RegExpLoopHashFunction()(nv->getConst< RegExpLoop >());

// clang-format on
    default:
      Unhandled() << cvc5::internal::expr::NodeValue::dKindToKind(nv->d_kind);
  }
}

template <bool pool>
bool NodeValueCompare::compare(const cvc5::internal::expr::NodeValue* nv1,
                               const cvc5::internal::expr::NodeValue* nv2)
{
  if(nv1->d_kind != nv2->d_kind) {
    return false;
  }

  if (nv1->getMetaKind() == kind::metakind::CONSTANT)
  {
    switch (nv1->d_kind)
    {
// clang-format off

    case kind::UNINTERPRETED_SORT_VALUE:
      return NodeValueConstCompare<kind::UNINTERPRETED_SORT_VALUE, UninterpretedSortValue, pool>::compare(nv1, nv2);

    case kind::BUILTIN:
      return NodeValueConstCompare<kind::BUILTIN, Kind, pool>::compare(nv1, nv2);

    case kind::TYPE_CONSTANT:
      return NodeValueConstCompare<kind::TYPE_CONSTANT, TypeConstant, pool>::compare(nv1, nv2);

    case kind::ABSTRACT_TYPE:
      return NodeValueConstCompare<kind::ABSTRACT_TYPE, AbstractType, pool>::compare(nv1, nv2);

    case kind::APPLY_INDEXED_SYMBOLIC_OP:
      return NodeValueConstCompare<kind::APPLY_INDEXED_SYMBOLIC_OP, GenericOp, pool>::compare(nv1, nv2);

    case kind::CONST_BOOLEAN:
      return NodeValueConstCompare<kind::CONST_BOOLEAN, bool, pool>::compare(nv1, nv2);

    case kind::CARDINALITY_CONSTRAINT_OP:
      return NodeValueConstCompare<kind::CARDINALITY_CONSTRAINT_OP, CardinalityConstraint, pool>::compare(nv1, nv2);

    case kind::COMBINED_CARDINALITY_CONSTRAINT_OP:
      return NodeValueConstCompare<kind::COMBINED_CARDINALITY_CONSTRAINT_OP, CombinedCardinalityConstraint, pool>::compare(nv1, nv2);

    case kind::FUNCTION_ARRAY_CONST:
      return NodeValueConstCompare<kind::FUNCTION_ARRAY_CONST, FunctionArrayConst, pool>::compare(nv1, nv2);

    case kind::INT_TO_BITVECTOR_OP:
      return NodeValueConstCompare<kind::INT_TO_BITVECTOR_OP, IntToBitVector, pool>::compare(nv1, nv2);

    case kind::DIVISIBLE_OP:
      return NodeValueConstCompare<kind::DIVISIBLE_OP, Divisible, pool>::compare(nv1, nv2);

    case kind::CONST_RATIONAL:
      return NodeValueConstCompare<kind::CONST_RATIONAL, Rational, pool>::compare(nv1, nv2);

    case kind::CONST_INTEGER:
      return NodeValueConstCompare<kind::CONST_INTEGER, Rational, pool>::compare(nv1, nv2);

    case kind::REAL_ALGEBRAIC_NUMBER_OP:
      return NodeValueConstCompare<kind::REAL_ALGEBRAIC_NUMBER_OP, RealAlgebraicNumber, pool>::compare(nv1, nv2);

    case kind::INDEXED_ROOT_PREDICATE_OP:
      return NodeValueConstCompare<kind::INDEXED_ROOT_PREDICATE_OP, IndexedRootPredicate, pool>::compare(nv1, nv2);

    case kind::IAND_OP:
      return NodeValueConstCompare<kind::IAND_OP, IntAnd, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_TYPE:
      return NodeValueConstCompare<kind::BITVECTOR_TYPE, BitVectorSize, pool>::compare(nv1, nv2);

    case kind::CONST_BITVECTOR:
      return NodeValueConstCompare<kind::CONST_BITVECTOR, BitVector, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_BITOF_OP:
      return NodeValueConstCompare<kind::BITVECTOR_BITOF_OP, BitVectorBitOf, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_EXTRACT_OP:
      return NodeValueConstCompare<kind::BITVECTOR_EXTRACT_OP, BitVectorExtract, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_REPEAT_OP:
      return NodeValueConstCompare<kind::BITVECTOR_REPEAT_OP, BitVectorRepeat, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_ROTATE_LEFT_OP:
      return NodeValueConstCompare<kind::BITVECTOR_ROTATE_LEFT_OP, BitVectorRotateLeft, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_ROTATE_RIGHT_OP:
      return NodeValueConstCompare<kind::BITVECTOR_ROTATE_RIGHT_OP, BitVectorRotateRight, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_SIGN_EXTEND_OP:
      return NodeValueConstCompare<kind::BITVECTOR_SIGN_EXTEND_OP, BitVectorSignExtend, pool>::compare(nv1, nv2);

    case kind::BITVECTOR_ZERO_EXTEND_OP:
      return NodeValueConstCompare<kind::BITVECTOR_ZERO_EXTEND_OP, BitVectorZeroExtend, pool>::compare(nv1, nv2);

    case kind::FINITE_FIELD_TYPE:
      return NodeValueConstCompare<kind::FINITE_FIELD_TYPE, FfSize, pool>::compare(nv1, nv2);

    case kind::CONST_FINITE_FIELD:
      return NodeValueConstCompare<kind::CONST_FINITE_FIELD, FiniteFieldValue, pool>::compare(nv1, nv2);

    case kind::CONST_FLOATINGPOINT:
      return NodeValueConstCompare<kind::CONST_FLOATINGPOINT, FloatingPoint, pool>::compare(nv1, nv2);

    case kind::CONST_ROUNDINGMODE:
      return NodeValueConstCompare<kind::CONST_ROUNDINGMODE, RoundingMode, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TYPE:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TYPE, FloatingPointSize, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP, FloatingPointToFPIEEEBitVector, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_FP_FROM_FP_OP, FloatingPointToFPFloatingPoint, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP, FloatingPointToFPReal, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP, FloatingPointToFPSignedBitVector, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP, FloatingPointToFPUnsignedBitVector, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_UBV_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_UBV_OP, FloatingPointToUBV, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_UBV_TOTAL_OP, FloatingPointToUBVTotal, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_SBV_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_SBV_OP, FloatingPointToSBV, pool>::compare(nv1, nv2);

    case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP:
      return NodeValueConstCompare<kind::FLOATINGPOINT_TO_SBV_TOTAL_OP, FloatingPointToSBVTotal, pool>::compare(nv1, nv2);

    case kind::STORE_ALL:
      return NodeValueConstCompare<kind::STORE_ALL, ArrayStoreAll, pool>::compare(nv1, nv2);

    case kind::ASCRIPTION_TYPE:
      return NodeValueConstCompare<kind::ASCRIPTION_TYPE, AscriptionType, pool>::compare(nv1, nv2);

    case kind::TUPLE_PROJECT_OP:
      return NodeValueConstCompare<kind::TUPLE_PROJECT_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::CODATATYPE_BOUND_VARIABLE:
      return NodeValueConstCompare<kind::CODATATYPE_BOUND_VARIABLE, CodatatypeBoundVariable, pool>::compare(nv1, nv2);

    case kind::SET_EMPTY:
      return NodeValueConstCompare<kind::SET_EMPTY, EmptySet, pool>::compare(nv1, nv2);

    case kind::RELATION_GROUP_OP:
      return NodeValueConstCompare<kind::RELATION_GROUP_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::RELATION_AGGREGATE_OP:
      return NodeValueConstCompare<kind::RELATION_AGGREGATE_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::RELATION_PROJECT_OP:
      return NodeValueConstCompare<kind::RELATION_PROJECT_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::BAG_EMPTY:
      return NodeValueConstCompare<kind::BAG_EMPTY, EmptyBag, pool>::compare(nv1, nv2);

    case kind::TABLE_PROJECT_OP:
      return NodeValueConstCompare<kind::TABLE_PROJECT_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::TABLE_AGGREGATE_OP:
      return NodeValueConstCompare<kind::TABLE_AGGREGATE_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::TABLE_JOIN_OP:
      return NodeValueConstCompare<kind::TABLE_JOIN_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::TABLE_GROUP_OP:
      return NodeValueConstCompare<kind::TABLE_GROUP_OP, ProjectOp, pool>::compare(nv1, nv2);

    case kind::CONST_STRING:
      return NodeValueConstCompare<kind::CONST_STRING, String, pool>::compare(nv1, nv2);

    case kind::CONST_SEQUENCE:
      return NodeValueConstCompare<kind::CONST_SEQUENCE, Sequence, pool>::compare(nv1, nv2);

    case kind::REGEXP_REPEAT_OP:
      return NodeValueConstCompare<kind::REGEXP_REPEAT_OP, RegExpRepeat, pool>::compare(nv1, nv2);

    case kind::REGEXP_LOOP_OP:
      return NodeValueConstCompare<kind::REGEXP_LOOP_OP, RegExpLoop, pool>::compare(nv1, nv2);

// clang-format on
default:
  Unhandled() << cvc5::internal::expr::NodeValue::dKindToKind(nv1->d_kind);
    }
  }

  if(nv1->d_nchildren != nv2->d_nchildren) {
    return false;
  }

  cvc5::internal::expr::NodeValue::const_nv_iterator i = nv1->nv_begin();
  cvc5::internal::expr::NodeValue::const_nv_iterator j = nv2->nv_begin();
  cvc5::internal::expr::NodeValue::const_nv_iterator i_end = nv1->nv_end();

  while(i != i_end) {
    if((*i) != (*j)) {
      return false;
    }
    ++i;
    ++j;
  }

  return true;
}

template bool NodeValueCompare::compare<true>(
    const cvc5::internal::expr::NodeValue* nv1,
    const cvc5::internal::expr::NodeValue* nv2);
template bool NodeValueCompare::compare<false>(
    const cvc5::internal::expr::NodeValue* nv1,
    const cvc5::internal::expr::NodeValue* nv2);

void nodeValueConstantToStream(std::ostream& out,
                               const cvc5::internal::expr::NodeValue* nv)
{
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch (nv->d_kind)
  {
// clang-format off

  case kind::UNINTERPRETED_SORT_VALUE:
    out << nv->getConst< UninterpretedSortValue >();
    break;

  case kind::BUILTIN:
    out << nv->getConst< Kind >();
    break;

  case kind::TYPE_CONSTANT:
    out << nv->getConst< TypeConstant >();
    break;

  case kind::ABSTRACT_TYPE:
    out << nv->getConst< AbstractType >();
    break;

  case kind::APPLY_INDEXED_SYMBOLIC_OP:
    out << nv->getConst< GenericOp >();
    break;

  case kind::CONST_BOOLEAN:
    out << nv->getConst< bool >();
    break;

  case kind::CARDINALITY_CONSTRAINT_OP:
    out << nv->getConst< CardinalityConstraint >();
    break;

  case kind::COMBINED_CARDINALITY_CONSTRAINT_OP:
    out << nv->getConst< CombinedCardinalityConstraint >();
    break;

  case kind::FUNCTION_ARRAY_CONST:
    out << nv->getConst< FunctionArrayConst >();
    break;

  case kind::INT_TO_BITVECTOR_OP:
    out << nv->getConst< IntToBitVector >();
    break;

  case kind::DIVISIBLE_OP:
    out << nv->getConst< Divisible >();
    break;

  case kind::CONST_RATIONAL:
    out << nv->getConst< Rational >();
    break;

  case kind::CONST_INTEGER:
    out << nv->getConst< Rational >();
    break;

  case kind::REAL_ALGEBRAIC_NUMBER_OP:
    out << nv->getConst< RealAlgebraicNumber >();
    break;

  case kind::INDEXED_ROOT_PREDICATE_OP:
    out << nv->getConst< IndexedRootPredicate >();
    break;

  case kind::IAND_OP:
    out << nv->getConst< IntAnd >();
    break;

  case kind::BITVECTOR_TYPE:
    out << nv->getConst< BitVectorSize >();
    break;

  case kind::CONST_BITVECTOR:
    out << nv->getConst< BitVector >();
    break;

  case kind::BITVECTOR_BITOF_OP:
    out << nv->getConst< BitVectorBitOf >();
    break;

  case kind::BITVECTOR_EXTRACT_OP:
    out << nv->getConst< BitVectorExtract >();
    break;

  case kind::BITVECTOR_REPEAT_OP:
    out << nv->getConst< BitVectorRepeat >();
    break;

  case kind::BITVECTOR_ROTATE_LEFT_OP:
    out << nv->getConst< BitVectorRotateLeft >();
    break;

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
    out << nv->getConst< BitVectorRotateRight >();
    break;

  case kind::BITVECTOR_SIGN_EXTEND_OP:
    out << nv->getConst< BitVectorSignExtend >();
    break;

  case kind::BITVECTOR_ZERO_EXTEND_OP:
    out << nv->getConst< BitVectorZeroExtend >();
    break;

  case kind::FINITE_FIELD_TYPE:
    out << nv->getConst< FfSize >();
    break;

  case kind::CONST_FINITE_FIELD:
    out << nv->getConst< FiniteFieldValue >();
    break;

  case kind::CONST_FLOATINGPOINT:
    out << nv->getConst< FloatingPoint >();
    break;

  case kind::CONST_ROUNDINGMODE:
    out << nv->getConst< RoundingMode >();
    break;

  case kind::FLOATINGPOINT_TYPE:
    out << nv->getConst< FloatingPointSize >();
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP:
    out << nv->getConst< FloatingPointToFPIEEEBitVector >();
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP:
    out << nv->getConst< FloatingPointToFPFloatingPoint >();
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP:
    out << nv->getConst< FloatingPointToFPReal >();
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP:
    out << nv->getConst< FloatingPointToFPSignedBitVector >();
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP:
    out << nv->getConst< FloatingPointToFPUnsignedBitVector >();
    break;

  case kind::FLOATINGPOINT_TO_UBV_OP:
    out << nv->getConst< FloatingPointToUBV >();
    break;

  case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP:
    out << nv->getConst< FloatingPointToUBVTotal >();
    break;

  case kind::FLOATINGPOINT_TO_SBV_OP:
    out << nv->getConst< FloatingPointToSBV >();
    break;

  case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP:
    out << nv->getConst< FloatingPointToSBVTotal >();
    break;

  case kind::STORE_ALL:
    out << nv->getConst< ArrayStoreAll >();
    break;

  case kind::ASCRIPTION_TYPE:
    out << nv->getConst< AscriptionType >();
    break;

  case kind::TUPLE_PROJECT_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::CODATATYPE_BOUND_VARIABLE:
    out << nv->getConst< CodatatypeBoundVariable >();
    break;

  case kind::SET_EMPTY:
    out << nv->getConst< EmptySet >();
    break;

  case kind::RELATION_GROUP_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::RELATION_AGGREGATE_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::RELATION_PROJECT_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::BAG_EMPTY:
    out << nv->getConst< EmptyBag >();
    break;

  case kind::TABLE_PROJECT_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::TABLE_AGGREGATE_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::TABLE_JOIN_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::TABLE_GROUP_OP:
    out << nv->getConst< ProjectOp >();
    break;

  case kind::CONST_STRING:
    out << nv->getConst< String >();
    break;

  case kind::CONST_SEQUENCE:
    out << nv->getConst< Sequence >();
    break;

  case kind::REGEXP_REPEAT_OP:
    out << nv->getConst< RegExpRepeat >();
    break;

  case kind::REGEXP_LOOP_OP:
    out << nv->getConst< RegExpLoop >();
    break;

// clang-format on
default:
  Unhandled() << cvc5::internal::expr::NodeValue::dKindToKind(nv->d_kind);
  }
}


// The reinterpret_cast of d_children to various constant payload types
// in deleteNodeValueConstant(), below, can flag a "strict aliasing"
// warning; it should actually be okay, because we never access the
// embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

/**
 * Cleanup to be performed when a NodeValue zombie is collected, and
 * it has CONSTANT metakind.  This calls the destructor for the underlying
 * C++ type representing the constant value.  See
 * NodeManager::reclaimZombies() for more information.
 *
 * This doesn't support "non-inlined" NodeValues, which shouldn't need this
 * kind of cleanup.
 */
void deleteNodeValueConstant(cvc5::internal::expr::NodeValue* nv)
{
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch (nv->d_kind)
  {
// clang-format off

  case kind::UNINTERPRETED_SORT_VALUE:
    std::destroy_at(reinterpret_cast< UninterpretedSortValue* >(nv->d_children));
    break;

  case kind::BUILTIN:
    std::destroy_at(reinterpret_cast< Kind* >(nv->d_children));
    break;

  case kind::TYPE_CONSTANT:
    std::destroy_at(reinterpret_cast< TypeConstant* >(nv->d_children));
    break;

  case kind::ABSTRACT_TYPE:
    std::destroy_at(reinterpret_cast< AbstractType* >(nv->d_children));
    break;

  case kind::APPLY_INDEXED_SYMBOLIC_OP:
    std::destroy_at(reinterpret_cast< GenericOp* >(nv->d_children));
    break;

  case kind::CONST_BOOLEAN:
    std::destroy_at(reinterpret_cast< bool* >(nv->d_children));
    break;

  case kind::CARDINALITY_CONSTRAINT_OP:
    std::destroy_at(reinterpret_cast< CardinalityConstraint* >(nv->d_children));
    break;

  case kind::COMBINED_CARDINALITY_CONSTRAINT_OP:
    std::destroy_at(reinterpret_cast< CombinedCardinalityConstraint* >(nv->d_children));
    break;

  case kind::FUNCTION_ARRAY_CONST:
    std::destroy_at(reinterpret_cast< FunctionArrayConst* >(nv->d_children));
    break;

  case kind::INT_TO_BITVECTOR_OP:
    std::destroy_at(reinterpret_cast< IntToBitVector* >(nv->d_children));
    break;

  case kind::DIVISIBLE_OP:
    std::destroy_at(reinterpret_cast< Divisible* >(nv->d_children));
    break;

  case kind::CONST_RATIONAL:
    std::destroy_at(reinterpret_cast< Rational* >(nv->d_children));
    break;

  case kind::CONST_INTEGER:
    std::destroy_at(reinterpret_cast< Rational* >(nv->d_children));
    break;

  case kind::REAL_ALGEBRAIC_NUMBER_OP:
    std::destroy_at(reinterpret_cast< RealAlgebraicNumber* >(nv->d_children));
    break;

  case kind::INDEXED_ROOT_PREDICATE_OP:
    std::destroy_at(reinterpret_cast< IndexedRootPredicate* >(nv->d_children));
    break;

  case kind::IAND_OP:
    std::destroy_at(reinterpret_cast< IntAnd* >(nv->d_children));
    break;

  case kind::BITVECTOR_TYPE:
    std::destroy_at(reinterpret_cast< BitVectorSize* >(nv->d_children));
    break;

  case kind::CONST_BITVECTOR:
    std::destroy_at(reinterpret_cast< BitVector* >(nv->d_children));
    break;

  case kind::BITVECTOR_BITOF_OP:
    std::destroy_at(reinterpret_cast< BitVectorBitOf* >(nv->d_children));
    break;

  case kind::BITVECTOR_EXTRACT_OP:
    std::destroy_at(reinterpret_cast< BitVectorExtract* >(nv->d_children));
    break;

  case kind::BITVECTOR_REPEAT_OP:
    std::destroy_at(reinterpret_cast< BitVectorRepeat* >(nv->d_children));
    break;

  case kind::BITVECTOR_ROTATE_LEFT_OP:
    std::destroy_at(reinterpret_cast< BitVectorRotateLeft* >(nv->d_children));
    break;

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
    std::destroy_at(reinterpret_cast< BitVectorRotateRight* >(nv->d_children));
    break;

  case kind::BITVECTOR_SIGN_EXTEND_OP:
    std::destroy_at(reinterpret_cast< BitVectorSignExtend* >(nv->d_children));
    break;

  case kind::BITVECTOR_ZERO_EXTEND_OP:
    std::destroy_at(reinterpret_cast< BitVectorZeroExtend* >(nv->d_children));
    break;

  case kind::FINITE_FIELD_TYPE:
    std::destroy_at(reinterpret_cast< FfSize* >(nv->d_children));
    break;

  case kind::CONST_FINITE_FIELD:
    std::destroy_at(reinterpret_cast< FiniteFieldValue* >(nv->d_children));
    break;

  case kind::CONST_FLOATINGPOINT:
    std::destroy_at(reinterpret_cast< FloatingPoint* >(nv->d_children));
    break;

  case kind::CONST_ROUNDINGMODE:
    std::destroy_at(reinterpret_cast< RoundingMode* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TYPE:
    std::destroy_at(reinterpret_cast< FloatingPointSize* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToFPIEEEBitVector* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToFPFloatingPoint* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToFPReal* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToFPSignedBitVector* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToFPUnsignedBitVector* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_UBV_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToUBV* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToUBVTotal* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_SBV_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToSBV* >(nv->d_children));
    break;

  case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP:
    std::destroy_at(reinterpret_cast< FloatingPointToSBVTotal* >(nv->d_children));
    break;

  case kind::STORE_ALL:
    std::destroy_at(reinterpret_cast< ArrayStoreAll* >(nv->d_children));
    break;

  case kind::ASCRIPTION_TYPE:
    std::destroy_at(reinterpret_cast< AscriptionType* >(nv->d_children));
    break;

  case kind::TUPLE_PROJECT_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::CODATATYPE_BOUND_VARIABLE:
    std::destroy_at(reinterpret_cast< CodatatypeBoundVariable* >(nv->d_children));
    break;

  case kind::SET_EMPTY:
    std::destroy_at(reinterpret_cast< EmptySet* >(nv->d_children));
    break;

  case kind::RELATION_GROUP_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::RELATION_AGGREGATE_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::RELATION_PROJECT_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::BAG_EMPTY:
    std::destroy_at(reinterpret_cast< EmptyBag* >(nv->d_children));
    break;

  case kind::TABLE_PROJECT_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::TABLE_AGGREGATE_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::TABLE_JOIN_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::TABLE_GROUP_OP:
    std::destroy_at(reinterpret_cast< ProjectOp* >(nv->d_children));
    break;

  case kind::CONST_STRING:
    std::destroy_at(reinterpret_cast< String* >(nv->d_children));
    break;

  case kind::CONST_SEQUENCE:
    std::destroy_at(reinterpret_cast< Sequence* >(nv->d_children));
    break;

  case kind::REGEXP_REPEAT_OP:
    std::destroy_at(reinterpret_cast< RegExpRepeat* >(nv->d_children));
    break;

  case kind::REGEXP_LOOP_OP:
    std::destroy_at(reinterpret_cast< RegExpLoop* >(nv->d_children));
    break;

// clang-format on
default:
  Unhandled() << cvc5::internal::expr::NodeValue::dKindToKind(nv->d_kind);
  }
}

// re-enable the strict-aliasing warning
# pragma GCC diagnostic warning "-Wstrict-aliasing"

uint32_t getMinArityForKind(cvc5::internal::Kind k)
{
  static const unsigned lbs[] = {
    0, /* NULL_EXPR */
// clang-format off

    0, /* SORT_TYPE */
    1, /* INSTANTIATED_SORT_TYPE */
    0, /* UNINTERPRETED_SORT_VALUE */
    0, /* BUILTIN */
    2, /* EQUAL */
    2, /* DISTINCT */
    0, /* VARIABLE */
    0, /* BOUND_VARIABLE */
    0, /* SKOLEM */
    0, /* SEXPR */
    2, /* WITNESS */
    0, /* TYPE_CONSTANT */
    0, /* RAW_SYMBOL */
    0, /* ABSTRACT_TYPE */
    0, /* APPLY_INDEXED_SYMBOLIC_OP */
    1, /* APPLY_INDEXED_SYMBOLIC */
    0, /* CONST_BOOLEAN */
    1, /* NOT */
    2, /* AND */
    2, /* IMPLIES */
    2, /* OR */
    2, /* XOR */
    3, /* ITE */
    1, /* APPLY_UF */
    2, /* FUNCTION_TYPE */
    2, /* LAMBDA */
    0, /* BOOLEAN_TERM_VARIABLE */
    2, /* HO_APPLY */
    0, /* CARDINALITY_CONSTRAINT_OP */
    0, /* CARDINALITY_CONSTRAINT */
    0, /* COMBINED_CARDINALITY_CONSTRAINT_OP */
    0, /* COMBINED_CARDINALITY_CONSTRAINT */
    0, /* FUNCTION_ARRAY_CONST */
    1, /* BITVECTOR_TO_NAT */
    0, /* INT_TO_BITVECTOR_OP */
    1, /* INT_TO_BITVECTOR */
    2, /* ADD */
    2, /* MULT */
    2, /* NONLINEAR_MULT */
    2, /* SUB */
    1, /* NEG */
    2, /* DIVISION */
    2, /* DIVISION_TOTAL */
    2, /* INTS_DIVISION */
    2, /* INTS_DIVISION_TOTAL */
    2, /* INTS_MODULUS */
    2, /* INTS_MODULUS_TOTAL */
    1, /* ABS */
    1, /* DIVISIBLE */
    2, /* POW */
    1, /* POW2 */
    1, /* EXPONENTIAL */
    1, /* SINE */
    1, /* COSINE */
    1, /* TANGENT */
    1, /* COSECANT */
    1, /* SECANT */
    1, /* COTANGENT */
    1, /* ARCSINE */
    1, /* ARCCOSINE */
    1, /* ARCTANGENT */
    1, /* ARCCOSECANT */
    1, /* ARCSECANT */
    1, /* ARCCOTANGENT */
    1, /* SQRT */
    0, /* DIVISIBLE_OP */
    0, /* CONST_RATIONAL */
    0, /* CONST_INTEGER */
    0, /* REAL_ALGEBRAIC_NUMBER_OP */
    0, /* REAL_ALGEBRAIC_NUMBER */
    2, /* LT */
    2, /* LEQ */
    2, /* GT */
    2, /* GEQ */
    0, /* INDEXED_ROOT_PREDICATE_OP */
    2, /* INDEXED_ROOT_PREDICATE */
    1, /* IS_INTEGER */
    1, /* TO_INTEGER */
    1, /* TO_REAL */
    0, /* PI */
    0, /* IAND_OP */
    2, /* IAND */
    0, /* BITVECTOR_TYPE */
    0, /* CONST_BITVECTOR */
    1, /* BITVECTOR_BB_TERM */
    2, /* BITVECTOR_CONCAT */
    2, /* BITVECTOR_AND */
    2, /* BITVECTOR_COMP */
    2, /* BITVECTOR_OR */
    2, /* BITVECTOR_XOR */
    1, /* BITVECTOR_NOT */
    2, /* BITVECTOR_NAND */
    2, /* BITVECTOR_NOR */
    2, /* BITVECTOR_XNOR */
    2, /* BITVECTOR_MULT */
    1, /* BITVECTOR_NEG */
    2, /* BITVECTOR_ADD */
    2, /* BITVECTOR_SUB */
    2, /* BITVECTOR_UDIV */
    2, /* BITVECTOR_UREM */
    2, /* BITVECTOR_SDIV */
    2, /* BITVECTOR_SMOD */
    2, /* BITVECTOR_SREM */
    2, /* BITVECTOR_ASHR */
    2, /* BITVECTOR_LSHR */
    2, /* BITVECTOR_SHL */
    2, /* BITVECTOR_ULE */
    2, /* BITVECTOR_ULT */
    2, /* BITVECTOR_UGE */
    2, /* BITVECTOR_UGT */
    2, /* BITVECTOR_SLE */
    2, /* BITVECTOR_SLT */
    2, /* BITVECTOR_SGE */
    2, /* BITVECTOR_SGT */
    2, /* BITVECTOR_ULTBV */
    2, /* BITVECTOR_SLTBV */
    1, /* BITVECTOR_REDAND */
    1, /* BITVECTOR_REDOR */
    2, /* BITVECTOR_UADDO */
    2, /* BITVECTOR_SADDO */
    2, /* BITVECTOR_UMULO */
    2, /* BITVECTOR_SMULO */
    2, /* BITVECTOR_USUBO */
    2, /* BITVECTOR_SSUBO */
    2, /* BITVECTOR_SDIVO */
    3, /* BITVECTOR_ITE */
    1, /* BITVECTOR_ACKERMANNIZE_UDIV */
    1, /* BITVECTOR_ACKERMANNIZE_UREM */
    1, /* BITVECTOR_EAGER_ATOM */
    0, /* BITVECTOR_BITOF_OP */
    1, /* BITVECTOR_BITOF */
    0, /* BITVECTOR_EXTRACT_OP */
    1, /* BITVECTOR_EXTRACT */
    0, /* BITVECTOR_REPEAT_OP */
    1, /* BITVECTOR_REPEAT */
    0, /* BITVECTOR_ROTATE_LEFT_OP */
    1, /* BITVECTOR_ROTATE_LEFT */
    0, /* BITVECTOR_ROTATE_RIGHT_OP */
    1, /* BITVECTOR_ROTATE_RIGHT */
    0, /* BITVECTOR_SIGN_EXTEND_OP */
    1, /* BITVECTOR_SIGN_EXTEND */
    0, /* BITVECTOR_ZERO_EXTEND_OP */
    1, /* BITVECTOR_ZERO_EXTEND */
    0, /* FINITE_FIELD_TYPE */
    0, /* CONST_FINITE_FIELD */
    2, /* FINITE_FIELD_MULT */
    1, /* FINITE_FIELD_NEG */
    2, /* FINITE_FIELD_ADD */
    0, /* CONST_FLOATINGPOINT */
    0, /* CONST_ROUNDINGMODE */
    0, /* FLOATINGPOINT_TYPE */
    3, /* FLOATINGPOINT_FP */
    2, /* FLOATINGPOINT_EQ */
    1, /* FLOATINGPOINT_ABS */
    1, /* FLOATINGPOINT_NEG */
    3, /* FLOATINGPOINT_ADD */
    3, /* FLOATINGPOINT_SUB */
    3, /* FLOATINGPOINT_MULT */
    3, /* FLOATINGPOINT_DIV */
    4, /* FLOATINGPOINT_FMA */
    2, /* FLOATINGPOINT_SQRT */
    2, /* FLOATINGPOINT_REM */
    2, /* FLOATINGPOINT_RTI */
    2, /* FLOATINGPOINT_MIN */
    2, /* FLOATINGPOINT_MAX */
    3, /* FLOATINGPOINT_MIN_TOTAL */
    3, /* FLOATINGPOINT_MAX_TOTAL */
    2, /* FLOATINGPOINT_LEQ */
    2, /* FLOATINGPOINT_LT */
    2, /* FLOATINGPOINT_GEQ */
    2, /* FLOATINGPOINT_GT */
    1, /* FLOATINGPOINT_IS_NORMAL */
    1, /* FLOATINGPOINT_IS_SUBNORMAL */
    1, /* FLOATINGPOINT_IS_ZERO */
    1, /* FLOATINGPOINT_IS_INF */
    1, /* FLOATINGPOINT_IS_NAN */
    1, /* FLOATINGPOINT_IS_NEG */
    1, /* FLOATINGPOINT_IS_POS */
    0, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP */
    1, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV */
    0, /* FLOATINGPOINT_TO_FP_FROM_FP_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_FP */
    0, /* FLOATINGPOINT_TO_FP_FROM_REAL_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_REAL */
    0, /* FLOATINGPOINT_TO_FP_FROM_SBV_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_SBV */
    0, /* FLOATINGPOINT_TO_FP_FROM_UBV_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_UBV */
    0, /* FLOATINGPOINT_TO_UBV_OP */
    2, /* FLOATINGPOINT_TO_UBV */
    0, /* FLOATINGPOINT_TO_UBV_TOTAL_OP */
    3, /* FLOATINGPOINT_TO_UBV_TOTAL */
    0, /* FLOATINGPOINT_TO_SBV_OP */
    2, /* FLOATINGPOINT_TO_SBV */
    0, /* FLOATINGPOINT_TO_SBV_TOTAL_OP */
    3, /* FLOATINGPOINT_TO_SBV_TOTAL */
    1, /* FLOATINGPOINT_TO_REAL */
    2, /* FLOATINGPOINT_TO_REAL_TOTAL */
    1, /* FLOATINGPOINT_COMPONENT_NAN */
    1, /* FLOATINGPOINT_COMPONENT_INF */
    1, /* FLOATINGPOINT_COMPONENT_ZERO */
    1, /* FLOATINGPOINT_COMPONENT_SIGN */
    1, /* FLOATINGPOINT_COMPONENT_EXPONENT */
    1, /* FLOATINGPOINT_COMPONENT_SIGNIFICAND */
    1, /* ROUNDINGMODE_BITBLAST */
    2, /* ARRAY_TYPE */
    2, /* SELECT */
    3, /* STORE */
    4, /* EQ_RANGE */
    0, /* STORE_ALL */
    1, /* ARRAY_LAMBDA */
    1, /* CONSTRUCTOR_TYPE */
    2, /* SELECTOR_TYPE */
    1, /* TESTER_TYPE */
    2, /* UPDATER_TYPE */
    0, /* APPLY_CONSTRUCTOR */
    1, /* APPLY_SELECTOR */
    1, /* APPLY_TESTER */
    2, /* APPLY_UPDATER */
    0, /* DATATYPE_TYPE */
    1, /* PARAMETRIC_DATATYPE */
    0, /* TUPLE_TYPE */
    1, /* APPLY_TYPE_ASCRIPTION */
    0, /* ASCRIPTION_TYPE */
    1, /* DT_SIZE */
    2, /* DT_HEIGHT_BOUND */
    2, /* DT_SIZE_BOUND */
    2, /* DT_SYGUS_BOUND */
    1, /* DT_SYGUS_EVAL */
    2, /* MATCH */
    2, /* MATCH_CASE */
    3, /* MATCH_BIND_CASE */
    0, /* TUPLE_PROJECT_OP */
    1, /* TUPLE_PROJECT */
    0, /* CODATATYPE_BOUND_VARIABLE */
    0, /* SEP_NIL */
    0, /* SEP_EMP */
    2, /* SEP_PTO */
    2, /* SEP_STAR */
    2, /* SEP_WAND */
    2, /* SEP_LABEL */
    0, /* SET_EMPTY */
    1, /* SET_TYPE */
    2, /* SET_UNION */
    2, /* SET_INTER */
    2, /* SET_MINUS */
    2, /* SET_SUBSET */
    2, /* SET_MEMBER */
    1, /* SET_SINGLETON */
    2, /* SET_INSERT */
    1, /* SET_CARD */
    1, /* SET_COMPLEMENT */
    0, /* SET_UNIVERSE */
    3, /* SET_COMPREHENSION */
    1, /* SET_CHOOSE */
    1, /* SET_IS_SINGLETON */
    2, /* SET_MAP */
    2, /* SET_FILTER */
    3, /* SET_FOLD */
    0, /* RELATION_GROUP_OP */
    1, /* RELATION_GROUP */
    0, /* RELATION_AGGREGATE_OP */
    3, /* RELATION_AGGREGATE */
    0, /* RELATION_PROJECT_OP */
    1, /* RELATION_PROJECT */
    2, /* RELATION_JOIN */
    2, /* RELATION_PRODUCT */
    1, /* RELATION_TRANSPOSE */
    1, /* RELATION_TCLOSURE */
    2, /* RELATION_JOIN_IMAGE */
    1, /* RELATION_IDEN */
    0, /* BAG_EMPTY */
    1, /* BAG_TYPE */
    2, /* BAG_UNION_MAX */
    2, /* BAG_UNION_DISJOINT */
    2, /* BAG_INTER_MIN */
    2, /* BAG_DIFFERENCE_SUBTRACT */
    2, /* BAG_DIFFERENCE_REMOVE */
    2, /* BAG_SUBBAG */
    2, /* BAG_COUNT */
    2, /* BAG_MEMBER */
    1, /* BAG_DUPLICATE_REMOVAL */
    2, /* BAG_MAKE */
    1, /* BAG_IS_SINGLETON */
    1, /* BAG_CARD */
    1, /* BAG_FROM_SET */
    1, /* BAG_TO_SET */
    1, /* BAG_CHOOSE */
    2, /* BAG_MAP */
    2, /* BAG_FILTER */
    3, /* BAG_FOLD */
    2, /* BAG_PARTITION */
    2, /* TABLE_PRODUCT */
    0, /* TABLE_PROJECT_OP */
    1, /* TABLE_PROJECT */
    0, /* TABLE_AGGREGATE_OP */
    3, /* TABLE_AGGREGATE */
    0, /* TABLE_JOIN_OP */
    2, /* TABLE_JOIN */
    0, /* TABLE_GROUP_OP */
    1, /* TABLE_GROUP */
    2, /* STRING_CONCAT */
    2, /* STRING_IN_REGEXP */
    1, /* STRING_LENGTH */
    3, /* STRING_SUBSTR */
    3, /* STRING_UPDATE */
    2, /* STRING_CHARAT */
    2, /* STRING_CONTAINS */
    2, /* STRING_LT */
    2, /* STRING_LEQ */
    3, /* STRING_INDEXOF */
    3, /* STRING_INDEXOF_RE */
    3, /* STRING_REPLACE */
    3, /* STRING_REPLACE_ALL */
    3, /* STRING_REPLACE_RE */
    3, /* STRING_REPLACE_RE_ALL */
    2, /* STRING_PREFIX */
    2, /* STRING_SUFFIX */
    1, /* STRING_IS_DIGIT */
    1, /* STRING_ITOS */
    1, /* STRING_STOI */
    1, /* STRING_TO_CODE */
    1, /* STRING_FROM_CODE */
    1, /* STRING_UNIT */
    1, /* STRING_TO_LOWER */
    1, /* STRING_TO_UPPER */
    1, /* STRING_REV */
    0, /* CONST_STRING */
    1, /* SEQUENCE_TYPE */
    0, /* CONST_SEQUENCE */
    1, /* SEQ_UNIT */
    2, /* SEQ_NTH */
    1, /* STRING_TO_REGEXP */
    2, /* REGEXP_CONCAT */
    2, /* REGEXP_UNION */
    2, /* REGEXP_INTER */
    2, /* REGEXP_DIFF */
    1, /* REGEXP_STAR */
    1, /* REGEXP_PLUS */
    1, /* REGEXP_OPT */
    2, /* REGEXP_RANGE */
    1, /* REGEXP_COMPLEMENT */
    0, /* REGEXP_NONE */
    0, /* REGEXP_ALL */
    0, /* REGEXP_ALLCHAR */
    0, /* REGEXP_REPEAT_OP */
    1, /* REGEXP_REPEAT */
    0, /* REGEXP_LOOP_OP */
    1, /* REGEXP_LOOP */
    1, /* REGEXP_RV */
    2, /* FORALL */
    2, /* EXISTS */
    0, /* INST_CONSTANT */
    0, /* ORACLE */
    1, /* BOUND_VAR_LIST */
    1, /* INST_PATTERN */
    1, /* INST_NO_PATTERN */
    1, /* INST_ATTRIBUTE */
    1, /* INST_POOL */
    2, /* INST_ADD_TO_POOL */
    2, /* SKOLEM_ADD_TO_POOL */
    2, /* ORACLE_FORMULA_GEN */
    1, /* INST_PATTERN_LIST */
// clang-format on

    0 /* LAST_KIND */
  };

  return lbs[k];
}

uint32_t getMaxArityForKind(cvc5::internal::Kind k)
{
  static const unsigned ubs[] = {
    0, /* NULL_EXPR */
// clang-format off

    0, /* SORT_TYPE */
    expr::NodeValue::MAX_CHILDREN, /* INSTANTIATED_SORT_TYPE */
    0, /* UNINTERPRETED_SORT_VALUE */
    0, /* BUILTIN */
    2, /* EQUAL */
    expr::NodeValue::MAX_CHILDREN, /* DISTINCT */
    0, /* VARIABLE */
    0, /* BOUND_VARIABLE */
    0, /* SKOLEM */
    expr::NodeValue::MAX_CHILDREN, /* SEXPR */
    3, /* WITNESS */
    0, /* TYPE_CONSTANT */
    0, /* RAW_SYMBOL */
    0, /* ABSTRACT_TYPE */
    0, /* APPLY_INDEXED_SYMBOLIC_OP */
    expr::NodeValue::MAX_CHILDREN, /* APPLY_INDEXED_SYMBOLIC */
    0, /* CONST_BOOLEAN */
    1, /* NOT */
    expr::NodeValue::MAX_CHILDREN, /* AND */
    2, /* IMPLIES */
    expr::NodeValue::MAX_CHILDREN, /* OR */
    2, /* XOR */
    3, /* ITE */
    expr::NodeValue::MAX_CHILDREN, /* APPLY_UF */
    expr::NodeValue::MAX_CHILDREN, /* FUNCTION_TYPE */
    2, /* LAMBDA */
    0, /* BOOLEAN_TERM_VARIABLE */
    2, /* HO_APPLY */
    0, /* CARDINALITY_CONSTRAINT_OP */
    0, /* CARDINALITY_CONSTRAINT */
    0, /* COMBINED_CARDINALITY_CONSTRAINT_OP */
    0, /* COMBINED_CARDINALITY_CONSTRAINT */
    0, /* FUNCTION_ARRAY_CONST */
    1, /* BITVECTOR_TO_NAT */
    0, /* INT_TO_BITVECTOR_OP */
    1, /* INT_TO_BITVECTOR */
    expr::NodeValue::MAX_CHILDREN, /* ADD */
    expr::NodeValue::MAX_CHILDREN, /* MULT */
    expr::NodeValue::MAX_CHILDREN, /* NONLINEAR_MULT */
    2, /* SUB */
    1, /* NEG */
    2, /* DIVISION */
    2, /* DIVISION_TOTAL */
    2, /* INTS_DIVISION */
    2, /* INTS_DIVISION_TOTAL */
    2, /* INTS_MODULUS */
    2, /* INTS_MODULUS_TOTAL */
    1, /* ABS */
    1, /* DIVISIBLE */
    2, /* POW */
    1, /* POW2 */
    1, /* EXPONENTIAL */
    1, /* SINE */
    1, /* COSINE */
    1, /* TANGENT */
    1, /* COSECANT */
    1, /* SECANT */
    1, /* COTANGENT */
    1, /* ARCSINE */
    1, /* ARCCOSINE */
    1, /* ARCTANGENT */
    1, /* ARCCOSECANT */
    1, /* ARCSECANT */
    1, /* ARCCOTANGENT */
    1, /* SQRT */
    0, /* DIVISIBLE_OP */
    0, /* CONST_RATIONAL */
    0, /* CONST_INTEGER */
    0, /* REAL_ALGEBRAIC_NUMBER_OP */
    0, /* REAL_ALGEBRAIC_NUMBER */
    2, /* LT */
    2, /* LEQ */
    2, /* GT */
    2, /* GEQ */
    0, /* INDEXED_ROOT_PREDICATE_OP */
    2, /* INDEXED_ROOT_PREDICATE */
    1, /* IS_INTEGER */
    1, /* TO_INTEGER */
    1, /* TO_REAL */
    0, /* PI */
    0, /* IAND_OP */
    2, /* IAND */
    0, /* BITVECTOR_TYPE */
    0, /* CONST_BITVECTOR */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_BB_TERM */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_CONCAT */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_AND */
    2, /* BITVECTOR_COMP */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_OR */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_XOR */
    1, /* BITVECTOR_NOT */
    2, /* BITVECTOR_NAND */
    2, /* BITVECTOR_NOR */
    2, /* BITVECTOR_XNOR */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_MULT */
    1, /* BITVECTOR_NEG */
    expr::NodeValue::MAX_CHILDREN, /* BITVECTOR_ADD */
    2, /* BITVECTOR_SUB */
    2, /* BITVECTOR_UDIV */
    2, /* BITVECTOR_UREM */
    2, /* BITVECTOR_SDIV */
    2, /* BITVECTOR_SMOD */
    2, /* BITVECTOR_SREM */
    2, /* BITVECTOR_ASHR */
    2, /* BITVECTOR_LSHR */
    2, /* BITVECTOR_SHL */
    2, /* BITVECTOR_ULE */
    2, /* BITVECTOR_ULT */
    2, /* BITVECTOR_UGE */
    2, /* BITVECTOR_UGT */
    2, /* BITVECTOR_SLE */
    2, /* BITVECTOR_SLT */
    2, /* BITVECTOR_SGE */
    2, /* BITVECTOR_SGT */
    2, /* BITVECTOR_ULTBV */
    2, /* BITVECTOR_SLTBV */
    1, /* BITVECTOR_REDAND */
    1, /* BITVECTOR_REDOR */
    2, /* BITVECTOR_UADDO */
    2, /* BITVECTOR_SADDO */
    2, /* BITVECTOR_UMULO */
    2, /* BITVECTOR_SMULO */
    2, /* BITVECTOR_USUBO */
    2, /* BITVECTOR_SSUBO */
    2, /* BITVECTOR_SDIVO */
    3, /* BITVECTOR_ITE */
    1, /* BITVECTOR_ACKERMANNIZE_UDIV */
    1, /* BITVECTOR_ACKERMANNIZE_UREM */
    1, /* BITVECTOR_EAGER_ATOM */
    0, /* BITVECTOR_BITOF_OP */
    1, /* BITVECTOR_BITOF */
    0, /* BITVECTOR_EXTRACT_OP */
    1, /* BITVECTOR_EXTRACT */
    0, /* BITVECTOR_REPEAT_OP */
    1, /* BITVECTOR_REPEAT */
    0, /* BITVECTOR_ROTATE_LEFT_OP */
    1, /* BITVECTOR_ROTATE_LEFT */
    0, /* BITVECTOR_ROTATE_RIGHT_OP */
    1, /* BITVECTOR_ROTATE_RIGHT */
    0, /* BITVECTOR_SIGN_EXTEND_OP */
    1, /* BITVECTOR_SIGN_EXTEND */
    0, /* BITVECTOR_ZERO_EXTEND_OP */
    1, /* BITVECTOR_ZERO_EXTEND */
    0, /* FINITE_FIELD_TYPE */
    0, /* CONST_FINITE_FIELD */
    expr::NodeValue::MAX_CHILDREN, /* FINITE_FIELD_MULT */
    1, /* FINITE_FIELD_NEG */
    expr::NodeValue::MAX_CHILDREN, /* FINITE_FIELD_ADD */
    0, /* CONST_FLOATINGPOINT */
    0, /* CONST_ROUNDINGMODE */
    0, /* FLOATINGPOINT_TYPE */
    3, /* FLOATINGPOINT_FP */
    expr::NodeValue::MAX_CHILDREN, /* FLOATINGPOINT_EQ */
    1, /* FLOATINGPOINT_ABS */
    1, /* FLOATINGPOINT_NEG */
    3, /* FLOATINGPOINT_ADD */
    3, /* FLOATINGPOINT_SUB */
    3, /* FLOATINGPOINT_MULT */
    3, /* FLOATINGPOINT_DIV */
    4, /* FLOATINGPOINT_FMA */
    2, /* FLOATINGPOINT_SQRT */
    2, /* FLOATINGPOINT_REM */
    2, /* FLOATINGPOINT_RTI */
    2, /* FLOATINGPOINT_MIN */
    2, /* FLOATINGPOINT_MAX */
    3, /* FLOATINGPOINT_MIN_TOTAL */
    3, /* FLOATINGPOINT_MAX_TOTAL */
    expr::NodeValue::MAX_CHILDREN, /* FLOATINGPOINT_LEQ */
    expr::NodeValue::MAX_CHILDREN, /* FLOATINGPOINT_LT */
    expr::NodeValue::MAX_CHILDREN, /* FLOATINGPOINT_GEQ */
    expr::NodeValue::MAX_CHILDREN, /* FLOATINGPOINT_GT */
    1, /* FLOATINGPOINT_IS_NORMAL */
    1, /* FLOATINGPOINT_IS_SUBNORMAL */
    1, /* FLOATINGPOINT_IS_ZERO */
    1, /* FLOATINGPOINT_IS_INF */
    1, /* FLOATINGPOINT_IS_NAN */
    1, /* FLOATINGPOINT_IS_NEG */
    1, /* FLOATINGPOINT_IS_POS */
    0, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP */
    1, /* FLOATINGPOINT_TO_FP_FROM_IEEE_BV */
    0, /* FLOATINGPOINT_TO_FP_FROM_FP_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_FP */
    0, /* FLOATINGPOINT_TO_FP_FROM_REAL_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_REAL */
    0, /* FLOATINGPOINT_TO_FP_FROM_SBV_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_SBV */
    0, /* FLOATINGPOINT_TO_FP_FROM_UBV_OP */
    2, /* FLOATINGPOINT_TO_FP_FROM_UBV */
    0, /* FLOATINGPOINT_TO_UBV_OP */
    2, /* FLOATINGPOINT_TO_UBV */
    0, /* FLOATINGPOINT_TO_UBV_TOTAL_OP */
    3, /* FLOATINGPOINT_TO_UBV_TOTAL */
    0, /* FLOATINGPOINT_TO_SBV_OP */
    2, /* FLOATINGPOINT_TO_SBV */
    0, /* FLOATINGPOINT_TO_SBV_TOTAL_OP */
    3, /* FLOATINGPOINT_TO_SBV_TOTAL */
    1, /* FLOATINGPOINT_TO_REAL */
    2, /* FLOATINGPOINT_TO_REAL_TOTAL */
    1, /* FLOATINGPOINT_COMPONENT_NAN */
    1, /* FLOATINGPOINT_COMPONENT_INF */
    1, /* FLOATINGPOINT_COMPONENT_ZERO */
    1, /* FLOATINGPOINT_COMPONENT_SIGN */
    1, /* FLOATINGPOINT_COMPONENT_EXPONENT */
    1, /* FLOATINGPOINT_COMPONENT_SIGNIFICAND */
    1, /* ROUNDINGMODE_BITBLAST */
    2, /* ARRAY_TYPE */
    2, /* SELECT */
    3, /* STORE */
    4, /* EQ_RANGE */
    0, /* STORE_ALL */
    1, /* ARRAY_LAMBDA */
    expr::NodeValue::MAX_CHILDREN, /* CONSTRUCTOR_TYPE */
    2, /* SELECTOR_TYPE */
    1, /* TESTER_TYPE */
    2, /* UPDATER_TYPE */
    expr::NodeValue::MAX_CHILDREN, /* APPLY_CONSTRUCTOR */
    1, /* APPLY_SELECTOR */
    1, /* APPLY_TESTER */
    2, /* APPLY_UPDATER */
    0, /* DATATYPE_TYPE */
    expr::NodeValue::MAX_CHILDREN, /* PARAMETRIC_DATATYPE */
    expr::NodeValue::MAX_CHILDREN, /* TUPLE_TYPE */
    1, /* APPLY_TYPE_ASCRIPTION */
    0, /* ASCRIPTION_TYPE */
    1, /* DT_SIZE */
    2, /* DT_HEIGHT_BOUND */
    2, /* DT_SIZE_BOUND */
    2, /* DT_SYGUS_BOUND */
    expr::NodeValue::MAX_CHILDREN, /* DT_SYGUS_EVAL */
    expr::NodeValue::MAX_CHILDREN, /* MATCH */
    2, /* MATCH_CASE */
    3, /* MATCH_BIND_CASE */
    0, /* TUPLE_PROJECT_OP */
    1, /* TUPLE_PROJECT */
    0, /* CODATATYPE_BOUND_VARIABLE */
    0, /* SEP_NIL */
    0, /* SEP_EMP */
    2, /* SEP_PTO */
    expr::NodeValue::MAX_CHILDREN, /* SEP_STAR */
    2, /* SEP_WAND */
    2, /* SEP_LABEL */
    0, /* SET_EMPTY */
    1, /* SET_TYPE */
    2, /* SET_UNION */
    2, /* SET_INTER */
    2, /* SET_MINUS */
    2, /* SET_SUBSET */
    2, /* SET_MEMBER */
    1, /* SET_SINGLETON */
    expr::NodeValue::MAX_CHILDREN, /* SET_INSERT */
    1, /* SET_CARD */
    1, /* SET_COMPLEMENT */
    0, /* SET_UNIVERSE */
    3, /* SET_COMPREHENSION */
    1, /* SET_CHOOSE */
    1, /* SET_IS_SINGLETON */
    2, /* SET_MAP */
    2, /* SET_FILTER */
    3, /* SET_FOLD */
    0, /* RELATION_GROUP_OP */
    1, /* RELATION_GROUP */
    0, /* RELATION_AGGREGATE_OP */
    3, /* RELATION_AGGREGATE */
    0, /* RELATION_PROJECT_OP */
    1, /* RELATION_PROJECT */
    2, /* RELATION_JOIN */
    2, /* RELATION_PRODUCT */
    1, /* RELATION_TRANSPOSE */
    1, /* RELATION_TCLOSURE */
    2, /* RELATION_JOIN_IMAGE */
    1, /* RELATION_IDEN */
    0, /* BAG_EMPTY */
    1, /* BAG_TYPE */
    2, /* BAG_UNION_MAX */
    2, /* BAG_UNION_DISJOINT */
    2, /* BAG_INTER_MIN */
    2, /* BAG_DIFFERENCE_SUBTRACT */
    2, /* BAG_DIFFERENCE_REMOVE */
    2, /* BAG_SUBBAG */
    2, /* BAG_COUNT */
    2, /* BAG_MEMBER */
    1, /* BAG_DUPLICATE_REMOVAL */
    2, /* BAG_MAKE */
    1, /* BAG_IS_SINGLETON */
    1, /* BAG_CARD */
    1, /* BAG_FROM_SET */
    1, /* BAG_TO_SET */
    1, /* BAG_CHOOSE */
    2, /* BAG_MAP */
    2, /* BAG_FILTER */
    3, /* BAG_FOLD */
    2, /* BAG_PARTITION */
    2, /* TABLE_PRODUCT */
    0, /* TABLE_PROJECT_OP */
    1, /* TABLE_PROJECT */
    0, /* TABLE_AGGREGATE_OP */
    3, /* TABLE_AGGREGATE */
    0, /* TABLE_JOIN_OP */
    2, /* TABLE_JOIN */
    0, /* TABLE_GROUP_OP */
    1, /* TABLE_GROUP */
    expr::NodeValue::MAX_CHILDREN, /* STRING_CONCAT */
    2, /* STRING_IN_REGEXP */
    1, /* STRING_LENGTH */
    3, /* STRING_SUBSTR */
    3, /* STRING_UPDATE */
    2, /* STRING_CHARAT */
    2, /* STRING_CONTAINS */
    2, /* STRING_LT */
    2, /* STRING_LEQ */
    3, /* STRING_INDEXOF */
    3, /* STRING_INDEXOF_RE */
    3, /* STRING_REPLACE */
    3, /* STRING_REPLACE_ALL */
    3, /* STRING_REPLACE_RE */
    3, /* STRING_REPLACE_RE_ALL */
    2, /* STRING_PREFIX */
    2, /* STRING_SUFFIX */
    1, /* STRING_IS_DIGIT */
    1, /* STRING_ITOS */
    1, /* STRING_STOI */
    1, /* STRING_TO_CODE */
    1, /* STRING_FROM_CODE */
    1, /* STRING_UNIT */
    1, /* STRING_TO_LOWER */
    1, /* STRING_TO_UPPER */
    1, /* STRING_REV */
    0, /* CONST_STRING */
    1, /* SEQUENCE_TYPE */
    0, /* CONST_SEQUENCE */
    1, /* SEQ_UNIT */
    2, /* SEQ_NTH */
    1, /* STRING_TO_REGEXP */
    expr::NodeValue::MAX_CHILDREN, /* REGEXP_CONCAT */
    expr::NodeValue::MAX_CHILDREN, /* REGEXP_UNION */
    expr::NodeValue::MAX_CHILDREN, /* REGEXP_INTER */
    2, /* REGEXP_DIFF */
    1, /* REGEXP_STAR */
    1, /* REGEXP_PLUS */
    1, /* REGEXP_OPT */
    2, /* REGEXP_RANGE */
    1, /* REGEXP_COMPLEMENT */
    0, /* REGEXP_NONE */
    0, /* REGEXP_ALL */
    0, /* REGEXP_ALLCHAR */
    0, /* REGEXP_REPEAT_OP */
    1, /* REGEXP_REPEAT */
    0, /* REGEXP_LOOP_OP */
    1, /* REGEXP_LOOP */
    1, /* REGEXP_RV */
    3, /* FORALL */
    3, /* EXISTS */
    0, /* INST_CONSTANT */
    0, /* ORACLE */
    expr::NodeValue::MAX_CHILDREN, /* BOUND_VAR_LIST */
    expr::NodeValue::MAX_CHILDREN, /* INST_PATTERN */
    1, /* INST_NO_PATTERN */
    expr::NodeValue::MAX_CHILDREN, /* INST_ATTRIBUTE */
    expr::NodeValue::MAX_CHILDREN, /* INST_POOL */
    2, /* INST_ADD_TO_POOL */
    2, /* SKOLEM_ADD_TO_POOL */
    2, /* ORACLE_FORMULA_GEN */
    expr::NodeValue::MAX_CHILDREN, /* INST_PATTERN_LIST */
// clang-format on

    0, /* LAST_KIND */
  };

  return ubs[k];
}

}  // namespace metakind

/**
 * Map a kind of the operator to the kind of the enclosing expression. For
 * example, since the kind of functions is just VARIABLE, it should map
 * VARIABLE to APPLY_UF.
 */
Kind operatorToKind(cvc5::internal::expr::NodeValue* nv)
{
  if(nv->getKind() == kind::BUILTIN) {
    return nv->getConst<Kind>();
  } else if(nv->getKind() == kind::LAMBDA) {
    return kind::APPLY_UF;
  }

  switch (Kind k CVC5_UNUSED = nv->getKind())
  {
// clang-format off
    

    /* from builtin */
    case kind::APPLY_INDEXED_SYMBOLIC_OP: return kind::APPLY_INDEXED_SYMBOLIC;

    /* from booleans */

    /* from uf */
    case kind::VARIABLE: return kind::APPLY_UF;
    case kind::CARDINALITY_CONSTRAINT_OP: return kind::CARDINALITY_CONSTRAINT;
    case kind::COMBINED_CARDINALITY_CONSTRAINT_OP: return kind::COMBINED_CARDINALITY_CONSTRAINT;
    case kind::INT_TO_BITVECTOR_OP: return kind::INT_TO_BITVECTOR;

    /* from arith */
    case kind::DIVISIBLE_OP: return kind::DIVISIBLE;
    case kind::REAL_ALGEBRAIC_NUMBER_OP: return kind::REAL_ALGEBRAIC_NUMBER;
    case kind::INDEXED_ROOT_PREDICATE_OP: return kind::INDEXED_ROOT_PREDICATE;
    case kind::IAND_OP: return kind::IAND;

    /* from bv */
    case kind::BITVECTOR_BITOF_OP: return kind::BITVECTOR_BITOF;
    case kind::BITVECTOR_EXTRACT_OP: return kind::BITVECTOR_EXTRACT;
    case kind::BITVECTOR_REPEAT_OP: return kind::BITVECTOR_REPEAT;
    case kind::BITVECTOR_ROTATE_LEFT_OP: return kind::BITVECTOR_ROTATE_LEFT;
    case kind::BITVECTOR_ROTATE_RIGHT_OP: return kind::BITVECTOR_ROTATE_RIGHT;
    case kind::BITVECTOR_SIGN_EXTEND_OP: return kind::BITVECTOR_SIGN_EXTEND;
    case kind::BITVECTOR_ZERO_EXTEND_OP: return kind::BITVECTOR_ZERO_EXTEND;

    /* from ff */

    /* from fp */
    case kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV_OP: return kind::FLOATINGPOINT_TO_FP_FROM_IEEE_BV;
    case kind::FLOATINGPOINT_TO_FP_FROM_FP_OP: return kind::FLOATINGPOINT_TO_FP_FROM_FP;
    case kind::FLOATINGPOINT_TO_FP_FROM_REAL_OP: return kind::FLOATINGPOINT_TO_FP_FROM_REAL;
    case kind::FLOATINGPOINT_TO_FP_FROM_SBV_OP: return kind::FLOATINGPOINT_TO_FP_FROM_SBV;
    case kind::FLOATINGPOINT_TO_FP_FROM_UBV_OP: return kind::FLOATINGPOINT_TO_FP_FROM_UBV;
    case kind::FLOATINGPOINT_TO_UBV_OP: return kind::FLOATINGPOINT_TO_UBV;
    case kind::FLOATINGPOINT_TO_UBV_TOTAL_OP: return kind::FLOATINGPOINT_TO_UBV_TOTAL;
    case kind::FLOATINGPOINT_TO_SBV_OP: return kind::FLOATINGPOINT_TO_SBV;
    case kind::FLOATINGPOINT_TO_SBV_TOTAL_OP: return kind::FLOATINGPOINT_TO_SBV_TOTAL;

    /* from arrays */

    /* from datatypes */
    case kind::APPLY_TYPE_ASCRIPTION: return kind::APPLY_CONSTRUCTOR;
    case kind::SELECTOR_TYPE: return kind::APPLY_SELECTOR;
    case kind::TESTER_TYPE: return kind::APPLY_TESTER;
    case kind::UPDATER_TYPE: return kind::APPLY_UPDATER;
    case kind::ASCRIPTION_TYPE: return kind::APPLY_TYPE_ASCRIPTION;
    case kind::TUPLE_PROJECT_OP: return kind::TUPLE_PROJECT;

    /* from sep */

    /* from sets */
    case kind::RELATION_GROUP_OP: return kind::RELATION_GROUP;
    case kind::RELATION_AGGREGATE_OP: return kind::RELATION_AGGREGATE;
    case kind::RELATION_PROJECT_OP: return kind::RELATION_PROJECT;

    /* from bags */
    case kind::TABLE_PROJECT_OP: return kind::TABLE_PROJECT;
    case kind::TABLE_AGGREGATE_OP: return kind::TABLE_AGGREGATE;
    case kind::TABLE_JOIN_OP: return kind::TABLE_JOIN;
    case kind::TABLE_GROUP_OP: return kind::TABLE_GROUP;

    /* from strings */
    case kind::REGEXP_REPEAT_OP: return kind::REGEXP_REPEAT;
    case kind::REGEXP_LOOP_OP: return kind::REGEXP_LOOP;

    /* from quantifiers */
// clang-format on

    default: return kind::UNDEFINED_KIND; /* LAST_KIND */
  };
}

}  // namespace kind
}  // namespace cvc5::internal
