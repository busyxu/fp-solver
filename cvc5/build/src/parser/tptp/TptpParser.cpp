/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g
 *     -                            On : 2024-03-19 12:01:47
 *     -                for the parser : TptpParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/* ****************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "TptpParser.h"


#include <algorithm>
#include <iterator>
#include <vector>

#include <cvc5/cvc5.h>
#include "base/output.h"
#include "parser/antlr_input.h"
#include "parser/parser_antlr.h"
#include "parser/tptp/tptp_antlr.h"

using namespace cvc5;
using namespace cvc5::parser;

/* These need to be macros so they can refer to the PARSER macro, which will be defined
 * by ANTLR *after* this section. (If they were functions, PARSER would be undefined.) */
#undef PARSER_BASE
#define PARSER_BASE ((Tptp*)PARSER->super)
#undef PARSER_STATE
#define PARSER_STATE PARSER_BASE->getTptpState()
#undef SOLVER
#define SOLVER PARSER_STATE->getSolver()
#undef SYM_MAN
#define SYM_MAN PARSER_STATE->getSymbolManager()
#undef MK_TERM
#define MK_TERM(KIND, ...) SOLVER->mkTerm(KIND, {__VA_ARGS__})
#define UNSUPPORTED PARSER_STATE->unimplementedFeature


/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pTptpParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pTptpParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pTptpParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pTptpParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   TptpParserTokenNames[92+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALPHA_NUMERIC",
        (pANTLR3_UINT8) "AND_TOK",
        (pANTLR3_UINT8) "APP_TOK",
        (pANTLR3_UINT8) "ARROW_TOK",
        (pANTLR3_UINT8) "CHOICE_TOK",
        (pANTLR3_UINT8) "CNF_TOK",
        (pANTLR3_UINT8) "COLON_TOK",
        (pANTLR3_UINT8) "COMMA_TOK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "DECIMAL",
        (pANTLR3_UINT8) "DEFINED_SYMBOL",
        (pANTLR3_UINT8) "DEF_DESC_TOK",
        (pANTLR3_UINT8) "DISEQUAL_TOK",
        (pANTLR3_UINT8) "DISTINCT_OBJECT",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "DOT_TOK",
        (pANTLR3_UINT8) "DO_CHAR",
        (pANTLR3_UINT8) "EQUAL_TOK",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FALSE_TOK",
        (pANTLR3_UINT8) "FOF_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "IFF_TOK",
        (pANTLR3_UINT8) "IMPLIES_TOK",
        (pANTLR3_UINT8) "INCLUDE_TOK",
        (pANTLR3_UINT8) "LAMBDA_TOK",
        (pANTLR3_UINT8) "LBRACK_TOK",
        (pANTLR3_UINT8) "LOWER_ALPHA",
        (pANTLR3_UINT8) "LOWER_WORD",
        (pANTLR3_UINT8) "LOWER_WORD_SINGLE_QUOTED",
        (pANTLR3_UINT8) "LPAREN_TOK",
        (pANTLR3_UINT8) "MINUS_TOK",
        (pANTLR3_UINT8) "NOT_TOK",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "NUMERIC",
        (pANTLR3_UINT8) "OR_TOK",
        (pANTLR3_UINT8) "PLUS_TOK",
        (pANTLR3_UINT8) "RBRACK_TOK",
        (pANTLR3_UINT8) "REVAND_TOK",
        (pANTLR3_UINT8) "REVIFF_TOK",
        (pANTLR3_UINT8) "REVIMPLIES_TOK",
        (pANTLR3_UINT8) "REVOR_TOK",
        (pANTLR3_UINT8) "RPAREN_TOK",
        (pANTLR3_UINT8) "SIGN",
        (pANTLR3_UINT8) "SINGLE_QUOTED",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "SQ_CHAR",
        (pANTLR3_UINT8) "SUBTYPE_TOK",
        (pANTLR3_UINT8) "TFF_TOK",
        (pANTLR3_UINT8) "TH1_UN_A",
        (pANTLR3_UINT8) "TH1_UN_E",
        (pANTLR3_UINT8) "THF_TOK",
        (pANTLR3_UINT8) "TIMES_TOK",
        (pANTLR3_UINT8) "TRUE_TOK",
        (pANTLR3_UINT8) "TYPE_TOK",
        (pANTLR3_UINT8) "UPPER_ALPHA",
        (pANTLR3_UINT8) "UPPER_WORD",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'$ceiling'",
        (pANTLR3_UINT8) "'$difference'",
        (pANTLR3_UINT8) "'$distinct'",
        (pANTLR3_UINT8) "'$floor'",
        (pANTLR3_UINT8) "'$greater'",
        (pANTLR3_UINT8) "'$greatereq'",
        (pANTLR3_UINT8) "'$is_int'",
        (pANTLR3_UINT8) "'$is_rat'",
        (pANTLR3_UINT8) "'$ite'",
        (pANTLR3_UINT8) "'$ite_f'",
        (pANTLR3_UINT8) "'$ite_t'",
        (pANTLR3_UINT8) "'$less'",
        (pANTLR3_UINT8) "'$lesseq'",
        (pANTLR3_UINT8) "'$let_ff'",
        (pANTLR3_UINT8) "'$let_ft'",
        (pANTLR3_UINT8) "'$let_tf'",
        (pANTLR3_UINT8) "'$let_tt'",
        (pANTLR3_UINT8) "'$product'",
        (pANTLR3_UINT8) "'$quotient'",
        (pANTLR3_UINT8) "'$quotient_e'",
        (pANTLR3_UINT8) "'$quotient_f'",
        (pANTLR3_UINT8) "'$quotient_t'",
        (pANTLR3_UINT8) "'$remainder_e'",
        (pANTLR3_UINT8) "'$remainder_f'",
        (pANTLR3_UINT8) "'$remainder_t'",
        (pANTLR3_UINT8) "'$round'",
        (pANTLR3_UINT8) "'$sum'",
        (pANTLR3_UINT8) "'$tType'",
        (pANTLR3_UINT8) "'$to_int'",
        (pANTLR3_UINT8) "'$to_rat'",
        (pANTLR3_UINT8) "'$to_real'",
        (pANTLR3_UINT8) "'$truncate'",
        (pANTLR3_UINT8) "'$uminus'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 cvc5::parser::tptp::myExpr
	parseExpr    (pTptpParser ctx);
static 
 std::unique_ptr<cvc5::parser::Command>
	parseCommand    (pTptpParser ctx);
static 
 void
	formulaRole    (pTptpParser ctx, cvc5::parser::TptpState::FormulaRole& role);
static 
 void
	cnfFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	cnfDisjunction    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	cnfLiteral    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	atomicFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	thfAtomicFormula    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	definedProp    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	definedPred    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	thfDefinedPred    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	definedFun    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	equalOp    (pTptpParser ctx, bool& equal);
static 
 void
	term    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	letTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	simpleTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	thfSimpleTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	functionTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	conditionalTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	plainTerm    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	arguments    (pTptpParser ctx, std::vector<cvc5::Term>& args);
static 
 void
	variable    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	fofFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	fofLogicFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	fofUnitaryFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	bindvariable    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	fofBinaryNonAssoc    (pTptpParser ctx, cvc5::parser::tptp::NonAssoc& na);
static 
 void
	folQuantifier    (pTptpParser ctx, cvc5::Kind& kind);
static 
 void
	thfQuantifier    (pTptpParser ctx, cvc5::Kind& kind);
static 
 void
	thfAtomTyping    (pTptpParser ctx, std::unique_ptr<cvc5::parser::Command>& cmd);
static 
 void
	thfLogicFormula    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	thfTupleForm    (pTptpParser ctx, std::vector<cvc5::Term>& args);
static 
 void
	thfUnitaryFormula    (pTptpParser ctx, cvc5::ParseOp& p);
static 
 void
	tffFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	tffTypedAtom    (pTptpParser ctx, std::unique_ptr<cvc5::parser::Command>& cmd);
static 
 void
	tffLogicFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	tffUnitaryFormula    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	tffLetTermDefn    (pTptpParser ctx, cvc5::Term& lhs, cvc5::Term& rhs);
static 
 void
	tffLetTermBinding    (pTptpParser ctx, std::vector<cvc5::Term> & bvlist, cvc5::Term& lhs, cvc5::Term& rhs);
static 
 void
	tffLetFormulaDefn    (pTptpParser ctx, cvc5::Term& lhs, cvc5::Term& rhs);
static 
 void
	tffLetFormulaBinding    (pTptpParser ctx, std::vector<cvc5::Term> & bvlist, cvc5::Term& lhs, cvc5::Term& rhs);
static 
 void
	thfBindVariable    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	tffbindvariable    (pTptpParser ctx, cvc5::Term& expr);
static 
 void
	tffVariableList    (pTptpParser ctx, std::vector<cvc5::Term>& bvlist);
static 
 void
	parseThfType    (pTptpParser ctx, cvc5::Sort& type);
static 
 void
	thfType    (pTptpParser ctx, cvc5::Sort& type);
static 
 void
	parseType    (pTptpParser ctx, cvc5::Sort & type);
static 
 void
	simpleType    (pTptpParser ctx, cvc5::Sort& type);
static 
 void
	anything    (pTptpParser ctx);
static 
 void
	unquotedFileName    (pTptpParser ctx, std::string& name);
static 
 void
	nameN    (pTptpParser ctx, std::string& name);
static 
 void
	atomicWord    (pTptpParser ctx, std::string& name);
static void	TptpParserFree(pTptpParser ctx);
static void     TptpParserReset (pTptpParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new TptpParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTptpParser
TptpParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return TptpParserNewSSD(instream, NULL);
}

/** \brief Create a new TptpParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTptpParser
TptpParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pTptpParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pTptpParser) ANTLR3_CALLOC(1, sizeof(TptpParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in TptpParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our TptpParser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->formulaRole	= formulaRole;
    ctx->cnfFormula	= cnfFormula;
    ctx->cnfDisjunction	= cnfDisjunction;
    ctx->cnfLiteral	= cnfLiteral;
    ctx->atomicFormula	= atomicFormula;
    ctx->thfAtomicFormula	= thfAtomicFormula;
    ctx->definedProp	= definedProp;
    ctx->definedPred	= definedPred;
    ctx->thfDefinedPred	= thfDefinedPred;
    ctx->definedFun	= definedFun;
    ctx->equalOp	= equalOp;
    ctx->term	= term;
    ctx->letTerm	= letTerm;
    ctx->simpleTerm	= simpleTerm;
    ctx->thfSimpleTerm	= thfSimpleTerm;
    ctx->functionTerm	= functionTerm;
    ctx->conditionalTerm	= conditionalTerm;
    ctx->plainTerm	= plainTerm;
    ctx->arguments	= arguments;
    ctx->variable	= variable;
    ctx->fofFormula	= fofFormula;
    ctx->fofLogicFormula	= fofLogicFormula;
    ctx->fofUnitaryFormula	= fofUnitaryFormula;
    ctx->bindvariable	= bindvariable;
    ctx->fofBinaryNonAssoc	= fofBinaryNonAssoc;
    ctx->folQuantifier	= folQuantifier;
    ctx->thfQuantifier	= thfQuantifier;
    ctx->thfAtomTyping	= thfAtomTyping;
    ctx->thfLogicFormula	= thfLogicFormula;
    ctx->thfTupleForm	= thfTupleForm;
    ctx->thfUnitaryFormula	= thfUnitaryFormula;
    ctx->tffFormula	= tffFormula;
    ctx->tffTypedAtom	= tffTypedAtom;
    ctx->tffLogicFormula	= tffLogicFormula;
    ctx->tffUnitaryFormula	= tffUnitaryFormula;
    ctx->tffLetTermDefn	= tffLetTermDefn;
    ctx->tffLetTermBinding	= tffLetTermBinding;
    ctx->tffLetFormulaDefn	= tffLetFormulaDefn;
    ctx->tffLetFormulaBinding	= tffLetFormulaBinding;
    ctx->thfBindVariable	= thfBindVariable;
    ctx->tffbindvariable	= tffbindvariable;
    ctx->tffVariableList	= tffVariableList;
    ctx->parseThfType	= parseThfType;
    ctx->thfType	= thfType;
    ctx->parseType	= parseType;
    ctx->simpleType	= simpleType;
    ctx->anything	= anything;
    ctx->unquotedFileName	= unquotedFileName;
    ctx->nameN	= nameN;
    ctx->atomicWord	= atomicWord;
    ctx->free			= TptpParserFree;
    ctx->reset			= TptpParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = TptpParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
TptpParserReset (pTptpParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 TptpParserFree(pTptpParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return TptpParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfFormula_in_parseExpr112  */
static	ANTLR3_BITWORD FOLLOW_cnfFormula_in_parseExpr112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfFormula_in_parseExpr112	= { FOLLOW_cnfFormula_in_parseExpr112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr119  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr119	= { FOLLOW_EOF_in_parseExpr119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CNF_TOK_in_parseCommand143  */
static	ANTLR3_BITWORD FOLLOW_CNF_TOK_in_parseCommand143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CNF_TOK_in_parseCommand143	= { FOLLOW_CNF_TOK_in_parseCommand143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand145  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand145_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand145	= { FOLLOW_LPAREN_TOK_in_parseCommand145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand147  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand147	= { FOLLOW_nameN_in_parseCommand147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand150  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand150	= { FOLLOW_COMMA_TOK_in_parseCommand150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formulaRole_in_parseCommand152  */
static	ANTLR3_BITWORD FOLLOW_formulaRole_in_parseCommand152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_formulaRole_in_parseCommand152	= { FOLLOW_formulaRole_in_parseCommand152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand155  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand155_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E33020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand155	= { FOLLOW_COMMA_TOK_in_parseCommand155_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfFormula_in_parseCommand165  */
static	ANTLR3_BITWORD FOLLOW_cnfFormula_in_parseCommand165_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfFormula_in_parseCommand165	= { FOLLOW_cnfFormula_in_parseCommand165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand177  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand177_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand177	= { FOLLOW_COMMA_TOK_in_parseCommand177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_parseCommand179  */
static	ANTLR3_BITWORD FOLLOW_anything_in_parseCommand179_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_parseCommand179	= { FOLLOW_anything_in_parseCommand179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand184  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand184	= { FOLLOW_RPAREN_TOK_in_parseCommand184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_parseCommand186  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_parseCommand186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_parseCommand186	= { FOLLOW_DOT_TOK_in_parseCommand186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOF_TOK_in_parseCommand198  */
static	ANTLR3_BITWORD FOLLOW_FOF_TOK_in_parseCommand198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FOF_TOK_in_parseCommand198	= { FOLLOW_FOF_TOK_in_parseCommand198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand200  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand200_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand200	= { FOLLOW_LPAREN_TOK_in_parseCommand200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand202  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand202	= { FOLLOW_nameN_in_parseCommand202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand205  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand205	= { FOLLOW_COMMA_TOK_in_parseCommand205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formulaRole_in_parseCommand207  */
static	ANTLR3_BITWORD FOLLOW_formulaRole_in_parseCommand207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_formulaRole_in_parseCommand207	= { FOLLOW_formulaRole_in_parseCommand207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand210  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand210_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand210	= { FOLLOW_COMMA_TOK_in_parseCommand210_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofFormula_in_parseCommand222  */
static	ANTLR3_BITWORD FOLLOW_fofFormula_in_parseCommand222_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_fofFormula_in_parseCommand222	= { FOLLOW_fofFormula_in_parseCommand222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand226  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand226_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand226	= { FOLLOW_COMMA_TOK_in_parseCommand226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_parseCommand228  */
static	ANTLR3_BITWORD FOLLOW_anything_in_parseCommand228_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_parseCommand228	= { FOLLOW_anything_in_parseCommand228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand233  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand233	= { FOLLOW_RPAREN_TOK_in_parseCommand233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_parseCommand235  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_parseCommand235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_parseCommand235	= { FOLLOW_DOT_TOK_in_parseCommand235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TFF_TOK_in_parseCommand247  */
static	ANTLR3_BITWORD FOLLOW_TFF_TOK_in_parseCommand247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_TFF_TOK_in_parseCommand247	= { FOLLOW_TFF_TOK_in_parseCommand247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand249  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand249_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand249	= { FOLLOW_LPAREN_TOK_in_parseCommand249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand251  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand251	= { FOLLOW_nameN_in_parseCommand251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand254  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand254_bits[]	= { ANTLR3_UINT64_LIT(0x0800000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand254	= { FOLLOW_COMMA_TOK_in_parseCommand254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_parseCommand262  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_parseCommand262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_parseCommand262	= { FOLLOW_TYPE_TOK_in_parseCommand262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand264  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand264_bits[]	= { ANTLR3_UINT64_LIT(0x0922004E22000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand264	= { FOLLOW_COMMA_TOK_in_parseCommand264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffTypedAtom_in_parseCommand266  */
static	ANTLR3_BITWORD FOLLOW_tffTypedAtom_in_parseCommand266_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffTypedAtom_in_parseCommand266	= { FOLLOW_tffTypedAtom_in_parseCommand266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formulaRole_in_parseCommand275  */
static	ANTLR3_BITWORD FOLLOW_formulaRole_in_parseCommand275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_formulaRole_in_parseCommand275	= { FOLLOW_formulaRole_in_parseCommand275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand278  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand278_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand278	= { FOLLOW_COMMA_TOK_in_parseCommand278_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffFormula_in_parseCommand294  */
static	ANTLR3_BITWORD FOLLOW_tffFormula_in_parseCommand294_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffFormula_in_parseCommand294	= { FOLLOW_tffFormula_in_parseCommand294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand298  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand298_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand298	= { FOLLOW_COMMA_TOK_in_parseCommand298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_parseCommand300  */
static	ANTLR3_BITWORD FOLLOW_anything_in_parseCommand300_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_parseCommand300	= { FOLLOW_anything_in_parseCommand300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand319  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand319	= { FOLLOW_RPAREN_TOK_in_parseCommand319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_parseCommand321  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_parseCommand321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_parseCommand321	= { FOLLOW_DOT_TOK_in_parseCommand321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THF_TOK_in_parseCommand327  */
static	ANTLR3_BITWORD FOLLOW_THF_TOK_in_parseCommand327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_THF_TOK_in_parseCommand327	= { FOLLOW_THF_TOK_in_parseCommand327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand339  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand339_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand339	= { FOLLOW_LPAREN_TOK_in_parseCommand339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand341  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand341	= { FOLLOW_nameN_in_parseCommand341_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand344  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand344_bits[]	= { ANTLR3_UINT64_LIT(0x0800000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand344	= { FOLLOW_COMMA_TOK_in_parseCommand344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_parseCommand362  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_parseCommand362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_parseCommand362	= { FOLLOW_TYPE_TOK_in_parseCommand362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand364  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand364_bits[]	= { ANTLR3_UINT64_LIT(0x0922004E22000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand364	= { FOLLOW_COMMA_TOK_in_parseCommand364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfAtomTyping_in_parseCommand366  */
static	ANTLR3_BITWORD FOLLOW_thfAtomTyping_in_parseCommand366_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_thfAtomTyping_in_parseCommand366	= { FOLLOW_thfAtomTyping_in_parseCommand366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formulaRole_in_parseCommand375  */
static	ANTLR3_BITWORD FOLLOW_formulaRole_in_parseCommand375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_formulaRole_in_parseCommand375	= { FOLLOW_formulaRole_in_parseCommand375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand378  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand378_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand378	= { FOLLOW_COMMA_TOK_in_parseCommand378_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfLogicFormula_in_parseCommand394  */
static	ANTLR3_BITWORD FOLLOW_thfLogicFormula_in_parseCommand394_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_thfLogicFormula_in_parseCommand394	= { FOLLOW_thfLogicFormula_in_parseCommand394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand398  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand398_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand398	= { FOLLOW_COMMA_TOK_in_parseCommand398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_parseCommand400  */
static	ANTLR3_BITWORD FOLLOW_anything_in_parseCommand400_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_parseCommand400	= { FOLLOW_anything_in_parseCommand400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand419  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand419	= { FOLLOW_RPAREN_TOK_in_parseCommand419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_parseCommand421  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_parseCommand421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_parseCommand421	= { FOLLOW_DOT_TOK_in_parseCommand421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_parseCommand427  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_parseCommand427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_parseCommand427	= { FOLLOW_INCLUDE_TOK_in_parseCommand427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand429  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand429_bits[]	= { ANTLR3_UINT64_LIT(0x0002000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand429	= { FOLLOW_LPAREN_TOK_in_parseCommand429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unquotedFileName_in_parseCommand431  */
static	ANTLR3_BITWORD FOLLOW_unquotedFileName_in_parseCommand431_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_unquotedFileName_in_parseCommand431	= { FOLLOW_unquotedFileName_in_parseCommand431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand440  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand440	= { FOLLOW_COMMA_TOK_in_parseCommand440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_parseCommand442  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_parseCommand442_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_parseCommand442	= { FOLLOW_LBRACK_TOK_in_parseCommand442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand444  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand444_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand444	= { FOLLOW_nameN_in_parseCommand444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_parseCommand455  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_parseCommand455_bits[]	= { ANTLR3_UINT64_LIT(0x0922004622000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_parseCommand455	= { FOLLOW_COMMA_TOK_in_parseCommand455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_parseCommand457  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_parseCommand457_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_parseCommand457	= { FOLLOW_nameN_in_parseCommand457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_parseCommand463  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_parseCommand463_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_parseCommand463	= { FOLLOW_RBRACK_TOK_in_parseCommand463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand472  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand472	= { FOLLOW_RPAREN_TOK_in_parseCommand472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_parseCommand474  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_parseCommand474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_parseCommand474	= { FOLLOW_DOT_TOK_in_parseCommand474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseCommand486  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseCommand486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseCommand486	= { FOLLOW_EOF_in_parseCommand486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_in_formulaRole508  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_in_formulaRole508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_in_formulaRole508	= { FOLLOW_LOWER_WORD_in_formulaRole508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_cnfFormula536  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_cnfFormula536_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016633020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_cnfFormula536	= { FOLLOW_LPAREN_TOK_in_cnfFormula536_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfDisjunction_in_cnfFormula538  */
static	ANTLR3_BITWORD FOLLOW_cnfDisjunction_in_cnfFormula538_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfDisjunction_in_cnfFormula538	= { FOLLOW_cnfDisjunction_in_cnfFormula538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_cnfFormula541  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_cnfFormula541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_cnfFormula541	= { FOLLOW_RPAREN_TOK_in_cnfFormula541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfDisjunction_in_cnfFormula547  */
static	ANTLR3_BITWORD FOLLOW_cnfDisjunction_in_cnfFormula547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfDisjunction_in_cnfFormula547	= { FOLLOW_cnfDisjunction_in_cnfFormula547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfLiteral_in_cnfDisjunction565  */
static	ANTLR3_BITWORD FOLLOW_cnfLiteral_in_cnfDisjunction565_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfLiteral_in_cnfDisjunction565	= { FOLLOW_cnfLiteral_in_cnfDisjunction565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_cnfDisjunction576  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_cnfDisjunction576_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016633020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_cnfDisjunction576	= { FOLLOW_OR_TOK_in_cnfDisjunction576_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnfLiteral_in_cnfDisjunction578  */
static	ANTLR3_BITWORD FOLLOW_cnfLiteral_in_cnfDisjunction578_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnfLiteral_in_cnfDisjunction578	= { FOLLOW_cnfLiteral_in_cnfDisjunction578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormula_in_cnfLiteral602  */
static	ANTLR3_BITWORD FOLLOW_atomicFormula_in_cnfLiteral602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicFormula_in_cnfLiteral602	= { FOLLOW_atomicFormula_in_cnfLiteral602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_cnfLiteral609  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_cnfLiteral609_bits[]	= { ANTLR3_UINT64_LIT(0xAD22014633020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_cnfLiteral609	= { FOLLOW_NOT_TOK_in_cnfLiteral609_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormula_in_cnfLiteral611  */
static	ANTLR3_BITWORD FOLLOW_atomicFormula_in_cnfLiteral611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicFormula_in_cnfLiteral611	= { FOLLOW_atomicFormula_in_cnfLiteral611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicWord_in_atomicFormula633  */
static	ANTLR3_BITWORD FOLLOW_atomicWord_in_atomicFormula633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800210002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicWord_in_atomicFormula633	= { FOLLOW_atomicWord_in_atomicFormula633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_atomicFormula637  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_atomicFormula637_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_atomicFormula637	= { FOLLOW_LPAREN_TOK_in_atomicFormula637_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_atomicFormula639  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_atomicFormula639_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_atomicFormula639	= { FOLLOW_arguments_in_atomicFormula639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_atomicFormula642  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_atomicFormula642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_atomicFormula642	= { FOLLOW_RPAREN_TOK_in_atomicFormula642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalOp_in_atomicFormula652  */
static	ANTLR3_BITWORD FOLLOW_equalOp_in_atomicFormula652_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_equalOp_in_atomicFormula652	= { FOLLOW_equalOp_in_atomicFormula652_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atomicFormula655  */
static	ANTLR3_BITWORD FOLLOW_term_in_atomicFormula655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_atomicFormula655	= { FOLLOW_term_in_atomicFormula655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedFun_in_atomicFormula684  */
static	ANTLR3_BITWORD FOLLOW_definedFun_in_atomicFormula684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedFun_in_atomicFormula684	= { FOLLOW_definedFun_in_atomicFormula684_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_atomicFormula698  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_atomicFormula698_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_atomicFormula698	= { FOLLOW_LPAREN_TOK_in_atomicFormula698_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_atomicFormula700  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_atomicFormula700_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_atomicFormula700	= { FOLLOW_arguments_in_atomicFormula700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_atomicFormula703  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_atomicFormula703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_atomicFormula703	= { FOLLOW_RPAREN_TOK_in_atomicFormula703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalOp_in_atomicFormula710  */
static	ANTLR3_BITWORD FOLLOW_equalOp_in_atomicFormula710_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_equalOp_in_atomicFormula710	= { FOLLOW_equalOp_in_atomicFormula710_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atomicFormula713  */
static	ANTLR3_BITWORD FOLLOW_term_in_atomicFormula713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_atomicFormula713	= { FOLLOW_term_in_atomicFormula713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleTerm_in_atomicFormula734  */
static	ANTLR3_BITWORD FOLLOW_simpleTerm_in_atomicFormula734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleTerm_in_atomicFormula734	= { FOLLOW_simpleTerm_in_atomicFormula734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letTerm_in_atomicFormula739  */
static	ANTLR3_BITWORD FOLLOW_letTerm_in_atomicFormula739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210002) };
static  ANTLR3_BITSET_LIST FOLLOW_letTerm_in_atomicFormula739	= { FOLLOW_letTerm_in_atomicFormula739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalTerm_in_atomicFormula744  */
static	ANTLR3_BITWORD FOLLOW_conditionalTerm_in_atomicFormula744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalTerm_in_atomicFormula744	= { FOLLOW_conditionalTerm_in_atomicFormula744_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalOp_in_atomicFormula760  */
static	ANTLR3_BITWORD FOLLOW_equalOp_in_atomicFormula760_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_equalOp_in_atomicFormula760	= { FOLLOW_equalOp_in_atomicFormula760_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atomicFormula763  */
static	ANTLR3_BITWORD FOLLOW_term_in_atomicFormula763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_atomicFormula763	= { FOLLOW_term_in_atomicFormula763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedPred_in_atomicFormula785  */
static	ANTLR3_BITWORD FOLLOW_definedPred_in_atomicFormula785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedPred_in_atomicFormula785	= { FOLLOW_definedPred_in_atomicFormula785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_atomicFormula789  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_atomicFormula789_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_atomicFormula789	= { FOLLOW_LPAREN_TOK_in_atomicFormula789_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_atomicFormula791  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_atomicFormula791_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_atomicFormula791	= { FOLLOW_arguments_in_atomicFormula791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_atomicFormula794  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_atomicFormula794_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_atomicFormula794	= { FOLLOW_RPAREN_TOK_in_atomicFormula794_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedProp_in_atomicFormula807  */
static	ANTLR3_BITWORD FOLLOW_definedProp_in_atomicFormula807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedProp_in_atomicFormula807	= { FOLLOW_definedProp_in_atomicFormula807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicWord_in_thfAtomicFormula827  */
static	ANTLR3_BITWORD FOLLOW_atomicWord_in_thfAtomicFormula827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicWord_in_thfAtomicFormula827	= { FOLLOW_atomicWord_in_thfAtomicFormula827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfAtomicFormula831  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfAtomicFormula831_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfAtomicFormula831	= { FOLLOW_LPAREN_TOK_in_thfAtomicFormula831_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_thfAtomicFormula833  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_thfAtomicFormula833_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_thfAtomicFormula833	= { FOLLOW_arguments_in_thfAtomicFormula833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfAtomicFormula836  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfAtomicFormula836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfAtomicFormula836	= { FOLLOW_RPAREN_TOK_in_thfAtomicFormula836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedFun_in_thfAtomicFormula850  */
static	ANTLR3_BITWORD FOLLOW_definedFun_in_thfAtomicFormula850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedFun_in_thfAtomicFormula850	= { FOLLOW_definedFun_in_thfAtomicFormula850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfAtomicFormula865  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfAtomicFormula865_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfAtomicFormula865	= { FOLLOW_LPAREN_TOK_in_thfAtomicFormula865_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_thfAtomicFormula867  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_thfAtomicFormula867_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_thfAtomicFormula867	= { FOLLOW_arguments_in_thfAtomicFormula867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfAtomicFormula870  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfAtomicFormula870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000210000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfAtomicFormula870	= { FOLLOW_RPAREN_TOK_in_thfAtomicFormula870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalOp_in_thfAtomicFormula878  */
static	ANTLR3_BITWORD FOLLOW_equalOp_in_thfAtomicFormula878_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_equalOp_in_thfAtomicFormula878	= { FOLLOW_equalOp_in_thfAtomicFormula878_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_thfAtomicFormula881  */
static	ANTLR3_BITWORD FOLLOW_term_in_thfAtomicFormula881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_thfAtomicFormula881	= { FOLLOW_term_in_thfAtomicFormula881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfSimpleTerm_in_thfAtomicFormula903  */
static	ANTLR3_BITWORD FOLLOW_thfSimpleTerm_in_thfAtomicFormula903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfSimpleTerm_in_thfAtomicFormula903	= { FOLLOW_thfSimpleTerm_in_thfAtomicFormula903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letTerm_in_thfAtomicFormula910  */
static	ANTLR3_BITWORD FOLLOW_letTerm_in_thfAtomicFormula910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_letTerm_in_thfAtomicFormula910	= { FOLLOW_letTerm_in_thfAtomicFormula910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalTerm_in_thfAtomicFormula917  */
static	ANTLR3_BITWORD FOLLOW_conditionalTerm_in_thfAtomicFormula917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalTerm_in_thfAtomicFormula917	= { FOLLOW_conditionalTerm_in_thfAtomicFormula917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfDefinedPred_in_thfAtomicFormula924  */
static	ANTLR3_BITWORD FOLLOW_thfDefinedPred_in_thfAtomicFormula924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfDefinedPred_in_thfAtomicFormula924	= { FOLLOW_thfDefinedPred_in_thfAtomicFormula924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfAtomicFormula928  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfAtomicFormula928_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfAtomicFormula928	= { FOLLOW_LPAREN_TOK_in_thfAtomicFormula928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_thfAtomicFormula930  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_thfAtomicFormula930_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_thfAtomicFormula930	= { FOLLOW_arguments_in_thfAtomicFormula930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfAtomicFormula933  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfAtomicFormula933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfAtomicFormula933	= { FOLLOW_RPAREN_TOK_in_thfAtomicFormula933_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedProp_in_thfAtomicFormula947  */
static	ANTLR3_BITWORD FOLLOW_definedProp_in_thfAtomicFormula947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedProp_in_thfAtomicFormula947	= { FOLLOW_definedProp_in_thfAtomicFormula947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_definedProp965  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_definedProp965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_definedProp965	= { FOLLOW_TRUE_TOK_in_definedProp965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_definedProp973  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_definedProp973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_definedProp973	= { FOLLOW_FALSE_TOK_in_definedProp973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_74_in_definedPred990  */
static	ANTLR3_BITWORD FOLLOW_74_in_definedPred990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_74_in_definedPred990	= { FOLLOW_74_in_definedPred990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_definedPred1002  */
static	ANTLR3_BITWORD FOLLOW_75_in_definedPred1002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_definedPred1002	= { FOLLOW_75_in_definedPred1002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_67_in_definedPred1014  */
static	ANTLR3_BITWORD FOLLOW_67_in_definedPred1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_67_in_definedPred1014	= { FOLLOW_67_in_definedPred1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_definedPred1026  */
static	ANTLR3_BITWORD FOLLOW_68_in_definedPred1026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_68_in_definedPred1026	= { FOLLOW_68_in_definedPred1026_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_definedPred1038  */
static	ANTLR3_BITWORD FOLLOW_70_in_definedPred1038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_70_in_definedPred1038	= { FOLLOW_70_in_definedPred1038_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_definedPred1065  */
static	ANTLR3_BITWORD FOLLOW_69_in_definedPred1065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_69_in_definedPred1065	= { FOLLOW_69_in_definedPred1065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_definedPred1077  */
static	ANTLR3_BITWORD FOLLOW_65_in_definedPred1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_65_in_definedPred1077	= { FOLLOW_65_in_definedPred1077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_definedPred1089  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_definedPred1089_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_definedPred1089	= { FOLLOW_AND_TOK_in_definedPred1089_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_definedPred1101  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_definedPred1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_definedPred1101	= { FOLLOW_IMPLIES_TOK_in_definedPred1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_definedPred1113  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_definedPred1113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_definedPred1113	= { FOLLOW_OR_TOK_in_definedPred1113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_74_in_thfDefinedPred1133  */
static	ANTLR3_BITWORD FOLLOW_74_in_thfDefinedPred1133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_74_in_thfDefinedPred1133	= { FOLLOW_74_in_thfDefinedPred1133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_thfDefinedPred1146  */
static	ANTLR3_BITWORD FOLLOW_75_in_thfDefinedPred1146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_75_in_thfDefinedPred1146	= { FOLLOW_75_in_thfDefinedPred1146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_67_in_thfDefinedPred1158  */
static	ANTLR3_BITWORD FOLLOW_67_in_thfDefinedPred1158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_67_in_thfDefinedPred1158	= { FOLLOW_67_in_thfDefinedPred1158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_thfDefinedPred1170  */
static	ANTLR3_BITWORD FOLLOW_68_in_thfDefinedPred1170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_68_in_thfDefinedPred1170	= { FOLLOW_68_in_thfDefinedPred1170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_thfDefinedPred1182  */
static	ANTLR3_BITWORD FOLLOW_70_in_thfDefinedPred1182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_70_in_thfDefinedPred1182	= { FOLLOW_70_in_thfDefinedPred1182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_thfDefinedPred1209  */
static	ANTLR3_BITWORD FOLLOW_69_in_thfDefinedPred1209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_69_in_thfDefinedPred1209	= { FOLLOW_69_in_thfDefinedPred1209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_thfDefinedPred1221  */
static	ANTLR3_BITWORD FOLLOW_65_in_thfDefinedPred1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_65_in_thfDefinedPred1221	= { FOLLOW_65_in_thfDefinedPred1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfDefinedPred1233  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfDefinedPred1233_bits[]	= { ANTLR3_UINT64_LIT(0x0000010010000020) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfDefinedPred1233	= { FOLLOW_LPAREN_TOK_in_thfDefinedPred1233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_thfDefinedPred1247  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_thfDefinedPred1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_thfDefinedPred1247	= { FOLLOW_AND_TOK_in_thfDefinedPred1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_thfDefinedPred1263  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_thfDefinedPred1263_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_thfDefinedPred1263	= { FOLLOW_OR_TOK_in_thfDefinedPred1263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_thfDefinedPred1279  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_thfDefinedPred1279_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_thfDefinedPred1279	= { FOLLOW_IMPLIES_TOK_in_thfDefinedPred1279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfDefinedPred1299  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfDefinedPred1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfDefinedPred1299	= { FOLLOW_RPAREN_TOK_in_thfDefinedPred1299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_95_in_definedFun1318  */
static	ANTLR3_BITWORD FOLLOW_95_in_definedFun1318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_95_in_definedFun1318	= { FOLLOW_95_in_definedFun1318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_89_in_definedFun1330  */
static	ANTLR3_BITWORD FOLLOW_89_in_definedFun1330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_89_in_definedFun1330	= { FOLLOW_89_in_definedFun1330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_definedFun1342  */
static	ANTLR3_BITWORD FOLLOW_64_in_definedFun1342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_definedFun1342	= { FOLLOW_64_in_definedFun1342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_definedFun1354  */
static	ANTLR3_BITWORD FOLLOW_80_in_definedFun1354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_80_in_definedFun1354	= { FOLLOW_80_in_definedFun1354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_definedFun1366  */
static	ANTLR3_BITWORD FOLLOW_81_in_definedFun1366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_81_in_definedFun1366	= { FOLLOW_81_in_definedFun1366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_definedFun1378  */
static	ANTLR3_BITWORD FOLLOW_71_in_definedFun1378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_71_in_definedFun1378	= { FOLLOW_71_in_definedFun1378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_definedFun1392  */
static	ANTLR3_BITWORD FOLLOW_82_in_definedFun1392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_82_in_definedFun1392	= { FOLLOW_82_in_definedFun1392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_85_in_definedFun1402  */
static	ANTLR3_BITWORD FOLLOW_85_in_definedFun1402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_85_in_definedFun1402	= { FOLLOW_85_in_definedFun1402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_definedFun1424  */
static	ANTLR3_BITWORD FOLLOW_84_in_definedFun1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_84_in_definedFun1424	= { FOLLOW_84_in_definedFun1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_87_in_definedFun1434  */
static	ANTLR3_BITWORD FOLLOW_87_in_definedFun1434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_87_in_definedFun1434	= { FOLLOW_87_in_definedFun1434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_83_in_definedFun1456  */
static	ANTLR3_BITWORD FOLLOW_83_in_definedFun1456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_83_in_definedFun1456	= { FOLLOW_83_in_definedFun1456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_86_in_definedFun1466  */
static	ANTLR3_BITWORD FOLLOW_86_in_definedFun1466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_86_in_definedFun1466	= { FOLLOW_86_in_definedFun1466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_definedFun1486  */
static	ANTLR3_BITWORD FOLLOW_66_in_definedFun1486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_66_in_definedFun1486	= { FOLLOW_66_in_definedFun1486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_definedFun1498  */
static	ANTLR3_BITWORD FOLLOW_63_in_definedFun1498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_definedFun1498	= { FOLLOW_63_in_definedFun1498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_94_in_definedFun1510  */
static	ANTLR3_BITWORD FOLLOW_94_in_definedFun1510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_94_in_definedFun1510	= { FOLLOW_94_in_definedFun1510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_88_in_definedFun1522  */
static	ANTLR3_BITWORD FOLLOW_88_in_definedFun1522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_88_in_definedFun1522	= { FOLLOW_88_in_definedFun1522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_91_in_definedFun1534  */
static	ANTLR3_BITWORD FOLLOW_91_in_definedFun1534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_91_in_definedFun1534	= { FOLLOW_91_in_definedFun1534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_92_in_definedFun1546  */
static	ANTLR3_BITWORD FOLLOW_92_in_definedFun1546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_92_in_definedFun1546	= { FOLLOW_92_in_definedFun1546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_93_in_definedFun1558  */
static	ANTLR3_BITWORD FOLLOW_93_in_definedFun1558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_93_in_definedFun1558	= { FOLLOW_93_in_definedFun1558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_equalOp1581  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_equalOp1581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_equalOp1581	= { FOLLOW_EQUAL_TOK_in_equalOp1581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISEQUAL_TOK_in_equalOp1592  */
static	ANTLR3_BITWORD FOLLOW_DISEQUAL_TOK_in_equalOp1592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISEQUAL_TOK_in_equalOp1592	= { FOLLOW_DISEQUAL_TOK_in_equalOp1592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionTerm_in_term1608  */
static	ANTLR3_BITWORD FOLLOW_functionTerm_in_term1608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionTerm_in_term1608	= { FOLLOW_functionTerm_in_term1608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalTerm_in_term1615  */
static	ANTLR3_BITWORD FOLLOW_conditionalTerm_in_term1615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalTerm_in_term1615	= { FOLLOW_conditionalTerm_in_term1615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleTerm_in_term1622  */
static	ANTLR3_BITWORD FOLLOW_simpleTerm_in_term1622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleTerm_in_term1622	= { FOLLOW_simpleTerm_in_term1622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_letTerm_in_term1629  */
static	ANTLR3_BITWORD FOLLOW_letTerm_in_term1629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_letTerm_in_term1629	= { FOLLOW_letTerm_in_term1629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_letTerm1649  */
static	ANTLR3_BITWORD FOLLOW_77_in_letTerm1649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_77_in_letTerm1649	= { FOLLOW_77_in_letTerm1649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_letTerm1651  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_letTerm1651_bits[]	= { ANTLR3_UINT64_LIT(0xAD22014E37020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_letTerm1651	= { FOLLOW_LPAREN_TOK_in_letTerm1651_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetFormulaDefn_in_letTerm1659  */
static	ANTLR3_BITWORD FOLLOW_tffLetFormulaDefn_in_letTerm1659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetFormulaDefn_in_letTerm1659	= { FOLLOW_tffLetFormulaDefn_in_letTerm1659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_letTerm1662  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_letTerm1662_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_letTerm1662	= { FOLLOW_COMMA_TOK_in_letTerm1662_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_letTerm1668  */
static	ANTLR3_BITWORD FOLLOW_term_in_letTerm1668_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_letTerm1668	= { FOLLOW_term_in_letTerm1668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_letTerm1681  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_letTerm1681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_letTerm1681	= { FOLLOW_RPAREN_TOK_in_letTerm1681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_79_in_letTerm1687  */
static	ANTLR3_BITWORD FOLLOW_79_in_letTerm1687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_79_in_letTerm1687	= { FOLLOW_79_in_letTerm1687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_letTerm1689  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_letTerm1689_bits[]	= { ANTLR3_UINT64_LIT(0xA922004E26020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_letTerm1689	= { FOLLOW_LPAREN_TOK_in_letTerm1689_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetTermDefn_in_letTerm1697  */
static	ANTLR3_BITWORD FOLLOW_tffLetTermDefn_in_letTerm1697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetTermDefn_in_letTerm1697	= { FOLLOW_tffLetTermDefn_in_letTerm1697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_letTerm1700  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_letTerm1700_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_letTerm1700	= { FOLLOW_COMMA_TOK_in_letTerm1700_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_letTerm1706  */
static	ANTLR3_BITWORD FOLLOW_term_in_letTerm1706_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_letTerm1706	= { FOLLOW_term_in_letTerm1706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_letTerm1719  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_letTerm1719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_letTerm1719	= { FOLLOW_RPAREN_TOK_in_letTerm1719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variable_in_simpleTerm1735  */
static	ANTLR3_BITWORD FOLLOW_variable_in_simpleTerm1735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variable_in_simpleTerm1735	= { FOLLOW_variable_in_simpleTerm1735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_simpleTerm1742  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_simpleTerm1742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_simpleTerm1742	= { FOLLOW_NUMBER_in_simpleTerm1742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_OBJECT_in_simpleTerm1750  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_OBJECT_in_simpleTerm1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_OBJECT_in_simpleTerm1750	= { FOLLOW_DISTINCT_OBJECT_in_simpleTerm1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_thfSimpleTerm1768  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_thfSimpleTerm1768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_thfSimpleTerm1768	= { FOLLOW_NUMBER_in_thfSimpleTerm1768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_OBJECT_in_thfSimpleTerm1776  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_OBJECT_in_thfSimpleTerm1776_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_OBJECT_in_thfSimpleTerm1776	= { FOLLOW_DISTINCT_OBJECT_in_thfSimpleTerm1776_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_plainTerm_in_functionTerm1801  */
static	ANTLR3_BITWORD FOLLOW_plainTerm_in_functionTerm1801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_plainTerm_in_functionTerm1801	= { FOLLOW_plainTerm_in_functionTerm1801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedFun_in_functionTerm1808  */
static	ANTLR3_BITWORD FOLLOW_definedFun_in_functionTerm1808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedFun_in_functionTerm1808	= { FOLLOW_definedFun_in_functionTerm1808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_functionTerm1811  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_functionTerm1811_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_functionTerm1811	= { FOLLOW_LPAREN_TOK_in_functionTerm1811_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_functionTerm1813  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_functionTerm1813_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_functionTerm1813	= { FOLLOW_arguments_in_functionTerm1813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_functionTerm1816  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_functionTerm1816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_functionTerm1816	= { FOLLOW_RPAREN_TOK_in_functionTerm1816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_conditionalTerm1841  */
static	ANTLR3_BITWORD FOLLOW_73_in_conditionalTerm1841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_73_in_conditionalTerm1841	= { FOLLOW_73_in_conditionalTerm1841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_conditionalTerm1843  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_conditionalTerm1843_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_conditionalTerm1843	= { FOLLOW_LPAREN_TOK_in_conditionalTerm1843_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_conditionalTerm1845  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_conditionalTerm1845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_conditionalTerm1845	= { FOLLOW_tffLogicFormula_in_conditionalTerm1845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_conditionalTerm1848  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_conditionalTerm1848_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_conditionalTerm1848	= { FOLLOW_COMMA_TOK_in_conditionalTerm1848_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_conditionalTerm1850  */
static	ANTLR3_BITWORD FOLLOW_term_in_conditionalTerm1850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_conditionalTerm1850	= { FOLLOW_term_in_conditionalTerm1850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_conditionalTerm1853  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_conditionalTerm1853_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_conditionalTerm1853	= { FOLLOW_COMMA_TOK_in_conditionalTerm1853_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_conditionalTerm1855  */
static	ANTLR3_BITWORD FOLLOW_term_in_conditionalTerm1855_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_conditionalTerm1855	= { FOLLOW_term_in_conditionalTerm1855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_conditionalTerm1858  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_conditionalTerm1858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_conditionalTerm1858	= { FOLLOW_RPAREN_TOK_in_conditionalTerm1858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicWord_in_plainTerm1883  */
static	ANTLR3_BITWORD FOLLOW_atomicWord_in_plainTerm1883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicWord_in_plainTerm1883	= { FOLLOW_atomicWord_in_plainTerm1883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_plainTerm1887  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_plainTerm1887_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_plainTerm1887	= { FOLLOW_LPAREN_TOK_in_plainTerm1887_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_plainTerm1889  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_plainTerm1889_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_plainTerm1889	= { FOLLOW_arguments_in_plainTerm1889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_plainTerm1892  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_plainTerm1892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_plainTerm1892	= { FOLLOW_RPAREN_TOK_in_plainTerm1892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_arguments1921  */
static	ANTLR3_BITWORD FOLLOW_term_in_arguments1921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_arguments1921	= { FOLLOW_term_in_arguments1921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_arguments1928  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_arguments1928_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_arguments1928	= { FOLLOW_COMMA_TOK_in_arguments1928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_arguments1930  */
static	ANTLR3_BITWORD FOLLOW_term_in_arguments1930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_arguments1930	= { FOLLOW_term_in_arguments1930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPPER_WORD_in_variable1950  */
static	ANTLR3_BITWORD FOLLOW_UPPER_WORD_in_variable1950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UPPER_WORD_in_variable1950	= { FOLLOW_UPPER_WORD_in_variable1950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofLogicFormula_in_fofFormula1974  */
static	ANTLR3_BITWORD FOLLOW_fofLogicFormula_in_fofFormula1974_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fofLogicFormula_in_fofFormula1974	= { FOLLOW_fofLogicFormula_in_fofFormula1974_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofLogicFormula1992  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofLogicFormula1992_bits[]	= { ANTLR3_UINT64_LIT(0x0000790018000022) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofLogicFormula1992	= { FOLLOW_fofUnitaryFormula_in_fofLogicFormula1992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofBinaryNonAssoc_in_fofLogicFormula2010  */
static	ANTLR3_BITWORD FOLLOW_fofBinaryNonAssoc_in_fofLogicFormula2010_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_fofBinaryNonAssoc_in_fofLogicFormula2010	= { FOLLOW_fofBinaryNonAssoc_in_fofLogicFormula2010_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofLogicFormula2013  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofLogicFormula2013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofLogicFormula2013	= { FOLLOW_fofUnitaryFormula_in_fofLogicFormula2013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_fofLogicFormula2061  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_fofLogicFormula2061_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_fofLogicFormula2061	= { FOLLOW_AND_TOK_in_fofLogicFormula2061_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofLogicFormula2063  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofLogicFormula2063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofLogicFormula2063	= { FOLLOW_fofUnitaryFormula_in_fofLogicFormula2063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_fofLogicFormula2116  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_fofLogicFormula2116_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_fofLogicFormula2116	= { FOLLOW_OR_TOK_in_fofLogicFormula2116_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofLogicFormula2118  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofLogicFormula2118_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofLogicFormula2118	= { FOLLOW_fofUnitaryFormula_in_fofLogicFormula2118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormula_in_fofUnitaryFormula2168  */
static	ANTLR3_BITWORD FOLLOW_atomicFormula_in_fofUnitaryFormula2168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicFormula_in_fofUnitaryFormula2168	= { FOLLOW_atomicFormula_in_fofUnitaryFormula2168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_fofUnitaryFormula2175  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_fofUnitaryFormula2175_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_fofUnitaryFormula2175	= { FOLLOW_LPAREN_TOK_in_fofUnitaryFormula2175_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofLogicFormula_in_fofUnitaryFormula2177  */
static	ANTLR3_BITWORD FOLLOW_fofLogicFormula_in_fofUnitaryFormula2177_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_fofLogicFormula_in_fofUnitaryFormula2177	= { FOLLOW_fofLogicFormula_in_fofUnitaryFormula2177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_fofUnitaryFormula2180  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_fofUnitaryFormula2180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_fofUnitaryFormula2180	= { FOLLOW_RPAREN_TOK_in_fofUnitaryFormula2180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_fofUnitaryFormula2186  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_fofUnitaryFormula2186_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_fofUnitaryFormula2186	= { FOLLOW_NOT_TOK_in_fofUnitaryFormula2186_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2188  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2188	= { FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_folQuantifier_in_fofUnitaryFormula2202  */
static	ANTLR3_BITWORD FOLLOW_folQuantifier_in_fofUnitaryFormula2202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_folQuantifier_in_fofUnitaryFormula2202	= { FOLLOW_folQuantifier_in_fofUnitaryFormula2202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_fofUnitaryFormula2205  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_fofUnitaryFormula2205_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_fofUnitaryFormula2205	= { FOLLOW_LBRACK_TOK_in_fofUnitaryFormula2205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bindvariable_in_fofUnitaryFormula2215  */
static	ANTLR3_BITWORD FOLLOW_bindvariable_in_fofUnitaryFormula2215_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_bindvariable_in_fofUnitaryFormula2215	= { FOLLOW_bindvariable_in_fofUnitaryFormula2215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_fofUnitaryFormula2228  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_fofUnitaryFormula2228_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_fofUnitaryFormula2228	= { FOLLOW_COMMA_TOK_in_fofUnitaryFormula2228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bindvariable_in_fofUnitaryFormula2230  */
static	ANTLR3_BITWORD FOLLOW_bindvariable_in_fofUnitaryFormula2230_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_bindvariable_in_fofUnitaryFormula2230	= { FOLLOW_bindvariable_in_fofUnitaryFormula2230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_fofUnitaryFormula2240  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_fofUnitaryFormula2240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_fofUnitaryFormula2240	= { FOLLOW_RBRACK_TOK_in_fofUnitaryFormula2240_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_fofUnitaryFormula2246  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_fofUnitaryFormula2246_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_fofUnitaryFormula2246	= { FOLLOW_COLON_TOK_in_fofUnitaryFormula2246_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2248  */
static	ANTLR3_BITWORD FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2248	= { FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPPER_WORD_in_bindvariable2269  */
static	ANTLR3_BITWORD FOLLOW_UPPER_WORD_in_bindvariable2269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UPPER_WORD_in_bindvariable2269	= { FOLLOW_UPPER_WORD_in_bindvariable2269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IFF_TOK_in_fofBinaryNonAssoc2289  */
static	ANTLR3_BITWORD FOLLOW_IFF_TOK_in_fofBinaryNonAssoc2289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IFF_TOK_in_fofBinaryNonAssoc2289	= { FOLLOW_IFF_TOK_in_fofBinaryNonAssoc2289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVIFF_TOK_in_fofBinaryNonAssoc2302  */
static	ANTLR3_BITWORD FOLLOW_REVIFF_TOK_in_fofBinaryNonAssoc2302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVIFF_TOK_in_fofBinaryNonAssoc2302	= { FOLLOW_REVIFF_TOK_in_fofBinaryNonAssoc2302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVOR_TOK_in_fofBinaryNonAssoc2312  */
static	ANTLR3_BITWORD FOLLOW_REVOR_TOK_in_fofBinaryNonAssoc2312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVOR_TOK_in_fofBinaryNonAssoc2312	= { FOLLOW_REVOR_TOK_in_fofBinaryNonAssoc2312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVAND_TOK_in_fofBinaryNonAssoc2323  */
static	ANTLR3_BITWORD FOLLOW_REVAND_TOK_in_fofBinaryNonAssoc2323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVAND_TOK_in_fofBinaryNonAssoc2323	= { FOLLOW_REVAND_TOK_in_fofBinaryNonAssoc2323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_fofBinaryNonAssoc2333  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_fofBinaryNonAssoc2333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_fofBinaryNonAssoc2333	= { FOLLOW_IMPLIES_TOK_in_fofBinaryNonAssoc2333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVIMPLIES_TOK_in_fofBinaryNonAssoc2344  */
static	ANTLR3_BITWORD FOLLOW_REVIMPLIES_TOK_in_fofBinaryNonAssoc2344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVIMPLIES_TOK_in_fofBinaryNonAssoc2344	= { FOLLOW_REVIMPLIES_TOK_in_fofBinaryNonAssoc2344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_folQuantifier2360  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_folQuantifier2360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_folQuantifier2360	= { FOLLOW_FORALL_TOK_in_folQuantifier2360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_folQuantifier2368  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_folQuantifier2368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_folQuantifier2368	= { FOLLOW_EXISTS_TOK_in_folQuantifier2368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_thfQuantifier2389  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_thfQuantifier2389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_thfQuantifier2389	= { FOLLOW_FORALL_TOK_in_thfQuantifier2389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_thfQuantifier2397  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_thfQuantifier2397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_thfQuantifier2397	= { FOLLOW_EXISTS_TOK_in_thfQuantifier2397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAMBDA_TOK_in_thfQuantifier2405  */
static	ANTLR3_BITWORD FOLLOW_LAMBDA_TOK_in_thfQuantifier2405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LAMBDA_TOK_in_thfQuantifier2405	= { FOLLOW_LAMBDA_TOK_in_thfQuantifier2405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHOICE_TOK_in_thfQuantifier2413  */
static	ANTLR3_BITWORD FOLLOW_CHOICE_TOK_in_thfQuantifier2413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHOICE_TOK_in_thfQuantifier2413	= { FOLLOW_CHOICE_TOK_in_thfQuantifier2413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEF_DESC_TOK_in_thfQuantifier2425  */
static	ANTLR3_BITWORD FOLLOW_DEF_DESC_TOK_in_thfQuantifier2425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEF_DESC_TOK_in_thfQuantifier2425	= { FOLLOW_DEF_DESC_TOK_in_thfQuantifier2425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_thfQuantifier2437  */
static	ANTLR3_BITWORD FOLLOW_set_in_thfQuantifier2437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_thfQuantifier2437	= { FOLLOW_set_in_thfQuantifier2437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfAtomTyping2469  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfAtomTyping2469_bits[]	= { ANTLR3_UINT64_LIT(0x0922004E22000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfAtomTyping2469	= { FOLLOW_LPAREN_TOK_in_thfAtomTyping2469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfAtomTyping_in_thfAtomTyping2471  */
static	ANTLR3_BITWORD FOLLOW_thfAtomTyping_in_thfAtomTyping2471_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_thfAtomTyping_in_thfAtomTyping2471	= { FOLLOW_thfAtomTyping_in_thfAtomTyping2471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfAtomTyping2474  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfAtomTyping2474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfAtomTyping2474	= { FOLLOW_RPAREN_TOK_in_thfAtomTyping2474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_thfAtomTyping2480  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_thfAtomTyping2480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_thfAtomTyping2480	= { FOLLOW_nameN_in_thfAtomTyping2480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_thfAtomTyping2483  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_thfAtomTyping2483_bits[]	= { ANTLR3_UINT64_LIT(0x0922000EA2004200), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_thfAtomTyping2483	= { FOLLOW_COLON_TOK_in_thfAtomTyping2483_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_90_in_thfAtomTyping2491  */
static	ANTLR3_BITWORD FOLLOW_90_in_thfAtomTyping2491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_90_in_thfAtomTyping2491	= { FOLLOW_90_in_thfAtomTyping2491_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseThfType_in_thfAtomTyping2507  */
static	ANTLR3_BITWORD FOLLOW_parseThfType_in_thfAtomTyping2507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parseThfType_in_thfAtomTyping2507	= { FOLLOW_parseThfType_in_thfAtomTyping2507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2547  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2547_bits[]	= { ANTLR3_UINT64_LIT(0x0000790018210062) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2547	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equalOp_in_thfLogicFormula2563  */
static	ANTLR3_BITWORD FOLLOW_equalOp_in_thfLogicFormula2563_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_equalOp_in_thfLogicFormula2563	= { FOLLOW_equalOp_in_thfLogicFormula2563_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2572  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2572	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofBinaryNonAssoc_in_thfLogicFormula2596  */
static	ANTLR3_BITWORD FOLLOW_fofBinaryNonAssoc_in_thfLogicFormula2596_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_fofBinaryNonAssoc_in_thfLogicFormula2596	= { FOLLOW_fofBinaryNonAssoc_in_thfLogicFormula2596_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2599  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2599	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_thfLogicFormula2645  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_thfLogicFormula2645_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_thfLogicFormula2645	= { FOLLOW_AND_TOK_in_thfLogicFormula2645_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2647  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2647	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_thfLogicFormula2726  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_thfLogicFormula2726_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_thfLogicFormula2726	= { FOLLOW_OR_TOK_in_thfLogicFormula2726_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2728  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2728_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2728	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_APP_TOK_in_thfLogicFormula2830  */
static	ANTLR3_BITWORD FOLLOW_APP_TOK_in_thfLogicFormula2830_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006EE7428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_APP_TOK_in_thfLogicFormula2830	= { FOLLOW_APP_TOK_in_thfLogicFormula2830_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfLogicFormula2851  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfLogicFormula2851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfLogicFormula2851	= { FOLLOW_thfUnitaryFormula_in_thfLogicFormula2851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_thfLogicFormula2876  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_thfLogicFormula2876_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_thfLogicFormula2876	= { FOLLOW_LBRACK_TOK_in_thfLogicFormula2876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfTupleForm_in_thfLogicFormula2902  */
static	ANTLR3_BITWORD FOLLOW_thfTupleForm_in_thfLogicFormula2902_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_thfTupleForm_in_thfLogicFormula2902	= { FOLLOW_thfTupleForm_in_thfLogicFormula2902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_thfLogicFormula2916  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_thfLogicFormula2916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_thfLogicFormula2916	= { FOLLOW_RBRACK_TOK_in_thfLogicFormula2916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfTupleForm2969  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfTupleForm2969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfTupleForm2969	= { FOLLOW_thfUnitaryFormula_in_thfTupleForm2969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_thfTupleForm2982  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_thfTupleForm2982_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_thfTupleForm2982	= { FOLLOW_COMMA_TOK_in_thfTupleForm2982_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfTupleForm2984  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfTupleForm2984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfTupleForm2984	= { FOLLOW_thfUnitaryFormula_in_thfTupleForm2984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variable_in_thfUnitaryFormula3015  */
static	ANTLR3_BITWORD FOLLOW_variable_in_thfUnitaryFormula3015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variable_in_thfUnitaryFormula3015	= { FOLLOW_variable_in_thfUnitaryFormula3015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfAtomicFormula_in_thfUnitaryFormula3022  */
static	ANTLR3_BITWORD FOLLOW_thfAtomicFormula_in_thfUnitaryFormula3022_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfAtomicFormula_in_thfUnitaryFormula3022	= { FOLLOW_thfAtomicFormula_in_thfUnitaryFormula3022_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfUnitaryFormula3029  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfUnitaryFormula3029_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfUnitaryFormula3029	= { FOLLOW_LPAREN_TOK_in_thfUnitaryFormula3029_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfLogicFormula_in_thfUnitaryFormula3035  */
static	ANTLR3_BITWORD FOLLOW_thfLogicFormula_in_thfUnitaryFormula3035_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_thfLogicFormula_in_thfUnitaryFormula3035	= { FOLLOW_thfLogicFormula_in_thfUnitaryFormula3035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfUnitaryFormula3042  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfUnitaryFormula3042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfUnitaryFormula3042	= { FOLLOW_RPAREN_TOK_in_thfUnitaryFormula3042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_thfUnitaryFormula3048  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_thfUnitaryFormula3048_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428302), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_thfUnitaryFormula3048	= { FOLLOW_NOT_TOK_in_thfUnitaryFormula3048_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3067  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3067	= { FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfQuantifier_in_thfUnitaryFormula3093  */
static	ANTLR3_BITWORD FOLLOW_thfQuantifier_in_thfUnitaryFormula3093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_thfQuantifier_in_thfUnitaryFormula3093	= { FOLLOW_thfQuantifier_in_thfUnitaryFormula3093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_thfUnitaryFormula3100  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_thfUnitaryFormula3100_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_thfUnitaryFormula3100	= { FOLLOW_LBRACK_TOK_in_thfUnitaryFormula3100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfBindVariable_in_thfUnitaryFormula3108  */
static	ANTLR3_BITWORD FOLLOW_thfBindVariable_in_thfUnitaryFormula3108_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_thfBindVariable_in_thfUnitaryFormula3108	= { FOLLOW_thfBindVariable_in_thfUnitaryFormula3108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_thfUnitaryFormula3123  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_thfUnitaryFormula3123_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_thfUnitaryFormula3123	= { FOLLOW_COMMA_TOK_in_thfUnitaryFormula3123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfBindVariable_in_thfUnitaryFormula3125  */
static	ANTLR3_BITWORD FOLLOW_thfBindVariable_in_thfUnitaryFormula3125_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_thfBindVariable_in_thfUnitaryFormula3125	= { FOLLOW_thfBindVariable_in_thfUnitaryFormula3125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_thfUnitaryFormula3147  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_thfUnitaryFormula3147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_thfUnitaryFormula3147	= { FOLLOW_RBRACK_TOK_in_thfUnitaryFormula3147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_thfUnitaryFormula3149  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_thfUnitaryFormula3149_bits[]	= { ANTLR3_UINT64_LIT(0xADE2006E67428300), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_thfUnitaryFormula3149	= { FOLLOW_COLON_TOK_in_thfUnitaryFormula3149_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3155  */
static	ANTLR3_BITWORD FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3155	= { FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_tffFormula3178  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_tffFormula3178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_tffFormula3178	= { FOLLOW_tffLogicFormula_in_tffFormula3178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffTypedAtom3195  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffTypedAtom3195_bits[]	= { ANTLR3_UINT64_LIT(0x0922004E22000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffTypedAtom3195	= { FOLLOW_LPAREN_TOK_in_tffTypedAtom3195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffTypedAtom_in_tffTypedAtom3197  */
static	ANTLR3_BITWORD FOLLOW_tffTypedAtom_in_tffTypedAtom3197_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffTypedAtom_in_tffTypedAtom3197	= { FOLLOW_tffTypedAtom_in_tffTypedAtom3197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffTypedAtom3200  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffTypedAtom3200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffTypedAtom3200	= { FOLLOW_RPAREN_TOK_in_tffTypedAtom3200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameN_in_tffTypedAtom3206  */
static	ANTLR3_BITWORD FOLLOW_nameN_in_tffTypedAtom3206_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_nameN_in_tffTypedAtom3206	= { FOLLOW_nameN_in_tffTypedAtom3206_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_tffTypedAtom3209  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_tffTypedAtom3209_bits[]	= { ANTLR3_UINT64_LIT(0x0922000E22004200), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_tffTypedAtom3209	= { FOLLOW_COLON_TOK_in_tffTypedAtom3209_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_90_in_tffTypedAtom3217  */
static	ANTLR3_BITWORD FOLLOW_90_in_tffTypedAtom3217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_90_in_tffTypedAtom3217	= { FOLLOW_90_in_tffTypedAtom3217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseType_in_tffTypedAtom3233  */
static	ANTLR3_BITWORD FOLLOW_parseType_in_tffTypedAtom3233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parseType_in_tffTypedAtom3233	= { FOLLOW_parseType_in_tffTypedAtom3233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffLogicFormula3267  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffLogicFormula3267_bits[]	= { ANTLR3_UINT64_LIT(0x0000790018000022) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffLogicFormula3267	= { FOLLOW_tffUnitaryFormula_in_tffLogicFormula3267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fofBinaryNonAssoc_in_tffLogicFormula3285  */
static	ANTLR3_BITWORD FOLLOW_fofBinaryNonAssoc_in_tffLogicFormula3285_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_fofBinaryNonAssoc_in_tffLogicFormula3285	= { FOLLOW_fofBinaryNonAssoc_in_tffLogicFormula3285_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffLogicFormula3288  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffLogicFormula3288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffLogicFormula3288	= { FOLLOW_tffUnitaryFormula_in_tffLogicFormula3288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_tffLogicFormula3336  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_tffLogicFormula3336_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_tffLogicFormula3336	= { FOLLOW_AND_TOK_in_tffLogicFormula3336_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffLogicFormula3338  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffLogicFormula3338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffLogicFormula3338	= { FOLLOW_tffUnitaryFormula_in_tffLogicFormula3338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_tffLogicFormula3391  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_tffLogicFormula3391_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_tffLogicFormula3391	= { FOLLOW_OR_TOK_in_tffLogicFormula3391_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffLogicFormula3393  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffLogicFormula3393_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffLogicFormula3393	= { FOLLOW_tffUnitaryFormula_in_tffLogicFormula3393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormula_in_tffUnitaryFormula3443  */
static	ANTLR3_BITWORD FOLLOW_atomicFormula_in_tffUnitaryFormula3443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicFormula_in_tffUnitaryFormula3443	= { FOLLOW_atomicFormula_in_tffUnitaryFormula3443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3450  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3450_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3450	= { FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3450_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_tffUnitaryFormula3452  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_tffUnitaryFormula3452_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_tffUnitaryFormula3452	= { FOLLOW_tffLogicFormula_in_tffUnitaryFormula3452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3455  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3455	= { FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_tffUnitaryFormula3461  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_tffUnitaryFormula3461_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_tffUnitaryFormula3461	= { FOLLOW_NOT_TOK_in_tffUnitaryFormula3461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3463  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3463_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3463	= { FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_folQuantifier_in_tffUnitaryFormula3477  */
static	ANTLR3_BITWORD FOLLOW_folQuantifier_in_tffUnitaryFormula3477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_folQuantifier_in_tffUnitaryFormula3477	= { FOLLOW_folQuantifier_in_tffUnitaryFormula3477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_tffUnitaryFormula3480  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_tffUnitaryFormula3480_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_tffUnitaryFormula3480	= { FOLLOW_LBRACK_TOK_in_tffUnitaryFormula3480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffbindvariable_in_tffUnitaryFormula3490  */
static	ANTLR3_BITWORD FOLLOW_tffbindvariable_in_tffUnitaryFormula3490_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffbindvariable_in_tffUnitaryFormula3490	= { FOLLOW_tffbindvariable_in_tffUnitaryFormula3490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffUnitaryFormula3503  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffUnitaryFormula3503_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffUnitaryFormula3503	= { FOLLOW_COMMA_TOK_in_tffUnitaryFormula3503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffbindvariable_in_tffUnitaryFormula3505  */
static	ANTLR3_BITWORD FOLLOW_tffbindvariable_in_tffUnitaryFormula3505_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffbindvariable_in_tffUnitaryFormula3505	= { FOLLOW_tffbindvariable_in_tffUnitaryFormula3505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_tffUnitaryFormula3515  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_tffUnitaryFormula3515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_tffUnitaryFormula3515	= { FOLLOW_RBRACK_TOK_in_tffUnitaryFormula3515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_tffUnitaryFormula3521  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_tffUnitaryFormula3521_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_tffUnitaryFormula3521	= { FOLLOW_COLON_TOK_in_tffUnitaryFormula3521_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3523  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3523	= { FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3523_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_tffUnitaryFormula3536  */
static	ANTLR3_BITWORD FOLLOW_72_in_tffUnitaryFormula3536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_tffUnitaryFormula3536	= { FOLLOW_72_in_tffUnitaryFormula3536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3538  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3538_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3538	= { FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3538_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_tffUnitaryFormula3540  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_tffUnitaryFormula3540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_tffUnitaryFormula3540	= { FOLLOW_tffLogicFormula_in_tffUnitaryFormula3540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffUnitaryFormula3543  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffUnitaryFormula3543_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffUnitaryFormula3543	= { FOLLOW_COMMA_TOK_in_tffUnitaryFormula3543_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_tffUnitaryFormula3545  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_tffUnitaryFormula3545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_tffUnitaryFormula3545	= { FOLLOW_tffLogicFormula_in_tffUnitaryFormula3545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffUnitaryFormula3548  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffUnitaryFormula3548_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffUnitaryFormula3548	= { FOLLOW_COMMA_TOK_in_tffUnitaryFormula3548_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLogicFormula_in_tffUnitaryFormula3550  */
static	ANTLR3_BITWORD FOLLOW_tffLogicFormula_in_tffUnitaryFormula3550_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLogicFormula_in_tffUnitaryFormula3550	= { FOLLOW_tffLogicFormula_in_tffUnitaryFormula3550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3553  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3553	= { FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3553_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_tffUnitaryFormula3565  */
static	ANTLR3_BITWORD FOLLOW_78_in_tffUnitaryFormula3565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_78_in_tffUnitaryFormula3565	= { FOLLOW_78_in_tffUnitaryFormula3565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3567  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3567_bits[]	= { ANTLR3_UINT64_LIT(0xA922004E26020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3567	= { FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3567_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetTermDefn_in_tffUnitaryFormula3575  */
static	ANTLR3_BITWORD FOLLOW_tffLetTermDefn_in_tffUnitaryFormula3575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetTermDefn_in_tffUnitaryFormula3575	= { FOLLOW_tffLetTermDefn_in_tffUnitaryFormula3575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffUnitaryFormula3578  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffUnitaryFormula3578_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffUnitaryFormula3578	= { FOLLOW_COMMA_TOK_in_tffUnitaryFormula3578_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffFormula_in_tffUnitaryFormula3584  */
static	ANTLR3_BITWORD FOLLOW_tffFormula_in_tffUnitaryFormula3584_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffFormula_in_tffUnitaryFormula3584	= { FOLLOW_tffFormula_in_tffUnitaryFormula3584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3597  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3597	= { FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_tffUnitaryFormula3603  */
static	ANTLR3_BITWORD FOLLOW_76_in_tffUnitaryFormula3603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_76_in_tffUnitaryFormula3603	= { FOLLOW_76_in_tffUnitaryFormula3603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3605  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3605_bits[]	= { ANTLR3_UINT64_LIT(0xAD22014E37020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3605	= { FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3605_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetFormulaDefn_in_tffUnitaryFormula3613  */
static	ANTLR3_BITWORD FOLLOW_tffLetFormulaDefn_in_tffUnitaryFormula3613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetFormulaDefn_in_tffUnitaryFormula3613	= { FOLLOW_tffLetFormulaDefn_in_tffUnitaryFormula3613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffUnitaryFormula3616  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffUnitaryFormula3616_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffUnitaryFormula3616	= { FOLLOW_COMMA_TOK_in_tffUnitaryFormula3616_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffFormula_in_tffUnitaryFormula3622  */
static	ANTLR3_BITWORD FOLLOW_tffFormula_in_tffUnitaryFormula3622_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffFormula_in_tffUnitaryFormula3622	= { FOLLOW_tffFormula_in_tffUnitaryFormula3622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3635  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3635	= { FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_tffLetTermDefn3655  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_tffLetTermDefn3655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_tffLetTermDefn3655	= { FOLLOW_FORALL_TOK_in_tffLetTermDefn3655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_tffLetTermDefn3657  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_tffLetTermDefn3657_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_tffLetTermDefn3657	= { FOLLOW_LBRACK_TOK_in_tffLetTermDefn3657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffVariableList_in_tffLetTermDefn3659  */
static	ANTLR3_BITWORD FOLLOW_tffVariableList_in_tffLetTermDefn3659_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffVariableList_in_tffLetTermDefn3659	= { FOLLOW_tffVariableList_in_tffLetTermDefn3659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_tffLetTermDefn3662  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_tffLetTermDefn3662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_tffLetTermDefn3662	= { FOLLOW_RBRACK_TOK_in_tffLetTermDefn3662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_tffLetTermDefn3664  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_tffLetTermDefn3664_bits[]	= { ANTLR3_UINT64_LIT(0xA922004E26020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_tffLetTermDefn3664	= { FOLLOW_COLON_TOK_in_tffLetTermDefn3664_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetTermBinding_in_tffLetTermDefn3672  */
static	ANTLR3_BITWORD FOLLOW_tffLetTermBinding_in_tffLetTermDefn3672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetTermBinding_in_tffLetTermDefn3672	= { FOLLOW_tffLetTermBinding_in_tffLetTermDefn3672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_tffLetTermBinding3687  */
static	ANTLR3_BITWORD FOLLOW_term_in_tffLetTermBinding3687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_tffLetTermBinding3687	= { FOLLOW_term_in_tffLetTermBinding3687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_tffLetTermBinding3690  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_tffLetTermBinding3690_bits[]	= { ANTLR3_UINT64_LIT(0xA922004622020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_tffLetTermBinding3690	= { FOLLOW_EQUAL_TOK_in_tffLetTermBinding3690_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_tffLetTermBinding3692  */
static	ANTLR3_BITWORD FOLLOW_term_in_tffLetTermBinding3692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_tffLetTermBinding3692	= { FOLLOW_term_in_tffLetTermBinding3692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffLetTermBinding3703  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffLetTermBinding3703_bits[]	= { ANTLR3_UINT64_LIT(0xA922004E22020200), ANTLR3_UINT64_LIT(0x00000000FBFFA285) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffLetTermBinding3703	= { FOLLOW_LPAREN_TOK_in_tffLetTermBinding3703_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetTermBinding_in_tffLetTermBinding3705  */
static	ANTLR3_BITWORD FOLLOW_tffLetTermBinding_in_tffLetTermBinding3705_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetTermBinding_in_tffLetTermBinding3705	= { FOLLOW_tffLetTermBinding_in_tffLetTermBinding3705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffLetTermBinding3708  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffLetTermBinding3708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffLetTermBinding3708	= { FOLLOW_RPAREN_TOK_in_tffLetTermBinding3708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_tffLetFormulaDefn3728  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_tffLetFormulaDefn3728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_tffLetFormulaDefn3728	= { FOLLOW_FORALL_TOK_in_tffLetFormulaDefn3728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_tffLetFormulaDefn3730  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_tffLetFormulaDefn3730_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_tffLetFormulaDefn3730	= { FOLLOW_LBRACK_TOK_in_tffLetFormulaDefn3730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffVariableList_in_tffLetFormulaDefn3732  */
static	ANTLR3_BITWORD FOLLOW_tffVariableList_in_tffLetFormulaDefn3732_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffVariableList_in_tffLetFormulaDefn3732	= { FOLLOW_tffVariableList_in_tffLetFormulaDefn3732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_tffLetFormulaDefn3735  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_tffLetFormulaDefn3735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_tffLetFormulaDefn3735	= { FOLLOW_RBRACK_TOK_in_tffLetFormulaDefn3735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_tffLetFormulaDefn3737  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_tffLetFormulaDefn3737_bits[]	= { ANTLR3_UINT64_LIT(0xAD22014E37020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_tffLetFormulaDefn3737	= { FOLLOW_COLON_TOK_in_tffLetFormulaDefn3737_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetFormulaBinding_in_tffLetFormulaDefn3745  */
static	ANTLR3_BITWORD FOLLOW_tffLetFormulaBinding_in_tffLetFormulaDefn3745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetFormulaBinding_in_tffLetFormulaDefn3745	= { FOLLOW_tffLetFormulaBinding_in_tffLetFormulaDefn3745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormula_in_tffLetFormulaBinding3761  */
static	ANTLR3_BITWORD FOLLOW_atomicFormula_in_tffLetFormulaBinding3761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicFormula_in_tffLetFormulaBinding3761	= { FOLLOW_atomicFormula_in_tffLetFormulaBinding3761_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IFF_TOK_in_tffLetFormulaBinding3764  */
static	ANTLR3_BITWORD FOLLOW_IFF_TOK_in_tffLetFormulaBinding3764_bits[]	= { ANTLR3_UINT64_LIT(0xAD22016E37420220), ANTLR3_UINT64_LIT(0x00000000FBFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IFF_TOK_in_tffLetFormulaBinding3764	= { FOLLOW_IFF_TOK_in_tffLetFormulaBinding3764_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffUnitaryFormula_in_tffLetFormulaBinding3766  */
static	ANTLR3_BITWORD FOLLOW_tffUnitaryFormula_in_tffLetFormulaBinding3766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tffUnitaryFormula_in_tffLetFormulaBinding3766	= { FOLLOW_tffUnitaryFormula_in_tffLetFormulaBinding3766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_tffLetFormulaBinding3777  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_tffLetFormulaBinding3777_bits[]	= { ANTLR3_UINT64_LIT(0xAD22014E33020220), ANTLR3_UINT64_LIT(0x00000000FBFFAEFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_tffLetFormulaBinding3777	= { FOLLOW_LPAREN_TOK_in_tffLetFormulaBinding3777_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffLetFormulaBinding_in_tffLetFormulaBinding3779  */
static	ANTLR3_BITWORD FOLLOW_tffLetFormulaBinding_in_tffLetFormulaBinding3779_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tffLetFormulaBinding_in_tffLetFormulaBinding3779	= { FOLLOW_tffLetFormulaBinding_in_tffLetFormulaBinding3779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_tffLetFormulaBinding3782  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_tffLetFormulaBinding3782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_tffLetFormulaBinding3782	= { FOLLOW_RPAREN_TOK_in_tffLetFormulaBinding3782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPPER_WORD_in_thfBindVariable3801  */
static	ANTLR3_BITWORD FOLLOW_UPPER_WORD_in_thfBindVariable3801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_UPPER_WORD_in_thfBindVariable3801	= { FOLLOW_UPPER_WORD_in_thfBindVariable3801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_thfBindVariable3815  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_thfBindVariable3815_bits[]	= { ANTLR3_UINT64_LIT(0x0922000EA2004200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_thfBindVariable3815	= { FOLLOW_COLON_TOK_in_thfBindVariable3815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseThfType_in_thfBindVariable3817  */
static	ANTLR3_BITWORD FOLLOW_parseThfType_in_thfBindVariable3817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parseThfType_in_thfBindVariable3817	= { FOLLOW_parseThfType_in_thfBindVariable3817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPPER_WORD_in_tffbindvariable3847  */
static	ANTLR3_BITWORD FOLLOW_UPPER_WORD_in_tffbindvariable3847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_UPPER_WORD_in_tffbindvariable3847	= { FOLLOW_UPPER_WORD_in_tffbindvariable3847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_tffbindvariable3855  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_tffbindvariable3855_bits[]	= { ANTLR3_UINT64_LIT(0x0922000E22004200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_tffbindvariable3855	= { FOLLOW_COLON_TOK_in_tffbindvariable3855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseType_in_tffbindvariable3857  */
static	ANTLR3_BITWORD FOLLOW_parseType_in_tffbindvariable3857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parseType_in_tffbindvariable3857	= { FOLLOW_parseType_in_tffbindvariable3857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffbindvariable_in_tffVariableList3888  */
static	ANTLR3_BITWORD FOLLOW_tffbindvariable_in_tffVariableList3888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_tffbindvariable_in_tffVariableList3888	= { FOLLOW_tffbindvariable_in_tffVariableList3888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_tffVariableList3899  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_tffVariableList3899_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_tffVariableList3899	= { FOLLOW_COMMA_TOK_in_tffVariableList3899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tffbindvariable_in_tffVariableList3901  */
static	ANTLR3_BITWORD FOLLOW_tffbindvariable_in_tffVariableList3901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_tffbindvariable_in_tffVariableList3901	= { FOLLOW_tffbindvariable_in_tffVariableList3901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfType_in_parseThfType3927  */
static	ANTLR3_BITWORD FOLLOW_thfType_in_parseThfType3927_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_thfType_in_parseThfType3927	= { FOLLOW_thfType_in_parseThfType3927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_parseThfType3943  */
static	ANTLR3_BITWORD FOLLOW_set_in_parseThfType3943_bits[]	= { ANTLR3_UINT64_LIT(0x0922000EA2004200) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_parseThfType3943	= { FOLLOW_set_in_parseThfType3943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_thfType_in_parseThfType3951  */
static	ANTLR3_BITWORD FOLLOW_thfType_in_parseThfType3951_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_thfType_in_parseThfType3951	= { FOLLOW_thfType_in_parseThfType3951_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_thfType3982  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_thfType3982_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_thfType3982	= { FOLLOW_simpleType_in_thfType3982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_thfType3991  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_thfType3991_bits[]	= { ANTLR3_UINT64_LIT(0x0922000EA2004200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_thfType3991	= { FOLLOW_LPAREN_TOK_in_thfType3991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseThfType_in_thfType3993  */
static	ANTLR3_BITWORD FOLLOW_parseThfType_in_thfType3993_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_parseThfType_in_thfType3993	= { FOLLOW_parseThfType_in_thfType3993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_thfType3996  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_thfType3996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_thfType3996	= { FOLLOW_RPAREN_TOK_in_thfType3996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_thfType4004  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_thfType4004_bits[]	= { ANTLR3_UINT64_LIT(0x0922000EA2004200) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_thfType4004	= { FOLLOW_LBRACK_TOK_in_thfType4004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parseThfType_in_thfType4008  */
static	ANTLR3_BITWORD FOLLOW_parseThfType_in_thfType4008_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_parseThfType_in_thfType4008	= { FOLLOW_parseThfType_in_thfType4008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_thfType4011  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_thfType4011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_thfType4011	= { FOLLOW_RBRACK_TOK_in_thfType4011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_parseType4030  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_parseType4030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_parseType4030	= { FOLLOW_simpleType_in_parseType4030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_parseType4039  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_parseType4039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_parseType4039	= { FOLLOW_simpleType_in_parseType4039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseType4050  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseType4050_bits[]	= { ANTLR3_UINT64_LIT(0x0922000622004200) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseType4050	= { FOLLOW_LPAREN_TOK_in_parseType4050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_parseType4052  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_parseType4052_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_parseType4052	= { FOLLOW_simpleType_in_parseType4052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TIMES_TOK_in_parseType4065  */
static	ANTLR3_BITWORD FOLLOW_TIMES_TOK_in_parseType4065_bits[]	= { ANTLR3_UINT64_LIT(0x0922000622004200) };
static  ANTLR3_BITSET_LIST FOLLOW_TIMES_TOK_in_parseType4065	= { FOLLOW_TIMES_TOK_in_parseType4065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_parseType4067  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_parseType4067_bits[]	= { ANTLR3_UINT64_LIT(0x0200800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_parseType4067	= { FOLLOW_simpleType_in_parseType4067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseType4081  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseType4081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseType4081	= { FOLLOW_RPAREN_TOK_in_parseType4081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARROW_TOK_in_parseType4093  */
static	ANTLR3_BITWORD FOLLOW_ARROW_TOK_in_parseType4093_bits[]	= { ANTLR3_UINT64_LIT(0x0922000622004200) };
static  ANTLR3_BITSET_LIST FOLLOW_ARROW_TOK_in_parseType4093	= { FOLLOW_ARROW_TOK_in_parseType4093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleType_in_parseType4095  */
static	ANTLR3_BITWORD FOLLOW_simpleType_in_parseType4095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleType_in_parseType4095	= { FOLLOW_simpleType_in_parseType4095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINED_SYMBOL_in_simpleType4122  */
static	ANTLR3_BITWORD FOLLOW_DEFINED_SYMBOL_in_simpleType4122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINED_SYMBOL_in_simpleType4122	= { FOLLOW_DEFINED_SYMBOL_in_simpleType4122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicWord_in_simpleType4134  */
static	ANTLR3_BITWORD FOLLOW_atomicWord_in_simpleType4134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicWord_in_simpleType4134	= { FOLLOW_atomicWord_in_simpleType4134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_anything4159  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_anything4159_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_anything4159	= { FOLLOW_LPAREN_TOK_in_anything4159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_anything4161  */
static	ANTLR3_BITWORD FOLLOW_anything_in_anything4161_bits[]	= { ANTLR3_UINT64_LIT(0x2F22FB7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_anything4161	= { FOLLOW_anything_in_anything4161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_anything4164  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_anything4164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_anything4164	= { FOLLOW_RPAREN_TOK_in_anything4164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACK_TOK_in_anything4170  */
static	ANTLR3_BITWORD FOLLOW_LBRACK_TOK_in_anything4170_bits[]	= { ANTLR3_UINT64_LIT(0x2F227F7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACK_TOK_in_anything4170	= { FOLLOW_LBRACK_TOK_in_anything4170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anything_in_anything4172  */
static	ANTLR3_BITWORD FOLLOW_anything_in_anything4172_bits[]	= { ANTLR3_UINT64_LIT(0x2F227F7EBF6B4E20) };
static  ANTLR3_BITSET_LIST FOLLOW_anything_in_anything4172	= { FOLLOW_anything_in_anything4172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACK_TOK_in_anything4175  */
static	ANTLR3_BITWORD FOLLOW_RBRACK_TOK_in_anything4175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACK_TOK_in_anything4175	= { FOLLOW_RBRACK_TOK_in_anything4175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_TOK_in_anything4181  */
static	ANTLR3_BITWORD FOLLOW_COMMA_TOK_in_anything4181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_TOK_in_anything4181	= { FOLLOW_COMMA_TOK_in_anything4181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_TOK_in_anything4187  */
static	ANTLR3_BITWORD FOLLOW_DOT_TOK_in_anything4187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_TOK_in_anything4187	= { FOLLOW_DOT_TOK_in_anything4187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_TOK_in_anything4193  */
static	ANTLR3_BITWORD FOLLOW_COLON_TOK_in_anything4193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_TOK_in_anything4193	= { FOLLOW_COLON_TOK_in_anything4193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_anything4199  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_anything4199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_anything4199	= { FOLLOW_OR_TOK_in_anything4199_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_anything4205  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_anything4205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_anything4205	= { FOLLOW_NOT_TOK_in_anything4205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_anything4211  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_anything4211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_anything4211	= { FOLLOW_FORALL_TOK_in_anything4211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_anything4217  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_anything4217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_anything4217	= { FOLLOW_EXISTS_TOK_in_anything4217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_anything4223  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_anything4223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_anything4223	= { FOLLOW_AND_TOK_in_anything4223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IFF_TOK_in_anything4229  */
static	ANTLR3_BITWORD FOLLOW_IFF_TOK_in_anything4229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IFF_TOK_in_anything4229	= { FOLLOW_IFF_TOK_in_anything4229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_anything4235  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_anything4235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_anything4235	= { FOLLOW_IMPLIES_TOK_in_anything4235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVIMPLIES_TOK_in_anything4241  */
static	ANTLR3_BITWORD FOLLOW_REVIMPLIES_TOK_in_anything4241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVIMPLIES_TOK_in_anything4241	= { FOLLOW_REVIMPLIES_TOK_in_anything4241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVIFF_TOK_in_anything4247  */
static	ANTLR3_BITWORD FOLLOW_REVIFF_TOK_in_anything4247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVIFF_TOK_in_anything4247	= { FOLLOW_REVIFF_TOK_in_anything4247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVOR_TOK_in_anything4253  */
static	ANTLR3_BITWORD FOLLOW_REVOR_TOK_in_anything4253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVOR_TOK_in_anything4253	= { FOLLOW_REVOR_TOK_in_anything4253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REVAND_TOK_in_anything4259  */
static	ANTLR3_BITWORD FOLLOW_REVAND_TOK_in_anything4259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REVAND_TOK_in_anything4259	= { FOLLOW_REVAND_TOK_in_anything4259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TIMES_TOK_in_anything4265  */
static	ANTLR3_BITWORD FOLLOW_TIMES_TOK_in_anything4265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TIMES_TOK_in_anything4265	= { FOLLOW_TIMES_TOK_in_anything4265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_TOK_in_anything4271  */
static	ANTLR3_BITWORD FOLLOW_PLUS_TOK_in_anything4271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_TOK_in_anything4271	= { FOLLOW_PLUS_TOK_in_anything4271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_anything4277  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_anything4277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_anything4277	= { FOLLOW_MINUS_TOK_in_anything4277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_anything4283  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_anything4283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_anything4283	= { FOLLOW_TRUE_TOK_in_anything4283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_anything4289  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_anything4289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_anything4289	= { FOLLOW_FALSE_TOK_in_anything4289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_anything4295  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_anything4295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_anything4295	= { FOLLOW_EQUAL_TOK_in_anything4295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISEQUAL_TOK_in_anything4301  */
static	ANTLR3_BITWORD FOLLOW_DISEQUAL_TOK_in_anything4301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISEQUAL_TOK_in_anything4301	= { FOLLOW_DISEQUAL_TOK_in_anything4301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CNF_TOK_in_anything4307  */
static	ANTLR3_BITWORD FOLLOW_CNF_TOK_in_anything4307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CNF_TOK_in_anything4307	= { FOLLOW_CNF_TOK_in_anything4307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOF_TOK_in_anything4313  */
static	ANTLR3_BITWORD FOLLOW_FOF_TOK_in_anything4313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FOF_TOK_in_anything4313	= { FOLLOW_FOF_TOK_in_anything4313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THF_TOK_in_anything4319  */
static	ANTLR3_BITWORD FOLLOW_THF_TOK_in_anything4319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THF_TOK_in_anything4319	= { FOLLOW_THF_TOK_in_anything4319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TFF_TOK_in_anything4325  */
static	ANTLR3_BITWORD FOLLOW_TFF_TOK_in_anything4325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TFF_TOK_in_anything4325	= { FOLLOW_TFF_TOK_in_anything4325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_anything4331  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_anything4331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_anything4331	= { FOLLOW_TYPE_TOK_in_anything4331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_anything4337  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_anything4337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_anything4337	= { FOLLOW_INCLUDE_TOK_in_anything4337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_OBJECT_in_anything4343  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_OBJECT_in_anything4343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_OBJECT_in_anything4343	= { FOLLOW_DISTINCT_OBJECT_in_anything4343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPPER_WORD_in_anything4349  */
static	ANTLR3_BITWORD FOLLOW_UPPER_WORD_in_anything4349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UPPER_WORD_in_anything4349	= { FOLLOW_UPPER_WORD_in_anything4349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_in_anything4355  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_in_anything4355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_in_anything4355	= { FOLLOW_LOWER_WORD_in_anything4355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_anything4361  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_anything4361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_anything4361	= { FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_anything4361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SINGLE_QUOTED_in_anything4367  */
static	ANTLR3_BITWORD FOLLOW_SINGLE_QUOTED_in_anything4367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SINGLE_QUOTED_in_anything4367	= { FOLLOW_SINGLE_QUOTED_in_anything4367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_anything4373  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_anything4373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_anything4373	= { FOLLOW_NUMBER_in_anything4373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINED_SYMBOL_in_anything4379  */
static	ANTLR3_BITWORD FOLLOW_DEFINED_SYMBOL_in_anything4379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINED_SYMBOL_in_anything4379	= { FOLLOW_DEFINED_SYMBOL_in_anything4379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_unquotedFileName5059  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_unquotedFileName5059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_unquotedFileName5059	= { FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_unquotedFileName5059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SINGLE_QUOTED_in_unquotedFileName5065  */
static	ANTLR3_BITWORD FOLLOW_SINGLE_QUOTED_in_unquotedFileName5065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SINGLE_QUOTED_in_unquotedFileName5065	= { FOLLOW_SINGLE_QUOTED_in_unquotedFileName5065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicWord_in_nameN5084  */
static	ANTLR3_BITWORD FOLLOW_atomicWord_in_nameN5084_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atomicWord_in_nameN5084	= { FOLLOW_atomicWord_in_nameN5084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_nameN5090  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_nameN5090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_nameN5090	= { FOLLOW_NUMBER_in_nameN5090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOF_TOK_in_atomicWord5106  */
static	ANTLR3_BITWORD FOLLOW_FOF_TOK_in_atomicWord5106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FOF_TOK_in_atomicWord5106	= { FOLLOW_FOF_TOK_in_atomicWord5106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CNF_TOK_in_atomicWord5117  */
static	ANTLR3_BITWORD FOLLOW_CNF_TOK_in_atomicWord5117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CNF_TOK_in_atomicWord5117	= { FOLLOW_CNF_TOK_in_atomicWord5117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THF_TOK_in_atomicWord5128  */
static	ANTLR3_BITWORD FOLLOW_THF_TOK_in_atomicWord5128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_THF_TOK_in_atomicWord5128	= { FOLLOW_THF_TOK_in_atomicWord5128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TFF_TOK_in_atomicWord5139  */
static	ANTLR3_BITWORD FOLLOW_TFF_TOK_in_atomicWord5139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TFF_TOK_in_atomicWord5139	= { FOLLOW_TFF_TOK_in_atomicWord5139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_TOK_in_atomicWord5150  */
static	ANTLR3_BITWORD FOLLOW_TYPE_TOK_in_atomicWord5150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_TOK_in_atomicWord5150	= { FOLLOW_TYPE_TOK_in_atomicWord5150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_atomicWord5160  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_atomicWord5160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_atomicWord5160	= { FOLLOW_INCLUDE_TOK_in_atomicWord5160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_in_atomicWord5167  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_in_atomicWord5167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_in_atomicWord5167	= { FOLLOW_LOWER_WORD_in_atomicWord5167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_atomicWord5175  */
static	ANTLR3_BITWORD FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_atomicWord5175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_atomicWord5175	= { FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_atomicWord5175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SINGLE_QUOTED_in_atomicWord5187  */
static	ANTLR3_BITWORD FOLLOW_SINGLE_QUOTED_in_atomicWord5187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SINGLE_QUOTED_in_atomicWord5187	= { FOLLOW_SINGLE_QUOTED_in_atomicWord5187_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:132:1: parseExpr returns [cvc5::parser::tptp::myExpr expr] : ( cnfFormula[expr] | EOF );
 */
static cvc5::parser::tptp::myExpr
parseExpr(pTptpParser ctx)
{
    cvc5::parser::tptp::myExpr expr;


    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:133:3: ( cnfFormula[expr] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case LPAREN_TOK:
            case NOT_TOK:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:133:5: cnfFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_cnfFormula_in_parseExpr112);
        	        cnfFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:134:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr119);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:141:1: parseCommand returns [std::unique_ptr<cvc5::parser::Command> cmd = nullptr] : ( CNF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK cnfFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK | FOF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK fofFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK | TFF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK tffTypedAtom[cmd] | formulaRole[fr] COMMA_TOK tffFormula[expr] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK | THF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK thfAtomTyping[cmd] | formulaRole[fr] COMMA_TOK thfLogicFormula[p] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK | INCLUDE_TOK LPAREN_TOK unquotedFileName[name] ( COMMA_TOK LBRACK_TOK nameN[inclSymbol] ( COMMA_TOK nameN[inclSymbol] )* RBRACK_TOK )? RPAREN_TOK DOT_TOK | EOF );
 */
static std::unique_ptr<cvc5::parser::Command>
parseCommand(pTptpParser ctx)
{
    std::unique_ptr<cvc5::parser::Command> cmd;



      cvc5::Term expr;
      TptpState::FormulaRole fr;
      std::string name, inclSymbol;
      ParseOp p;

    /* Initialize rule variables
     */
    cmd =  nullptr;


    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:148:3: ( CNF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK cnfFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK | FOF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK fofFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK | TFF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK tffTypedAtom[cmd] | formulaRole[fr] COMMA_TOK tffFormula[expr] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK | THF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK thfAtomTyping[cmd] | formulaRole[fr] COMMA_TOK thfLogicFormula[p] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK | INCLUDE_TOK LPAREN_TOK unquotedFileName[name] ( COMMA_TOK LBRACK_TOK nameN[inclSymbol] ( COMMA_TOK nameN[inclSymbol] )* RBRACK_TOK )? RPAREN_TOK DOT_TOK | EOF )

            ANTLR3_UINT32 alt14;

            alt14=6;

            switch ( LA(1) )
            {
            case CNF_TOK:
            	{
            		alt14=1;
            	}
                break;
            case FOF_TOK:
            	{
            		alt14=2;
            	}
                break;
            case TFF_TOK:
            	{
            		alt14=3;
            	}
                break;
            case THF_TOK:
            	{
            		alt14=4;
            	}
                break;
            case INCLUDE_TOK:
            	{
            		alt14=5;
            	}
                break;
            case EOF:
            	{
            		alt14=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:148:5: CNF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK cnfFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK
        	    {
        	         MATCHT(CNF_TOK, &FOLLOW_CNF_TOK_in_parseCommand143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand145);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand147);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand150);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_formulaRole_in_parseCommand152);
        	        formulaRole(ctx, fr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand155);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             PARSER_STATE->setCnf(true);
        	                PARSER_STATE->setFof(false);
        	                PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_cnfFormula_in_parseCommand165);
        	        cnfFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                std::vector<cvc5::Term> bvl = PARSER_STATE->getFreeVar();
        	                if(!bvl.empty()) {
        	                  expr = MK_TERM(cvc5::FORALL,MK_TERM(cvc5::VARIABLE_LIST,bvl),expr);
        	                };
        	              
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:159:5: ( COMMA_TOK ( anything )* )?
        	        {
        	            int alt3=2;
        	            switch ( LA(1) )
        	            {
        	                case COMMA_TOK:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:159:6: COMMA_TOK ( anything )*
        	        	    {
        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand177);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:159:16: ( anything )*

        	        	        for (;;)
        	        	        {
        	        	            int alt2=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case AND_TOK:
        	        	            case CNF_TOK:
        	        	            case COLON_TOK:
        	        	            case COMMA_TOK:
        	        	            case DEFINED_SYMBOL:
        	        	            case DISEQUAL_TOK:
        	        	            case DISTINCT_OBJECT:
        	        	            case DOT_TOK:
        	        	            case EQUAL_TOK:
        	        	            case EXISTS_TOK:
        	        	            case FALSE_TOK:
        	        	            case FOF_TOK:
        	        	            case FORALL_TOK:
        	        	            case IFF_TOK:
        	        	            case IMPLIES_TOK:
        	        	            case INCLUDE_TOK:
        	        	            case LBRACK_TOK:
        	        	            case LOWER_WORD:
        	        	            case LOWER_WORD_SINGLE_QUOTED:
        	        	            case LPAREN_TOK:
        	        	            case MINUS_TOK:
        	        	            case NOT_TOK:
        	        	            case NUMBER:
        	        	            case OR_TOK:
        	        	            case PLUS_TOK:
        	        	            case REVAND_TOK:
        	        	            case REVIFF_TOK:
        	        	            case REVIMPLIES_TOK:
        	        	            case REVOR_TOK:
        	        	            case SINGLE_QUOTED:
        	        	            case TFF_TOK:
        	        	            case THF_TOK:
        	        	            case TIMES_TOK:
        	        	            case TRUE_TOK:
        	        	            case TYPE_TOK:
        	        	            case UPPER_WORD:
        	        	            	{
        	        	            		alt2=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt2)
        	        	            {
        	        	        	case 1:
        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:159:16: anything
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_anything_in_parseCommand179);
        	        	        	        anything(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop2;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop2: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand184);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_parseCommand186);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {

        	                  cvc5::Term aexpr = PARSER_STATE->getAssertionExpr(fr, expr);
        	                  if( !aexpr.isNull() ){
        	                    // set the expression name (e.g. used with unsat core printing)
        	                    SYM_MAN->setExpressionName(aexpr, name, true);
        	                  }
        	                  // make the command to assert the formula
        	                  cmd = PARSER_STATE->makeAssertCommand(fr, aexpr, true);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:169:5: FOF_TOK LPAREN_TOK nameN[name] COMMA_TOK formulaRole[fr] COMMA_TOK fofFormula[expr] ( COMMA_TOK ( anything )* )? RPAREN_TOK DOT_TOK
        	    {
        	         MATCHT(FOF_TOK, &FOLLOW_FOF_TOK_in_parseCommand198);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand200);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand202);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand205);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_formulaRole_in_parseCommand207);
        	        formulaRole(ctx, fr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand210);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             PARSER_STATE->setCnf(false); PARSER_STATE->setFof(true); 
        	        }


        	        FOLLOWPUSH(FOLLOW_fofFormula_in_parseCommand222);
        	        fofFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:171:22: ( COMMA_TOK ( anything )* )?
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	                case COMMA_TOK:
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:171:23: COMMA_TOK ( anything )*
        	        	    {
        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand226);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:171:33: ( anything )*

        	        	        for (;;)
        	        	        {
        	        	            int alt4=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case AND_TOK:
        	        	            case CNF_TOK:
        	        	            case COLON_TOK:
        	        	            case COMMA_TOK:
        	        	            case DEFINED_SYMBOL:
        	        	            case DISEQUAL_TOK:
        	        	            case DISTINCT_OBJECT:
        	        	            case DOT_TOK:
        	        	            case EQUAL_TOK:
        	        	            case EXISTS_TOK:
        	        	            case FALSE_TOK:
        	        	            case FOF_TOK:
        	        	            case FORALL_TOK:
        	        	            case IFF_TOK:
        	        	            case IMPLIES_TOK:
        	        	            case INCLUDE_TOK:
        	        	            case LBRACK_TOK:
        	        	            case LOWER_WORD:
        	        	            case LOWER_WORD_SINGLE_QUOTED:
        	        	            case LPAREN_TOK:
        	        	            case MINUS_TOK:
        	        	            case NOT_TOK:
        	        	            case NUMBER:
        	        	            case OR_TOK:
        	        	            case PLUS_TOK:
        	        	            case REVAND_TOK:
        	        	            case REVIFF_TOK:
        	        	            case REVIMPLIES_TOK:
        	        	            case REVOR_TOK:
        	        	            case SINGLE_QUOTED:
        	        	            case TFF_TOK:
        	        	            case THF_TOK:
        	        	            case TIMES_TOK:
        	        	            case TRUE_TOK:
        	        	            case TYPE_TOK:
        	        	            case UPPER_WORD:
        	        	            	{
        	        	            		alt4=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt4)
        	        	            {
        	        	        	case 1:
        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:171:33: anything
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_anything_in_parseCommand228);
        	        	        	        anything(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop4;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop4: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand233);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_parseCommand235);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {

        	                  cvc5::Term aexpr = PARSER_STATE->getAssertionExpr(fr,expr);
        	                  if( !aexpr.isNull() ){
        	                    // set the expression name (e.g. used with unsat core printing)
        	                    SYM_MAN->setExpressionName(aexpr, name, true);
        	                  }
        	                  // make the command to assert the formula
        	                  cmd = PARSER_STATE->makeAssertCommand(fr, aexpr, false);
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:181:5: TFF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK tffTypedAtom[cmd] | formulaRole[fr] COMMA_TOK tffFormula[expr] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK
        	    {
        	         MATCHT(TFF_TOK, &FOLLOW_TFF_TOK_in_parseCommand247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand249);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand251);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand254);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:182:5: ( TYPE_TOK COMMA_TOK tffTypedAtom[cmd] | formulaRole[fr] COMMA_TOK tffFormula[expr] ( COMMA_TOK ( anything )* )? )
        	        {
        	            int alt8=2;
        	            switch ( LA(1) )
        	            {
        	            case TYPE_TOK:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;
        	            case LOWER_WORD:
        	            	{
        	            		alt8=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 8;
        	                EXCEPTION->state        = 0;


        	                goto ruleparseCommandEx;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:182:7: TYPE_TOK COMMA_TOK tffTypedAtom[cmd]
        	        	    {
        	        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_parseCommand262);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand264);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_tffTypedAtom_in_parseCommand266);
        	        	        tffTypedAtom(ctx, cmd);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:183:7: formulaRole[fr] COMMA_TOK tffFormula[expr] ( COMMA_TOK ( anything )* )?
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_formulaRole_in_parseCommand275);
        	        	        formulaRole(ctx, fr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand278);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->setCnf(false); PARSER_STATE->setFof(false); 
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_tffFormula_in_parseCommand294);
        	        	        tffFormula(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:185:24: ( COMMA_TOK ( anything )* )?
        	        	        {
        	        	            int alt7=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case COMMA_TOK:
        	        	                	{
        	        	                		alt7=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt7)
        	        	            {
        	        	        	case 1:
        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:185:25: COMMA_TOK ( anything )*
        	        	        	    {
        	        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand298);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:185:35: ( anything )*

        	        	        	        for (;;)
        	        	        	        {
        	        	        	            int alt6=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case AND_TOK:
        	        	        	            case CNF_TOK:
        	        	        	            case COLON_TOK:
        	        	        	            case COMMA_TOK:
        	        	        	            case DEFINED_SYMBOL:
        	        	        	            case DISEQUAL_TOK:
        	        	        	            case DISTINCT_OBJECT:
        	        	        	            case DOT_TOK:
        	        	        	            case EQUAL_TOK:
        	        	        	            case EXISTS_TOK:
        	        	        	            case FALSE_TOK:
        	        	        	            case FOF_TOK:
        	        	        	            case FORALL_TOK:
        	        	        	            case IFF_TOK:
        	        	        	            case IMPLIES_TOK:
        	        	        	            case INCLUDE_TOK:
        	        	        	            case LBRACK_TOK:
        	        	        	            case LOWER_WORD:
        	        	        	            case LOWER_WORD_SINGLE_QUOTED:
        	        	        	            case LPAREN_TOK:
        	        	        	            case MINUS_TOK:
        	        	        	            case NOT_TOK:
        	        	        	            case NUMBER:
        	        	        	            case OR_TOK:
        	        	        	            case PLUS_TOK:
        	        	        	            case REVAND_TOK:
        	        	        	            case REVIFF_TOK:
        	        	        	            case REVIMPLIES_TOK:
        	        	        	            case REVOR_TOK:
        	        	        	            case SINGLE_QUOTED:
        	        	        	            case TFF_TOK:
        	        	        	            case THF_TOK:
        	        	        	            case TIMES_TOK:
        	        	        	            case TRUE_TOK:
        	        	        	            case TYPE_TOK:
        	        	        	            case UPPER_WORD:
        	        	        	            	{
        	        	        	            		alt6=1;
        	        	        	            	}
        	        	        	                break;

        	        	        	            }

        	        	        	            switch (alt6)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:185:35: anything
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_anything_in_parseCommand300);
        	        	        	        	        anything(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleparseCommandEx;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	        	default:
        	        	        	        	    goto loop6;	/* break out of the loop */
        	        	        	        	    break;
        	        	        	            }
        	        	        	        }
        	        	        	        loop6: ; /* Jump out to here if this rule does not match */


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        {

        	        	                    cvc5::Term aexpr = PARSER_STATE->getAssertionExpr(fr,expr);
        	        	                    if( !aexpr.isNull() ){
        	        	                      // set the expression name (e.g. used with unsat core printing)
        	        	                      SYM_MAN->setExpressionName(aexpr, name, true);
        	        	                    }
        	        	                    // make the command to assert the formula
        	        	                    cmd = PARSER_STATE->makeAssertCommand(fr, aexpr, false);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand319);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_parseCommand321);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:196:5: THF_TOK LPAREN_TOK nameN[name] COMMA_TOK ( TYPE_TOK COMMA_TOK thfAtomTyping[cmd] | formulaRole[fr] COMMA_TOK thfLogicFormula[p] ( COMMA_TOK ( anything )* )? ) RPAREN_TOK DOT_TOK
        	    {
        	         MATCHT(THF_TOK, &FOLLOW_THF_TOK_in_parseCommand327);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->setHol();
        	                
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand339);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand341);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand344);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:203:5: ( TYPE_TOK COMMA_TOK thfAtomTyping[cmd] | formulaRole[fr] COMMA_TOK thfLogicFormula[p] ( COMMA_TOK ( anything )* )? )
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	            case TYPE_TOK:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;
        	            case LOWER_WORD:
        	            	{
        	            		alt11=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 11;
        	                EXCEPTION->state        = 0;


        	                goto ruleparseCommandEx;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:203:7: TYPE_TOK COMMA_TOK thfAtomTyping[cmd]
        	        	    {
        	        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_parseCommand362);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand364);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_thfAtomTyping_in_parseCommand366);
        	        	        thfAtomTyping(ctx, cmd);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:204:7: formulaRole[fr] COMMA_TOK thfLogicFormula[p] ( COMMA_TOK ( anything )* )?
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_formulaRole_in_parseCommand375);
        	        	        formulaRole(ctx, fr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand378);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->setCnf(false); PARSER_STATE->setFof(false); 
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_thfLogicFormula_in_parseCommand394);
        	        	        thfLogicFormula(ctx, p);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:206:26: ( COMMA_TOK ( anything )* )?
        	        	        {
        	        	            int alt10=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case COMMA_TOK:
        	        	                	{
        	        	                		alt10=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt10)
        	        	            {
        	        	        	case 1:
        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:206:27: COMMA_TOK ( anything )*
        	        	        	    {
        	        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand398);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:206:37: ( anything )*

        	        	        	        for (;;)
        	        	        	        {
        	        	        	            int alt9=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case AND_TOK:
        	        	        	            case CNF_TOK:
        	        	        	            case COLON_TOK:
        	        	        	            case COMMA_TOK:
        	        	        	            case DEFINED_SYMBOL:
        	        	        	            case DISEQUAL_TOK:
        	        	        	            case DISTINCT_OBJECT:
        	        	        	            case DOT_TOK:
        	        	        	            case EQUAL_TOK:
        	        	        	            case EXISTS_TOK:
        	        	        	            case FALSE_TOK:
        	        	        	            case FOF_TOK:
        	        	        	            case FORALL_TOK:
        	        	        	            case IFF_TOK:
        	        	        	            case IMPLIES_TOK:
        	        	        	            case INCLUDE_TOK:
        	        	        	            case LBRACK_TOK:
        	        	        	            case LOWER_WORD:
        	        	        	            case LOWER_WORD_SINGLE_QUOTED:
        	        	        	            case LPAREN_TOK:
        	        	        	            case MINUS_TOK:
        	        	        	            case NOT_TOK:
        	        	        	            case NUMBER:
        	        	        	            case OR_TOK:
        	        	        	            case PLUS_TOK:
        	        	        	            case REVAND_TOK:
        	        	        	            case REVIFF_TOK:
        	        	        	            case REVIMPLIES_TOK:
        	        	        	            case REVOR_TOK:
        	        	        	            case SINGLE_QUOTED:
        	        	        	            case TFF_TOK:
        	        	        	            case THF_TOK:
        	        	        	            case TIMES_TOK:
        	        	        	            case TRUE_TOK:
        	        	        	            case TYPE_TOK:
        	        	        	            case UPPER_WORD:
        	        	        	            	{
        	        	        	            		alt9=1;
        	        	        	            	}
        	        	        	                break;

        	        	        	            }

        	        	        	            switch (alt9)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:206:37: anything
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_anything_in_parseCommand400);
        	        	        	        	        anything(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleparseCommandEx;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	        	default:
        	        	        	        	    goto loop9;	/* break out of the loop */
        	        	        	        	    break;
        	        	        	            }
        	        	        	        }
        	        	        	        loop9: ; /* Jump out to here if this rule does not match */


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        {

        	        	                    if (p.d_expr.isNull())
        	        	                    {
        	        	                      PARSER_STATE->parseError("Top level expression must be a formula");
        	        	                    }
        	        	                    expr = p.d_expr;
        	        	                    cvc5::Term aexpr = PARSER_STATE->getAssertionExpr(fr, expr);
        	        	                    if (!aexpr.isNull())
        	        	                    {
        	        	                      // set the expression name (e.g. used with unsat core printing)
        	        	                      SYM_MAN->setExpressionName(aexpr, name, true);
        	        	                    }
        	        	                    // make the command to assert the formula
        	        	                    cmd = PARSER_STATE->makeAssertCommand(fr, aexpr, false);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand419);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_parseCommand421);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:223:5: INCLUDE_TOK LPAREN_TOK unquotedFileName[name] ( COMMA_TOK LBRACK_TOK nameN[inclSymbol] ( COMMA_TOK nameN[inclSymbol] )* RBRACK_TOK )? RPAREN_TOK DOT_TOK
        	    {
        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_parseCommand427);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand429);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_unquotedFileName_in_parseCommand431);
        	        unquotedFileName(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:224:5: ( COMMA_TOK LBRACK_TOK nameN[inclSymbol] ( COMMA_TOK nameN[inclSymbol] )* RBRACK_TOK )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	                case COMMA_TOK:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:224:7: COMMA_TOK LBRACK_TOK nameN[inclSymbol] ( COMMA_TOK nameN[inclSymbol] )* RBRACK_TOK
        	        	    {
        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand440);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_parseCommand442);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand444);
        	        	        nameN(ctx, inclSymbol);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:225:7: ( COMMA_TOK nameN[inclSymbol] )*

        	        	        for (;;)
        	        	        {
        	        	            int alt12=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case COMMA_TOK:
        	        	            	{
        	        	            		alt12=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt12)
        	        	            {
        	        	        	case 1:
        	        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:225:9: COMMA_TOK nameN[inclSymbol]
        	        	        	    {
        	        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_parseCommand455);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_nameN_in_parseCommand457);
        	        	        	        nameN(ctx, inclSymbol);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleparseCommandEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop12;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop12: ; /* Jump out to here if this rule does not match */


        	        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_parseCommand463);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand472);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_parseCommand474);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             /* TODO - implement symbol filtering for file inclusion.
        	                   * the following removes duplicates and "all", just need to pass it
        	                   * through to includeFile() and implement it there.
        	                  std::sort(inclArgs.begin(), inclArgs.end());
        	                  std::vector<std::string>::iterator it =
        	                    std::unique(inclArgs.begin(), inclArgs.end());
        	                  inclArgs.resize(std::distance(inclArgs.begin(), it));
        	                  it = std::lower_bound(inclArgs.begin(), inclArgs.end(), std::string("all"));
        	                  if(it != inclArgs.end() && *it == "all") {
        	                    inclArgs.erase(it);
        	                  }
        	                  */
        	                  const std::string& tptpDir = PARSER_STATE->getTptpDir();
        	                  PARSER_BASE->includeTptpFile(name, tptpDir);
        	                  // The command of the included file will be produced at the next parseCommand() call
        	                  cmd = std::make_unique<EmptyCommand>("include::" + name);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:244:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseCommand486);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {

        	                  // assert that all distinct constants are distinct
        	                  cvc5::Term aexpr = PARSER_STATE->getAssertionDistinctConstants();
        	                  if( !aexpr.isNull() )
        	                  {
        	                    PARSER_STATE->preemptCommand(std::make_unique<AssertCommand>(aexpr));
        	                  }

        	                  std::string filename = PARSER_BASE->getInput()->getInputStreamName();
        	                  size_t i = filename.find_last_of('/');
        	                  if(i != std::string::npos) {
        	                    filename = filename.substr(i + 1);
        	                  }
        	                  if(filename.substr(filename.length() - 2) == ".p") {
        	                    filename = filename.substr(0, filename.length() - 2);
        	                  }
        	                  PARSER_STATE->preemptCommand(std::make_unique<SetInfoCommand>("filename", filename));
        	                  if(PARSER_STATE->hasConjecture()) {
        	                    // note this does not impact how the TPTP status is reported currently
        	                    PARSER_STATE->preemptCommand(std::make_unique<CheckSatAssumingCommand>(SOLVER->mkTrue()));
        	                  } else {
        	                    PARSER_STATE->preemptCommand(std::make_unique<CheckSatCommand>());
        	                  }
        	                  cmd = nullptr;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return cmd;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start formulaRole
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:273:1: formulaRole[cvc5::parser::TptpState::FormulaRole& role] : LOWER_WORD ;
 */
static void
formulaRole(pTptpParser ctx, cvc5::parser::TptpState::FormulaRole& role)
{
    pANTLR3_COMMON_TOKEN    LOWER_WORD1;

    /* Initialize rule variables
     */

    LOWER_WORD1       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:274:3: ( LOWER_WORD )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:274:5: LOWER_WORD
        {
            LOWER_WORD1 = (pANTLR3_COMMON_TOKEN) MATCHT(LOWER_WORD, &FOLLOW_LOWER_WORD_in_formulaRole508);
            if  (HASEXCEPTION())
            {
                goto ruleformulaRoleEx;
            }


            {

                      std::string r = AntlrInput::tokenText(LOWER_WORD1);
                      if      (r == "axiom")              role = TptpState::FR_AXIOM;
                      else if (r == "hypothesis")         role = TptpState::FR_HYPOTHESIS;
                      else if (r == "definition")         role = TptpState::FR_DEFINITION;
                      else if (r == "assumption")         role = TptpState::FR_ASSUMPTION;
                      else if (r == "lemma")              role = TptpState::FR_LEMMA;
                      else if (r == "theorem")            role = TptpState::FR_THEOREM;
                      else if (r == "negated_conjecture") role = TptpState::FR_NEGATED_CONJECTURE;
                      else if (r == "conjecture")         role = TptpState::FR_CONJECTURE;
                      else if (r == "unknown")            role = TptpState::FR_UNKNOWN;
                      else if (r == "plain")              role = TptpState::FR_PLAIN;
                      else if (r == "fi_domain")          role = TptpState::FR_FI_DOMAIN;
                      else if (r == "fi_functor")         role = TptpState::FR_FI_FUNCTORS;
                      else if (r == "fi_predicate")       role = TptpState::FR_FI_PREDICATES;
                      else if (r == "type")               role = TptpState::FR_TYPE;
                      else PARSER_STATE->parseError("Invalid formula role: " + r);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleformulaRoleEx; /* Prevent compiler warnings */
    ruleformulaRoleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end formulaRole */

/**
 * $ANTLR start cnfFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:301:1: cnfFormula[cvc5::Term& expr] : ( LPAREN_TOK cnfDisjunction[expr] RPAREN_TOK | cnfDisjunction[expr] );
 */
static void
cnfFormula(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:302:3: ( LPAREN_TOK cnfDisjunction[expr] RPAREN_TOK | cnfDisjunction[expr] )

            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt15=1;
            	}
                break;
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NOT_TOK:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt15=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto rulecnfFormulaEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:302:5: LPAREN_TOK cnfDisjunction[expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_cnfFormula536);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_cnfDisjunction_in_cnfFormula538);
        	        cnfDisjunction(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_cnfFormula541);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:303:5: cnfDisjunction[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_cnfDisjunction_in_cnfFormula547);
        	        cnfDisjunction(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfFormulaEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecnfFormulaEx; /* Prevent compiler warnings */
    rulecnfFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end cnfFormula */

/**
 * $ANTLR start cnfDisjunction
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:306:1: cnfDisjunction[cvc5::Term& expr] : cnfLiteral[expr] ( OR_TOK cnfLiteral[expr] )* ;
 */
static void
cnfDisjunction(pTptpParser ctx, cvc5::Term& expr)
{

      std::vector<cvc5::Term> args;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:310:3: ( cnfLiteral[expr] ( OR_TOK cnfLiteral[expr] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:310:5: cnfLiteral[expr] ( OR_TOK cnfLiteral[expr] )*
        {
            FOLLOWPUSH(FOLLOW_cnfLiteral_in_cnfDisjunction565);
            cnfLiteral(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnfDisjunctionEx;
            }


            {
                 args.push_back(expr); 
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:311:5: ( OR_TOK cnfLiteral[expr] )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case OR_TOK:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:311:7: OR_TOK cnfLiteral[expr]
            	    {
            	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_cnfDisjunction576);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecnfDisjunctionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_cnfLiteral_in_cnfDisjunction578);
            	        cnfLiteral(ctx, expr);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecnfDisjunctionEx;
            	        }


            	        {
            	             args.push_back(expr); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            {
                 if(args.size() > 1) {
                        expr = MK_TERM(cvc5::OR, args);
                      } // else its already in the expr
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecnfDisjunctionEx; /* Prevent compiler warnings */
    rulecnfDisjunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end cnfDisjunction */

/**
 * $ANTLR start cnfLiteral
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:318:1: cnfLiteral[cvc5::Term& expr] : ( atomicFormula[expr] | NOT_TOK atomicFormula[expr] );
 */
static void
cnfLiteral(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:319:3: ( atomicFormula[expr] | NOT_TOK atomicFormula[expr] )

            ANTLR3_UINT32 alt17;

            alt17=2;

            switch ( LA(1) )
            {
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt17=1;
            	}
                break;
            case NOT_TOK:
            	{
            		alt17=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto rulecnfLiteralEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:319:5: atomicFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicFormula_in_cnfLiteral602);
        	        atomicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfLiteralEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:320:5: NOT_TOK atomicFormula[expr]
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_cnfLiteral609);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfLiteralEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_atomicFormula_in_cnfLiteral611);
        	        atomicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecnfLiteralEx;
        	        }


        	        {
        	             expr = MK_TERM(cvc5::NOT, expr); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecnfLiteralEx; /* Prevent compiler warnings */
    rulecnfLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end cnfLiteral */

/**
 * $ANTLR start atomicFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:323:1: atomicFormula[cvc5::Term& expr] : ( atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? ( equalOp[equal] term[expr2] |) | definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] ) | ( simpleTerm[expr] | letTerm[expr] | conditionalTerm[expr] ) ( equalOp[equal] term[expr2] )? | definedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK ) | definedProp[expr] );
 */
static void
atomicFormula(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Term expr2;
      std::string name;
      std::vector<cvc5::Term> args;
      bool equal;
      ParseOp p;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:331:3: ( atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? ( equalOp[equal] term[expr2] |) | definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] ) | ( simpleTerm[expr] | letTerm[expr] | conditionalTerm[expr] ) ( equalOp[equal] term[expr2] )? | definedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK ) | definedProp[expr] )

            ANTLR3_UINT32 alt22;

            alt22=5;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt22=1;
            	}
                break;
            case 63:
            case 64:
            case 66:
            case 71:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt22=2;
            	}
                break;
            case DISTINCT_OBJECT:
            case NUMBER:
            case UPPER_WORD:
            case 73:
            case 77:
            case 79:
            	{
            		alt22=3;
            	}
                break;
            case AND_TOK:
            case IMPLIES_TOK:
            case OR_TOK:
            case 65:
            case 67:
            case 68:
            case 69:
            case 70:
            case 74:
            case 75:
            	{
            		alt22=4;
            	}
                break;
            case FALSE_TOK:
            case TRUE_TOK:
            	{
            		alt22=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto ruleatomicFormulaEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:331:5: atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? ( equalOp[equal] term[expr2] |)
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicWord_in_atomicFormula633);
        	        atomicWord(ctx, p.d_name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:331:26: ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        	        {
        	            int alt18=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt18=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt18)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:331:27: LPAREN_TOK arguments[args] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_atomicFormula637);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_arguments_in_atomicFormula639);
        	        	        arguments(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_atomicFormula642);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:332:5: ( equalOp[equal] term[expr2] |)
        	        {
        	            int alt19=2;
        	            switch ( LA(1) )
        	            {
        	            case DISEQUAL_TOK:
        	            case EQUAL_TOK:
        	            	{
        	            		alt19=1;
        	            	}
        	                break;
        	            case EOF:
        	            case AND_TOK:
        	            case COMMA_TOK:
        	            case IFF_TOK:
        	            case IMPLIES_TOK:
        	            case OR_TOK:
        	            case REVAND_TOK:
        	            case REVIFF_TOK:
        	            case REVIMPLIES_TOK:
        	            case REVOR_TOK:
        	            case RPAREN_TOK:
        	            	{
        	            		alt19=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 19;
        	                EXCEPTION->state        = 0;


        	                goto ruleatomicFormulaEx;

        	            }

        	            switch (alt19)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:332:7: equalOp[equal] term[expr2]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_equalOp_in_atomicFormula652);
        	        	        equalOp(ctx, equal);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_atomicFormula655);
        	        	        term(ctx, expr2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	        {
        	        	             // equality/disequality between terms
        	        	                    expr = args.empty() ? PARSER_STATE->parseOpToExpr(p)
        	        	                                        : PARSER_STATE->applyParseOp(p, args);
        	        	                    args.clear();
        	        	                    args.push_back(expr);
        	        	                    args.push_back(expr2);
        	        	                    ParseOp p1(cvc5::EQUAL);
        	        	                    expr = PARSER_STATE->applyParseOp(p1, args);
        	        	                    if (!equal)
        	        	                    {
        	        	                      expr = MK_TERM(cvc5::NOT, expr);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:346:7: 
        	        	    {
        	        	        {
        	        	             // predicate
        	        	                    p.d_type = SOLVER->getBooleanSort();
        	        	                    expr = args.empty() ? PARSER_STATE->parseOpToExpr(p)
        	        	                                        : PARSER_STATE->applyParseOp(p, args);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:352:5: definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )
        	    {
        	        FOLLOWPUSH(FOLLOW_definedFun_in_atomicFormula684);
        	        definedFun(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:353:5: ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:354:6: LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2]
        	        {
        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_atomicFormula698);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	            FOLLOWPUSH(FOLLOW_arguments_in_atomicFormula700);
        	            arguments(ctx, args);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_atomicFormula703);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	            FOLLOWPUSH(FOLLOW_equalOp_in_atomicFormula710);
        	            equalOp(ctx, equal);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	            FOLLOWPUSH(FOLLOW_term_in_atomicFormula713);
        	            term(ctx, expr2);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	            {

        	                       expr = PARSER_STATE->applyParseOp(p, args);
        	                       args.clear();
        	                       args.push_back(expr);
        	                       args.push_back(expr2);
        	                       ParseOp p1(cvc5::EQUAL);
        	                       expr = PARSER_STATE->applyParseOp(p1, args);
        	                       if (!equal)
        	                       {
        	                         expr = MK_TERM(cvc5::NOT, expr);
        	                       }
        	                     
        	            }


        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:369:5: ( simpleTerm[expr] | letTerm[expr] | conditionalTerm[expr] ) ( equalOp[equal] term[expr2] )?
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:369:5: ( simpleTerm[expr] | letTerm[expr] | conditionalTerm[expr] )
        	        {
        	            int alt20=3;
        	            switch ( LA(1) )
        	            {
        	            case DISTINCT_OBJECT:
        	            case NUMBER:
        	            case UPPER_WORD:
        	            	{
        	            		alt20=1;
        	            	}
        	                break;
        	            case 77:
        	            case 79:
        	            	{
        	            		alt20=2;
        	            	}
        	                break;
        	            case 73:
        	            	{
        	            		alt20=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 20;
        	                EXCEPTION->state        = 0;


        	                goto ruleatomicFormulaEx;

        	            }

        	            switch (alt20)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:369:6: simpleTerm[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleTerm_in_atomicFormula734);
        	        	        simpleTerm(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:369:25: letTerm[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_letTerm_in_atomicFormula739);
        	        	        letTerm(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:369:41: conditionalTerm[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_conditionalTerm_in_atomicFormula744);
        	        	        conditionalTerm(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:370:5: ( equalOp[equal] term[expr2] )?
        	        {
        	            int alt21=2;
        	            switch ( LA(1) )
        	            {
        	                case DISEQUAL_TOK:
        	                case EQUAL_TOK:
        	                	{
        	                		alt21=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:371:7: equalOp[equal] term[expr2]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_equalOp_in_atomicFormula760);
        	        	        equalOp(ctx, equal);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_atomicFormula763);
        	        	        term(ctx, expr2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomicFormulaEx;
        	        	        }


        	        	        {
        	        	             // equality/disequality between terms
        	        	                    args.push_back(expr);
        	        	                    args.push_back(expr2);
        	        	                    p.d_kind = cvc5::EQUAL;
        	        	                    expr = PARSER_STATE->applyParseOp(p, args);
        	        	                    if (!equal)
        	        	                    {
        	        	                      expr = MK_TERM(cvc5::NOT, expr);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:383:5: definedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK )
        	    {
        	        FOLLOWPUSH(FOLLOW_definedPred_in_atomicFormula785);
        	        definedPred(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:383:20: ( LPAREN_TOK arguments[args] RPAREN_TOK )
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:383:21: LPAREN_TOK arguments[args] RPAREN_TOK
        	        {
        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_atomicFormula789);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	            FOLLOWPUSH(FOLLOW_arguments_in_atomicFormula791);
        	            arguments(ctx, args);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_atomicFormula794);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleatomicFormulaEx;
        	            }


        	        }


        	        {

        	                  p.d_type = SOLVER->getBooleanSort();
        	                  expr = PARSER_STATE->applyParseOp(p, args);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:388:5: definedProp[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_definedProp_in_atomicFormula807);
        	        definedProp(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicFormulaEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomicFormulaEx; /* Prevent compiler warnings */
    ruleatomicFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomicFormula */

/**
 * $ANTLR start thfAtomicFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:391:1: thfAtomicFormula[cvc5::ParseOp& p] : ( atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? | definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )? | thfSimpleTerm[p.d_expr] | letTerm[p.d_expr] | conditionalTerm[p.d_expr] | thfDefinedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK )? | definedProp[p.d_expr] );
 */
static void
thfAtomicFormula(pTptpParser ctx, cvc5::ParseOp& p)
{

      cvc5::Term expr2;
      std::string name;
      std::vector<cvc5::Term> args;
      bool equal;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:398:3: ( atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? | definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )? | thfSimpleTerm[p.d_expr] | letTerm[p.d_expr] | conditionalTerm[p.d_expr] | thfDefinedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK )? | definedProp[p.d_expr] )

            ANTLR3_UINT32 alt26;

            alt26=7;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt26=1;
            	}
                break;
            case 63:
            case 64:
            case 66:
            case 71:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt26=2;
            	}
                break;
            case DISTINCT_OBJECT:
            case NUMBER:
            	{
            		alt26=3;
            	}
                break;
            case 77:
            case 79:
            	{
            		alt26=4;
            	}
                break;
            case 73:
            	{
            		alt26=5;
            	}
                break;
            case LPAREN_TOK:
            case 65:
            case 67:
            case 68:
            case 69:
            case 70:
            case 74:
            case 75:
            	{
            		alt26=6;
            	}
                break;
            case FALSE_TOK:
            case TRUE_TOK:
            	{
            		alt26=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto rulethfAtomicFormulaEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:398:5: atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicWord_in_thfAtomicFormula827);
        	        atomicWord(ctx, p.d_name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:398:26: ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        	        {
        	            int alt23=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt23=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt23)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:398:27: LPAREN_TOK arguments[args] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfAtomicFormula831);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_arguments_in_thfAtomicFormula833);
        	        	        arguments(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfAtomicFormula836);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  p.d_expr = args.empty() ? PARSER_STATE->parseOpToExpr(p)
        	                                          : PARSER_STATE->applyParseOp(p, args);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:403:5: definedFun[p] ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_definedFun_in_thfAtomicFormula850);
        	        definedFun(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:404:5: ( LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2] )?
        	        {
        	            int alt24=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt24=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:405:7: LPAREN_TOK arguments[args] RPAREN_TOK equalOp[equal] term[expr2]
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfAtomicFormula865);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_arguments_in_thfAtomicFormula867);
        	        	        arguments(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfAtomicFormula870);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_equalOp_in_thfAtomicFormula878);
        	        	        equalOp(ctx, equal);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_term_in_thfAtomicFormula881);
        	        	        term(ctx, expr2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        {

        	        	                    p.d_expr = PARSER_STATE->applyParseOp(p, args);
        	        	                    args.clear();
        	        	                    args.push_back(p.d_expr);
        	        	                    args.push_back(expr2);
        	        	                    ParseOp p1(cvc5::EQUAL);
        	        	                    p.d_expr = PARSER_STATE->applyParseOp(p1, args);
        	        	                    if (!equal)
        	        	                    {
        	        	                      p.d_expr = MK_TERM(cvc5::NOT, p.d_expr);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:420:5: thfSimpleTerm[p.d_expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_thfSimpleTerm_in_thfAtomicFormula903);
        	        thfSimpleTerm(ctx, p.d_expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:421:5: letTerm[p.d_expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_letTerm_in_thfAtomicFormula910);
        	        letTerm(ctx, p.d_expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:422:5: conditionalTerm[p.d_expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_conditionalTerm_in_thfAtomicFormula917);
        	        conditionalTerm(ctx, p.d_expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:423:5: thfDefinedPred[p] ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        	    {
        	        FOLLOWPUSH(FOLLOW_thfDefinedPred_in_thfAtomicFormula924);
        	        thfDefinedPred(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:423:23: ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        	        {
        	            int alt25=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt25=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:423:24: LPAREN_TOK arguments[args] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfAtomicFormula928);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_arguments_in_thfAtomicFormula930);
        	        	        arguments(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfAtomicFormula933);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomicFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  p.d_type = SOLVER->getBooleanSort();
        	                  if (!args.empty())
        	                  {
        	                    p.d_expr = PARSER_STATE->applyParseOp(p, args);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:431:5: definedProp[p.d_expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_definedProp_in_thfAtomicFormula947);
        	        definedProp(ctx, p.d_expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomicFormulaEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfAtomicFormulaEx; /* Prevent compiler warnings */
    rulethfAtomicFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfAtomicFormula */

/**
 * $ANTLR start definedProp
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:437:1: definedProp[cvc5::Term& expr] : ( TRUE_TOK | FALSE_TOK );
 */
static void
definedProp(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:438:3: ( TRUE_TOK | FALSE_TOK )

            ANTLR3_UINT32 alt27;

            alt27=2;

            switch ( LA(1) )
            {
            case TRUE_TOK:
            	{
            		alt27=1;
            	}
                break;
            case FALSE_TOK:
            	{
            		alt27=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruledefinedPropEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:438:5: TRUE_TOK
        	    {
        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_definedProp965);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPropEx;
        	        }


        	        {
        	             expr = SOLVER->mkTrue(); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:439:5: FALSE_TOK
        	    {
        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_definedProp973);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPropEx;
        	        }


        	        {
        	             expr = SOLVER->mkFalse(); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledefinedPropEx; /* Prevent compiler warnings */
    ruledefinedPropEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end definedProp */

/**
 * $ANTLR start definedPred
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:442:1: definedPred[cvc5::ParseOp& p] : ( '$less' | '$lesseq' | '$greater' | '$greatereq' | '$is_rat' | '$is_int' | '$distinct' | AND_TOK | IMPLIES_TOK | OR_TOK );
 */
static void
definedPred(pTptpParser ctx, cvc5::ParseOp& p)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:443:3: ( '$less' | '$lesseq' | '$greater' | '$greatereq' | '$is_rat' | '$is_int' | '$distinct' | AND_TOK | IMPLIES_TOK | OR_TOK )

            ANTLR3_UINT32 alt28;

            alt28=10;

            switch ( LA(1) )
            {
            case 74:
            	{
            		alt28=1;
            	}
                break;
            case 75:
            	{
            		alt28=2;
            	}
                break;
            case 67:
            	{
            		alt28=3;
            	}
                break;
            case 68:
            	{
            		alt28=4;
            	}
                break;
            case 70:
            	{
            		alt28=5;
            	}
                break;
            case 69:
            	{
            		alt28=6;
            	}
                break;
            case 65:
            	{
            		alt28=7;
            	}
                break;
            case AND_TOK:
            	{
            		alt28=8;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt28=9;
            	}
                break;
            case OR_TOK:
            	{
            		alt28=10;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruledefinedPredEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:443:5: '$less'
        	    {
        	         MATCHT(74, &FOLLOW_74_in_definedPred990);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::LT;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:447:5: '$lesseq'
        	    {
        	         MATCHT(75, &FOLLOW_75_in_definedPred1002);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::LEQ;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:451:5: '$greater'
        	    {
        	         MATCHT(67, &FOLLOW_67_in_definedPred1014);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::GT;
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:455:5: '$greatereq'
        	    {
        	         MATCHT(68, &FOLLOW_68_in_definedPred1026);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::GEQ;
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:459:5: '$is_rat'
        	    {
        	         MATCHT(70, &FOLLOW_70_in_definedPred1038);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term q = SOLVER->mkVar(SOLVER->getIntegerSort(), "Q");
        	                  cvc5::Term qr = MK_TERM(cvc5::TO_REAL, q);
        	                  cvc5::Term r = SOLVER->mkVar(SOLVER->getIntegerSort(), "R");
        	                  cvc5::Term rr = MK_TERM(cvc5::TO_REAL, r);
        	                  cvc5::Term body =
        	                      MK_TERM(cvc5::AND,
        	                              MK_TERM(cvc5::NOT,
        	                                      MK_TERM(cvc5::EQUAL, r, SOLVER->mkInteger(0))),
        	                              MK_TERM(cvc5::EQUAL, qr, MK_TERM(cvc5::MULT, n, rr)));
        	                  cvc5::Term bvl = MK_TERM(cvc5::VARIABLE_LIST, q, r);
        	                  body = MK_TERM(cvc5::EXISTS, bvl, body);
        	                  cvc5::Term lbvl = MK_TERM(cvc5::VARIABLE_LIST, n);
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, lbvl, body);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:480:5: '$is_int'
        	    {
        	         MATCHT(69, &FOLLOW_69_in_definedPred1065);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::IS_INTEGER;
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:484:5: '$distinct'
        	    {
        	         MATCHT(65, &FOLLOW_65_in_definedPred1077);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::DISTINCT;
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:488:5: AND_TOK
        	    {
        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_definedPred1089);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::AND;
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:492:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_definedPred1101);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::IMPLIES;
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:496:5: OR_TOK
        	    {
        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_definedPred1113);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::OR;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledefinedPredEx; /* Prevent compiler warnings */
    ruledefinedPredEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end definedPred */

/**
 * $ANTLR start thfDefinedPred
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:502:1: thfDefinedPred[cvc5::ParseOp& p] : ( '$less' | '$lesseq' | '$greater' | '$greatereq' | '$is_rat' | '$is_int' | '$distinct' | LPAREN_TOK ( AND_TOK | OR_TOK | IMPLIES_TOK ) RPAREN_TOK );
 */
static void
thfDefinedPred(pTptpParser ctx, cvc5::ParseOp& p)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:503:3: ( '$less' | '$lesseq' | '$greater' | '$greatereq' | '$is_rat' | '$is_int' | '$distinct' | LPAREN_TOK ( AND_TOK | OR_TOK | IMPLIES_TOK ) RPAREN_TOK )

            ANTLR3_UINT32 alt30;

            alt30=8;

            switch ( LA(1) )
            {
            case 74:
            	{
            		alt30=1;
            	}
                break;
            case 75:
            	{
            		alt30=2;
            	}
                break;
            case 67:
            	{
            		alt30=3;
            	}
                break;
            case 68:
            	{
            		alt30=4;
            	}
                break;
            case 70:
            	{
            		alt30=5;
            	}
                break;
            case 69:
            	{
            		alt30=6;
            	}
                break;
            case 65:
            	{
            		alt30=7;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt30=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;


                goto rulethfDefinedPredEx;

            }

            switch (alt30)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:503:5: '$less'
        	    {
        	         MATCHT(74, &FOLLOW_74_in_thfDefinedPred1133);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                   p.d_kind = cvc5::LT;
        	                 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:507:5: '$lesseq'
        	    {
        	         MATCHT(75, &FOLLOW_75_in_thfDefinedPred1146);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::LEQ;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:511:5: '$greater'
        	    {
        	         MATCHT(67, &FOLLOW_67_in_thfDefinedPred1158);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::GT;
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:515:5: '$greatereq'
        	    {
        	         MATCHT(68, &FOLLOW_68_in_thfDefinedPred1170);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::GEQ;
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:519:5: '$is_rat'
        	    {
        	         MATCHT(70, &FOLLOW_70_in_thfDefinedPred1182);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term q = SOLVER->mkVar(SOLVER->getIntegerSort(), "Q");
        	                  cvc5::Term qr = MK_TERM(cvc5::TO_REAL, q);
        	                  cvc5::Term r = SOLVER->mkVar(SOLVER->getIntegerSort(), "R");
        	                  cvc5::Term rr = MK_TERM(cvc5::TO_REAL, r);
        	                  cvc5::Term body = MK_TERM(
        	                      cvc5::AND,
        	                      MK_TERM(cvc5::NOT,
        	                              MK_TERM(cvc5::EQUAL, r, SOLVER->mkInteger(0))),
        	                      MK_TERM(cvc5::EQUAL, qr, MK_TERM(cvc5::MULT, n, rr)));
        	                  cvc5::Term bvl = MK_TERM(cvc5::VARIABLE_LIST, q, r);
        	                  body = MK_TERM(cvc5::EXISTS, bvl, body);
        	                  cvc5::Term lbvl = MK_TERM(cvc5::VARIABLE_LIST, n);
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, lbvl, body);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:540:5: '$is_int'
        	    {
        	         MATCHT(69, &FOLLOW_69_in_thfDefinedPred1209);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::IS_INTEGER;
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:544:5: '$distinct'
        	    {
        	         MATCHT(65, &FOLLOW_65_in_thfDefinedPred1221);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::DISTINCT;
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:548:5: LPAREN_TOK ( AND_TOK | OR_TOK | IMPLIES_TOK ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfDefinedPred1233);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:549:5: ( AND_TOK | OR_TOK | IMPLIES_TOK )
        	        {
        	            int alt29=3;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            	{
        	            		alt29=1;
        	            	}
        	                break;
        	            case OR_TOK:
        	            	{
        	            		alt29=2;
        	            	}
        	                break;
        	            case IMPLIES_TOK:
        	            	{
        	            		alt29=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 29;
        	                EXCEPTION->state        = 0;


        	                goto rulethfDefinedPredEx;

        	            }

        	            switch (alt29)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:550:7: AND_TOK
        	        	    {
        	        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_thfDefinedPred1247);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfDefinedPredEx;
        	        	        }


        	        	        {

        	        	                    p.d_kind = cvc5::AND;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:554:7: OR_TOK
        	        	    {
        	        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_thfDefinedPred1263);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfDefinedPredEx;
        	        	        }


        	        	        {

        	        	                    p.d_kind = cvc5::OR;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:558:7: IMPLIES_TOK
        	        	    {
        	        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_thfDefinedPred1279);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfDefinedPredEx;
        	        	        }


        	        	        {

        	        	                    p.d_kind = cvc5::IMPLIES;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfDefinedPred1299);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfDefinedPredEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfDefinedPredEx; /* Prevent compiler warnings */
    rulethfDefinedPredEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfDefinedPred */

/**
 * $ANTLR start definedFun
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:566:1: definedFun[cvc5::ParseOp& p] : ( '$uminus' | '$sum' | '$difference' | '$product' | '$quotient' | '$ite' | ( '$quotient_e' | '$remainder_e' ) | ( '$quotient_t' | '$remainder_t' ) | ( '$quotient_f' | '$remainder_f' ) | '$floor' | '$ceiling' | '$truncate' | '$round' | '$to_int' | '$to_rat' | '$to_real' );
 */
static void
definedFun(pTptpParser ctx, cvc5::ParseOp& p)
{

      bool remainder = false;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:570:3: ( '$uminus' | '$sum' | '$difference' | '$product' | '$quotient' | '$ite' | ( '$quotient_e' | '$remainder_e' ) | ( '$quotient_t' | '$remainder_t' ) | ( '$quotient_f' | '$remainder_f' ) | '$floor' | '$ceiling' | '$truncate' | '$round' | '$to_int' | '$to_rat' | '$to_real' )

            ANTLR3_UINT32 alt34;

            alt34=16;

            switch ( LA(1) )
            {
            case 95:
            	{
            		alt34=1;
            	}
                break;
            case 89:
            	{
            		alt34=2;
            	}
                break;
            case 64:
            	{
            		alt34=3;
            	}
                break;
            case 80:
            	{
            		alt34=4;
            	}
                break;
            case 81:
            	{
            		alt34=5;
            	}
                break;
            case 71:
            	{
            		alt34=6;
            	}
                break;
            case 82:
            case 85:
            	{
            		alt34=7;
            	}
                break;
            case 84:
            case 87:
            	{
            		alt34=8;
            	}
                break;
            case 83:
            case 86:
            	{
            		alt34=9;
            	}
                break;
            case 66:
            	{
            		alt34=10;
            	}
                break;
            case 63:
            	{
            		alt34=11;
            	}
                break;
            case 94:
            	{
            		alt34=12;
            	}
                break;
            case 88:
            	{
            		alt34=13;
            	}
                break;
            case 91:
            	{
            		alt34=14;
            	}
                break;
            case 92:
            	{
            		alt34=15;
            	}
                break;
            case 93:
            	{
            		alt34=16;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 34;
                EXCEPTION->state        = 0;


                goto ruledefinedFunEx;

            }

            switch (alt34)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:570:5: '$uminus'
        	    {
        	         MATCHT(95, &FOLLOW_95_in_definedFun1318);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::NEG;
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:574:5: '$sum'
        	    {
        	         MATCHT(89, &FOLLOW_89_in_definedFun1330);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::ADD;
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:578:5: '$difference'
        	    {
        	         MATCHT(64, &FOLLOW_64_in_definedFun1342);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::SUB;
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:582:5: '$product'
        	    {
        	         MATCHT(80, &FOLLOW_80_in_definedFun1354);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::MULT;
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:586:5: '$quotient'
        	    {
        	         MATCHT(81, &FOLLOW_81_in_definedFun1366);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::DIVISION;
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:590:5: '$ite'
        	    {
        	         MATCHT(71, &FOLLOW_71_in_definedFun1378);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::ITE;
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:594:5: ( '$quotient_e' | '$remainder_e' )
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:594:5: ( '$quotient_e' | '$remainder_e' )
        	        {
        	            int alt31=2;
        	            switch ( LA(1) )
        	            {
        	            case 82:
        	            	{
        	            		alt31=1;
        	            	}
        	                break;
        	            case 85:
        	            	{
        	            		alt31=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 31;
        	                EXCEPTION->state        = 0;


        	                goto ruledefinedFunEx;

        	            }

        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:594:7: '$quotient_e'
        	        	    {
        	        	         MATCHT(82, &FOLLOW_82_in_definedFun1392);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = false; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:595:7: '$remainder_e'
        	        	    {
        	        	         MATCHT(85, &FOLLOW_85_in_definedFun1402);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term d = SOLVER->mkVar(SOLVER->getRealSort(), "D");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n, d);
        	                  cvc5::Term expr = MK_TERM(cvc5::DIVISION, n, d);
        	                  expr = MK_TERM(cvc5::ITE,
        	                                 MK_TERM(cvc5::GEQ, d, SOLVER->mkReal(0)),
        	                                 MK_TERM(cvc5::TO_INTEGER, expr),
        	                                 MK_TERM(cvc5::NEG,
        	                                         MK_TERM(cvc5::TO_INTEGER,
        	                                                 MK_TERM(cvc5::NEG, expr))));
        	                  if (remainder)
        	                  {
        	                    expr = MK_TERM(
        	                        cvc5::TO_INTEGER,
        	                        MK_TERM(cvc5::SUB, n, MK_TERM(cvc5::MULT, expr, d)));
        	                  }
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:617:5: ( '$quotient_t' | '$remainder_t' )
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:617:5: ( '$quotient_t' | '$remainder_t' )
        	        {
        	            int alt32=2;
        	            switch ( LA(1) )
        	            {
        	            case 84:
        	            	{
        	            		alt32=1;
        	            	}
        	                break;
        	            case 87:
        	            	{
        	            		alt32=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 32;
        	                EXCEPTION->state        = 0;


        	                goto ruledefinedFunEx;

        	            }

        	            switch (alt32)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:617:7: '$quotient_t'
        	        	    {
        	        	         MATCHT(84, &FOLLOW_84_in_definedFun1424);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = false; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:618:7: '$remainder_t'
        	        	    {
        	        	         MATCHT(87, &FOLLOW_87_in_definedFun1434);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term d = SOLVER->mkVar(SOLVER->getRealSort(), "D");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n, d);
        	                  cvc5::Term expr = MK_TERM(cvc5::DIVISION, n, d);
        	                  expr = MK_TERM(cvc5::ITE,
        	                                 MK_TERM(cvc5::GEQ, expr, SOLVER->mkReal(0)),
        	                                 MK_TERM(cvc5::TO_INTEGER, expr),
        	                                 MK_TERM(cvc5::NEG,
        	                                         MK_TERM(cvc5::TO_INTEGER,
        	                                                 MK_TERM(cvc5::NEG, expr))));
        	                  if (remainder)
        	                  {
        	                    expr = MK_TERM(
        	                        cvc5::TO_INTEGER,
        	                        MK_TERM(cvc5::SUB, n, MK_TERM(cvc5::MULT, expr, d)));
        	                  }
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:640:5: ( '$quotient_f' | '$remainder_f' )
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:640:5: ( '$quotient_f' | '$remainder_f' )
        	        {
        	            int alt33=2;
        	            switch ( LA(1) )
        	            {
        	            case 83:
        	            	{
        	            		alt33=1;
        	            	}
        	                break;
        	            case 86:
        	            	{
        	            		alt33=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 33;
        	                EXCEPTION->state        = 0;


        	                goto ruledefinedFunEx;

        	            }

        	            switch (alt33)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:640:7: '$quotient_f'
        	        	    {
        	        	         MATCHT(83, &FOLLOW_83_in_definedFun1456);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = false; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:641:7: '$remainder_f'
        	        	    {
        	        	         MATCHT(86, &FOLLOW_86_in_definedFun1466);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledefinedFunEx;
        	        	        }


        	        	        {
        	        	             remainder = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term d = SOLVER->mkVar(SOLVER->getRealSort(), "D");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n, d);
        	                  cvc5::Term expr = MK_TERM(cvc5::DIVISION, n, d);
        	                  expr = MK_TERM(cvc5::TO_INTEGER, expr);
        	                  if (remainder)
        	                  {
        	                    expr = MK_TERM(cvc5::TO_INTEGER,
        	                                   MK_TERM(cvc5::SUB, n, MK_TERM(cvc5::MULT, expr, d)));
        	                  }
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:657:5: '$floor'
        	    {
        	         MATCHT(66, &FOLLOW_66_in_definedFun1486);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::TO_INTEGER;
        	                
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:661:5: '$ceiling'
        	    {
        	         MATCHT(63, &FOLLOW_63_in_definedFun1498);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n);
        	                  cvc5::Term expr = MK_TERM(cvc5::NEG,
        	                                      MK_TERM(cvc5::TO_INTEGER, MK_TERM(cvc5::NEG, n)));
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:670:5: '$truncate'
        	    {
        	         MATCHT(94, &FOLLOW_94_in_definedFun1510);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n);
        	                  cvc5::Term expr =
        	                      MK_TERM(cvc5::ITE,
        	                              MK_TERM(cvc5::GEQ, n, SOLVER->mkReal(0)),
        	                              MK_TERM(cvc5::TO_INTEGER, n),
        	                              MK_TERM(cvc5::NEG,
        	                                      MK_TERM(cvc5::TO_INTEGER, MK_TERM(cvc5::NEG, n))));
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                
        	        }


        	    }
        	    break;
        	case 13:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:683:5: '$round'
        	    {
        	         MATCHT(88, &FOLLOW_88_in_definedFun1522);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  cvc5::Term n = SOLVER->mkVar(SOLVER->getRealSort(), "N");
        	                  cvc5::Term formals = MK_TERM(cvc5::VARIABLE_LIST, n);
        	                  cvc5::Term decPart = MK_TERM(cvc5::SUB, n, MK_TERM(cvc5::TO_INTEGER, n));
        	                  cvc5::Term expr = MK_TERM(
        	                      cvc5::ITE,
        	                      MK_TERM(cvc5::LT, decPart, SOLVER->mkReal(1, 2)),
        	                      // if decPart < 0.5, round down
        	                      MK_TERM(cvc5::TO_INTEGER, n),
        	                      MK_TERM(cvc5::ITE,
        	                              MK_TERM(cvc5::GT, decPart, SOLVER->mkReal(1, 2)),
        	                              // if decPart > 0.5, round up
        	                              MK_TERM(cvc5::TO_INTEGER,
        	                                      MK_TERM(cvc5::ADD, n, SOLVER->mkReal(1))),
        	                              // if decPart == 0.5, round to nearest even integer:
        	                              // result is: to_int(n/2 + .5) * 2
        	                              MK_TERM(cvc5::MULT,
        	                                      MK_TERM(cvc5::TO_INTEGER,
        	                                              MK_TERM(cvc5::ADD,
        	                                                      MK_TERM(cvc5::DIVISION,
        	                                                              n,
        	                                                              SOLVER->mkReal(2)),
        	                                                      SOLVER->mkReal(1, 2))),
        	                                      SOLVER->mkInteger(2))));
        	                  p.d_kind = cvc5::LAMBDA;
        	                  p.d_expr = MK_TERM(cvc5::LAMBDA, formals, expr);
        	                  
        	        }


        	    }
        	    break;
        	case 14:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:711:5: '$to_int'
        	    {
        	         MATCHT(91, &FOLLOW_91_in_definedFun1534);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::TO_INTEGER;
        	                
        	        }


        	    }
        	    break;
        	case 15:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:715:5: '$to_rat'
        	    {
        	         MATCHT(92, &FOLLOW_92_in_definedFun1546);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::TO_REAL;
        	                
        	        }


        	    }
        	    break;
        	case 16:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:719:5: '$to_real'
        	    {
        	         MATCHT(93, &FOLLOW_93_in_definedFun1558);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefinedFunEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::TO_REAL;
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledefinedFunEx; /* Prevent compiler warnings */
    ruledefinedFunEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end definedFun */

/**
 * $ANTLR start equalOp
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:728:1: equalOp[bool& equal] : ( EQUAL_TOK | DISEQUAL_TOK );
 */
static void
equalOp(pTptpParser ctx, bool& equal)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:729:3: ( EQUAL_TOK | DISEQUAL_TOK )

            ANTLR3_UINT32 alt35;

            alt35=2;

            switch ( LA(1) )
            {
            case EQUAL_TOK:
            	{
            		alt35=1;
            	}
                break;
            case DISEQUAL_TOK:
            	{
            		alt35=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 35;
                EXCEPTION->state        = 0;


                goto ruleequalOpEx;

            }

            switch (alt35)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:729:5: EQUAL_TOK
        	    {
        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_equalOp1581);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleequalOpEx;
        	        }


        	        {
        	             equal = true; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:730:5: DISEQUAL_TOK
        	    {
        	         MATCHT(DISEQUAL_TOK, &FOLLOW_DISEQUAL_TOK_in_equalOp1592);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleequalOpEx;
        	        }


        	        {
        	             equal = false; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleequalOpEx; /* Prevent compiler warnings */
    ruleequalOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end equalOp */

/**
 * $ANTLR start term
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:733:1: term[cvc5::Term& expr] : ( functionTerm[expr] | conditionalTerm[expr] | simpleTerm[expr] | letTerm[expr] );
 */
static void
term(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:734:3: ( functionTerm[expr] | conditionalTerm[expr] | simpleTerm[expr] | letTerm[expr] )

            ANTLR3_UINT32 alt36;

            alt36=4;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            case 63:
            case 64:
            case 66:
            case 71:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt36=1;
            	}
                break;
            case 73:
            	{
            		alt36=2;
            	}
                break;
            case DISTINCT_OBJECT:
            case NUMBER:
            case UPPER_WORD:
            	{
            		alt36=3;
            	}
                break;
            case 77:
            case 79:
            	{
            		alt36=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 36;
                EXCEPTION->state        = 0;


                goto ruletermEx;

            }

            switch (alt36)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:734:5: functionTerm[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_functionTerm_in_term1608);
        	        functionTerm(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:735:5: conditionalTerm[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_conditionalTerm_in_term1615);
        	        conditionalTerm(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:736:5: simpleTerm[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleTerm_in_term1622);
        	        simpleTerm(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:737:5: letTerm[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_letTerm_in_term1629);
        	        letTerm(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start letTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:740:1: letTerm[cvc5::Term& expr] : ( '$let_ft' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK | '$let_tt' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK );
 */
static void
letTerm(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Term lhs, rhs;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:744:3: ( '$let_ft' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK | '$let_tt' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK )

            ANTLR3_UINT32 alt37;

            alt37=2;

            switch ( LA(1) )
            {
            case 77:
            	{
            		alt37=1;
            	}
                break;
            case 79:
            	{
            		alt37=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto ruleletTermEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:744:5: '$let_ft' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK
        	    {
        	         MATCHT(77, &FOLLOW_77_in_letTerm1649);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_letTerm1651);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetFormulaDefn_in_letTerm1659);
        	        tffLetFormulaDefn(ctx, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_letTerm1662);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_letTerm1668);
        	        term(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = expr.substitute(lhs, rhs);
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_letTerm1681);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:751:5: '$let_tt' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK term[expr] RPAREN_TOK
        	    {
        	         MATCHT(79, &FOLLOW_79_in_letTerm1687);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_letTerm1689);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetTermDefn_in_letTerm1697);
        	        tffLetTermDefn(ctx, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_letTerm1700);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_letTerm1706);
        	        term(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = expr.substitute(lhs, rhs);
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_letTerm1719);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleletTermEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleletTermEx; /* Prevent compiler warnings */
    ruleletTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end letTerm */

/**
 * $ANTLR start simpleTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:761:1: simpleTerm[cvc5::Term& expr] : ( variable[expr] | NUMBER | DISTINCT_OBJECT );
 */
static void
simpleTerm(pTptpParser ctx, cvc5::Term& expr)
{
    pANTLR3_COMMON_TOKEN    DISTINCT_OBJECT2;

    /* Initialize rule variables
     */

    DISTINCT_OBJECT2       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:762:3: ( variable[expr] | NUMBER | DISTINCT_OBJECT )

            ANTLR3_UINT32 alt38;

            alt38=3;

            switch ( LA(1) )
            {
            case UPPER_WORD:
            	{
            		alt38=1;
            	}
                break;
            case NUMBER:
            	{
            		alt38=2;
            	}
                break;
            case DISTINCT_OBJECT:
            	{
            		alt38=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto rulesimpleTermEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:762:5: variable[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_variable_in_simpleTerm1735);
        	        variable(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:763:5: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_simpleTerm1742);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }


        	        {
        	             expr = PARSER_STATE->d_tmp_expr; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:764:5: DISTINCT_OBJECT
        	    {
        	        DISTINCT_OBJECT2 = (pANTLR3_COMMON_TOKEN) MATCHT(DISTINCT_OBJECT, &FOLLOW_DISTINCT_OBJECT_in_simpleTerm1750);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTermEx;
        	        }


        	        {
        	             expr = PARSER_STATE->convertStrToUnsorted(AntlrInput::tokenText(DISTINCT_OBJECT2)); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleTermEx; /* Prevent compiler warnings */
    rulesimpleTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleTerm */

/**
 * $ANTLR start thfSimpleTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:768:1: thfSimpleTerm[cvc5::Term& expr] : ( NUMBER | DISTINCT_OBJECT );
 */
static void
thfSimpleTerm(pTptpParser ctx, cvc5::Term& expr)
{
    pANTLR3_COMMON_TOKEN    DISTINCT_OBJECT3;

    /* Initialize rule variables
     */

    DISTINCT_OBJECT3       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:769:3: ( NUMBER | DISTINCT_OBJECT )

            ANTLR3_UINT32 alt39;

            alt39=2;

            switch ( LA(1) )
            {
            case NUMBER:
            	{
            		alt39=1;
            	}
                break;
            case DISTINCT_OBJECT:
            	{
            		alt39=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulethfSimpleTermEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:769:5: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_thfSimpleTerm1768);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfSimpleTermEx;
        	        }


        	        {
        	             expr = PARSER_STATE->d_tmp_expr; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:770:5: DISTINCT_OBJECT
        	    {
        	        DISTINCT_OBJECT3 = (pANTLR3_COMMON_TOKEN) MATCHT(DISTINCT_OBJECT, &FOLLOW_DISTINCT_OBJECT_in_thfSimpleTerm1776);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfSimpleTermEx;
        	        }


        	        {

        	                  expr = PARSER_STATE->convertStrToUnsorted(
        	                      AntlrInput::tokenText(DISTINCT_OBJECT3));
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfSimpleTermEx; /* Prevent compiler warnings */
    rulethfSimpleTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfSimpleTerm */

/**
 * $ANTLR start functionTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:777:1: functionTerm[cvc5::Term& expr] : ( plainTerm[expr] | definedFun[p] LPAREN_TOK arguments[args] RPAREN_TOK );
 */
static void
functionTerm(pTptpParser ctx, cvc5::Term& expr)
{

      std::vector<cvc5::Term> args;
      ParseOp p;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:782:3: ( plainTerm[expr] | definedFun[p] LPAREN_TOK arguments[args] RPAREN_TOK )

            ANTLR3_UINT32 alt40;

            alt40=2;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt40=1;
            	}
                break;
            case 63:
            case 64:
            case 66:
            case 71:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt40=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 40;
                EXCEPTION->state        = 0;


                goto rulefunctionTermEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:782:5: plainTerm[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_plainTerm_in_functionTerm1801);
        	        plainTerm(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunctionTermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:783:5: definedFun[p] LPAREN_TOK arguments[args] RPAREN_TOK
        	    {
        	        FOLLOWPUSH(FOLLOW_definedFun_in_functionTerm1808);
        	        definedFun(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunctionTermEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_functionTerm1811);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunctionTermEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_arguments_in_functionTerm1813);
        	        arguments(ctx, args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunctionTermEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_functionTerm1816);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunctionTermEx;
        	        }


        	        {

        	                  expr = PARSER_STATE->applyParseOp(p, args);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefunctionTermEx; /* Prevent compiler warnings */
    rulefunctionTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionTerm */

/**
 * $ANTLR start conditionalTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:789:1: conditionalTerm[cvc5::Term& expr] : '$ite_t' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK term[expr2] COMMA_TOK term[expr3] RPAREN_TOK ;
 */
static void
conditionalTerm(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Term expr2, expr3;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:793:3: ( '$ite_t' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK term[expr2] COMMA_TOK term[expr3] RPAREN_TOK )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:793:5: '$ite_t' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK term[expr2] COMMA_TOK term[expr3] RPAREN_TOK
        {
             MATCHT(73, &FOLLOW_73_in_conditionalTerm1841);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_conditionalTerm1843);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


            FOLLOWPUSH(FOLLOW_tffLogicFormula_in_conditionalTerm1845);
            tffLogicFormula(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


             MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_conditionalTerm1848);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


            FOLLOWPUSH(FOLLOW_term_in_conditionalTerm1850);
            term(ctx, expr2);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


             MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_conditionalTerm1853);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


            FOLLOWPUSH(FOLLOW_term_in_conditionalTerm1855);
            term(ctx, expr3);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_conditionalTerm1858);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalTermEx;
            }


            {
                 expr = MK_TERM(cvc5::ITE, expr, expr2, expr3); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconditionalTermEx; /* Prevent compiler warnings */
    ruleconditionalTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end conditionalTerm */

/**
 * $ANTLR start plainTerm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:797:1: plainTerm[cvc5::Term& expr] : atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? ;
 */
static void
plainTerm(pTptpParser ctx, cvc5::Term& expr)
{

      std::string name;
      std::vector<cvc5::Term> args;
      ParseOp p;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:803:3: ( atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:803:5: atomicWord[p.d_name] ( LPAREN_TOK arguments[args] RPAREN_TOK )?
        {
            FOLLOWPUSH(FOLLOW_atomicWord_in_plainTerm1883);
            atomicWord(ctx, p.d_name);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplainTermEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:803:26: ( LPAREN_TOK arguments[args] RPAREN_TOK )?
            {
                int alt41=2;
                switch ( LA(1) )
                {
                    case LPAREN_TOK:
                    	{
                    		alt41=1;
                    	}
                        break;
                }

                switch (alt41)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:803:27: LPAREN_TOK arguments[args] RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_plainTerm1887);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleplainTermEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_arguments_in_plainTerm1889);
            	        arguments(ctx, args);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleplainTermEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_plainTerm1892);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleplainTermEx;
            	        }


            	    }
            	    break;

                }
            }

            {

                      expr = args.empty() ? PARSER_STATE->parseOpToExpr(p)
                                          : PARSER_STATE->applyParseOp(p, args);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleplainTermEx; /* Prevent compiler warnings */
    ruleplainTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end plainTerm */

/**
 * $ANTLR start arguments
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:810:1: arguments[std::vector<cvc5::Term>& args] : term[expr] ( COMMA_TOK term[expr] )* ;
 */
static void
arguments(pTptpParser ctx, std::vector<cvc5::Term>& args)
{

      cvc5::Term expr;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:814:3: ( term[expr] ( COMMA_TOK term[expr] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:815:3: term[expr] ( COMMA_TOK term[expr] )*
        {
            FOLLOWPUSH(FOLLOW_term_in_arguments1921);
            term(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleargumentsEx;
            }


            {
                 args.push_back(expr); 
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:815:40: ( COMMA_TOK term[expr] )*

            for (;;)
            {
                int alt42=2;
                switch ( LA(1) )
                {
                case COMMA_TOK:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:815:42: COMMA_TOK term[expr]
            	    {
            	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_arguments1928);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargumentsEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_term_in_arguments1930);
            	        term(ctx, expr);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleargumentsEx;
            	        }


            	        {
            	             args.push_back(expr); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleargumentsEx; /* Prevent compiler warnings */
    ruleargumentsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end arguments */

/**
 * $ANTLR start variable
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:818:1: variable[cvc5::Term& expr] : UPPER_WORD ;
 */
static void
variable(pTptpParser ctx, cvc5::Term& expr)
{
    pANTLR3_COMMON_TOKEN    UPPER_WORD4;

    /* Initialize rule variables
     */

    UPPER_WORD4       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:819:3: ( UPPER_WORD )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:819:5: UPPER_WORD
        {
            UPPER_WORD4 = (pANTLR3_COMMON_TOKEN) MATCHT(UPPER_WORD, &FOLLOW_UPPER_WORD_in_variable1950);
            if  (HASEXCEPTION())
            {
                goto rulevariableEx;
            }


            {

                      std::string name = AntlrInput::tokenText(UPPER_WORD4);
                      if(!PARSER_STATE->cnf() || PARSER_STATE->isDeclared(name)) {
                        expr = PARSER_STATE->getVariable(name);
                      } else {
                        expr = PARSER_STATE->bindBoundVar(name, PARSER_STATE->d_unsorted);
                        if(PARSER_STATE->cnf()) PARSER_STATE->addFreeVar(expr);
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariableEx; /* Prevent compiler warnings */
    rulevariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end variable */

/**
 * $ANTLR start fofFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:833:1: fofFormula[cvc5::Term& expr] : fofLogicFormula[expr] ;
 */
static void
fofFormula(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:833:30: ( fofLogicFormula[expr] )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:833:32: fofLogicFormula[expr]
        {
            FOLLOWPUSH(FOLLOW_fofLogicFormula_in_fofFormula1974);
            fofLogicFormula(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefofFormulaEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefofFormulaEx; /* Prevent compiler warnings */
    rulefofFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end fofFormula */

/**
 * $ANTLR start fofLogicFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:835:1: fofLogicFormula[cvc5::Term& expr] : fofUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] ) | ( ( AND_TOK fofUnitaryFormula[expr] )+ ) | ( ( OR_TOK fofUnitaryFormula[expr] )+ ) )? ;
 */
static void
fofLogicFormula(pTptpParser ctx, cvc5::Term& expr)
{

      tptp::NonAssoc na;
      std::vector< cvc5::Term > args;
      cvc5::Term expr2;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:841:3: ( fofUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] ) | ( ( AND_TOK fofUnitaryFormula[expr] )+ ) | ( ( OR_TOK fofUnitaryFormula[expr] )+ ) )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:841:5: fofUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] ) | ( ( AND_TOK fofUnitaryFormula[expr] )+ ) | ( ( OR_TOK fofUnitaryFormula[expr] )+ ) )?
        {
            FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofLogicFormula1992);
            fofUnitaryFormula(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefofLogicFormulaEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:842:5: ( ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] ) | ( ( AND_TOK fofUnitaryFormula[expr] )+ ) | ( ( OR_TOK fofUnitaryFormula[expr] )+ ) )?
            {
                int alt45=4;
                switch ( LA(1) )
                {
                    case IFF_TOK:
                    case IMPLIES_TOK:
                    case REVAND_TOK:
                    case REVIFF_TOK:
                    case REVIMPLIES_TOK:
                    case REVOR_TOK:
                    	{
                    		alt45=1;
                    	}
                        break;
                    case AND_TOK:
                    	{
                    		alt45=2;
                    	}
                        break;
                    case OR_TOK:
                    	{
                    		alt45=3;
                    	}
                        break;
                }

                switch (alt45)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:843:7: ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:843:7: ( fofBinaryNonAssoc[na] fofUnitaryFormula[expr2] )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:843:9: fofBinaryNonAssoc[na] fofUnitaryFormula[expr2]
            	        {
            	            FOLLOWPUSH(FOLLOW_fofBinaryNonAssoc_in_fofLogicFormula2010);
            	            fofBinaryNonAssoc(ctx, na);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefofLogicFormulaEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofLogicFormula2013);
            	            fofUnitaryFormula(ctx, expr2);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulefofLogicFormulaEx;
            	            }


            	            {
            	                 switch(na) {
            	                           case tptp::NA_IFF:
            	                             expr = MK_TERM(cvc5::EQUAL,expr,expr2);
            	                             break;
            	                           case tptp::NA_REVIFF:
            	                             expr = MK_TERM(cvc5::XOR,expr,expr2);
            	                             break;
            	                           case tptp::NA_IMPLIES:
            	                             expr = MK_TERM(cvc5::IMPLIES,expr,expr2);
            	                             break;
            	                           case tptp::NA_REVIMPLIES:
            	                             expr = MK_TERM(cvc5::IMPLIES,expr2,expr);
            	                             break;
            	                           case tptp::NA_REVOR:
            	                             expr = MK_TERM(cvc5::NOT,MK_TERM(cvc5::OR,expr,expr2));
            	                             break;
            	                           case tptp::NA_REVAND:
            	                             expr = MK_TERM(cvc5::NOT,MK_TERM(cvc5::AND,expr,expr2));
            	                             break;
            	                          }
            	                        
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:867:7: ( ( AND_TOK fofUnitaryFormula[expr] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:867:7: ( ( AND_TOK fofUnitaryFormula[expr] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:867:9: ( AND_TOK fofUnitaryFormula[expr] )+
            	        {
            	            {
            	                 args.push_back(expr); 
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:868:9: ( AND_TOK fofUnitaryFormula[expr] )+
            	            {
            	                int cnt43=0;

            	                for (;;)
            	                {
            	                    int alt43=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case AND_TOK:
            	            		{
            	            			alt43=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt43)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:868:11: AND_TOK fofUnitaryFormula[expr]
            	            	        {
            	            	             MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_fofLogicFormula2061);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulefofLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofLogicFormula2063);
            	            	            fofUnitaryFormula(ctx, expr);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulefofLogicFormulaEx;
            	            	            }


            	            	            {
            	            	                 args.push_back(expr); 
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt43 >= 1 )
            	            		{
            	            		    goto loop43;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulefofLogicFormulaEx;
            	            	}
            	            	cnt43++;
            	                }
            	                loop43: ;	/* Jump to here if this rule does not match */
            	            }

            	            {
            	                 expr = MK_TERM(cvc5::AND, args); 
            	            }


            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:872:7: ( ( OR_TOK fofUnitaryFormula[expr] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:872:7: ( ( OR_TOK fofUnitaryFormula[expr] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:872:9: ( OR_TOK fofUnitaryFormula[expr] )+
            	        {
            	            {
            	                 args.push_back(expr); 
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:873:9: ( OR_TOK fofUnitaryFormula[expr] )+
            	            {
            	                int cnt44=0;

            	                for (;;)
            	                {
            	                    int alt44=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case OR_TOK:
            	            		{
            	            			alt44=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt44)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:873:11: OR_TOK fofUnitaryFormula[expr]
            	            	        {
            	            	             MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_fofLogicFormula2116);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulefofLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofLogicFormula2118);
            	            	            fofUnitaryFormula(ctx, expr);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulefofLogicFormulaEx;
            	            	            }


            	            	            {
            	            	                 args.push_back(expr); 
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt44 >= 1 )
            	            		{
            	            		    goto loop44;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulefofLogicFormulaEx;
            	            	}
            	            	cnt44++;
            	                }
            	                loop44: ;	/* Jump to here if this rule does not match */
            	            }

            	            {
            	                 expr = MK_TERM(cvc5::OR, args); 
            	            }


            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefofLogicFormulaEx; /* Prevent compiler warnings */
    rulefofLogicFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end fofLogicFormula */

/**
 * $ANTLR start fofUnitaryFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:879:1: fofUnitaryFormula[cvc5::Term& expr] : ( atomicFormula[expr] | LPAREN_TOK fofLogicFormula[expr] RPAREN_TOK | NOT_TOK fofUnitaryFormula[expr] | folQuantifier[kind] LBRACK_TOK ( bindvariable[expr] ( COMMA_TOK bindvariable[expr] )* ) RBRACK_TOK COLON_TOK fofUnitaryFormula[expr] );
 */
static void
fofUnitaryFormula(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Kind kind;
      std::vector< cvc5::Term > bv;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:884:3: ( atomicFormula[expr] | LPAREN_TOK fofLogicFormula[expr] RPAREN_TOK | NOT_TOK fofUnitaryFormula[expr] | folQuantifier[kind] LBRACK_TOK ( bindvariable[expr] ( COMMA_TOK bindvariable[expr] )* ) RBRACK_TOK COLON_TOK fofUnitaryFormula[expr] )

            ANTLR3_UINT32 alt47;

            alt47=4;

            switch ( LA(1) )
            {
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt47=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt47=2;
            	}
                break;
            case NOT_TOK:
            	{
            		alt47=3;
            	}
                break;
            case EXISTS_TOK:
            case FORALL_TOK:
            	{
            		alt47=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 47;
                EXCEPTION->state        = 0;


                goto rulefofUnitaryFormulaEx;

            }

            switch (alt47)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:884:5: atomicFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicFormula_in_fofUnitaryFormula2168);
        	        atomicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:885:5: LPAREN_TOK fofLogicFormula[expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_fofUnitaryFormula2175);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_fofLogicFormula_in_fofUnitaryFormula2177);
        	        fofLogicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_fofUnitaryFormula2180);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:886:5: NOT_TOK fofUnitaryFormula[expr]
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_fofUnitaryFormula2186);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2188);
        	        fofUnitaryFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        {
        	             expr = MK_TERM(cvc5::NOT,expr); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:888:5: folQuantifier[kind] LBRACK_TOK ( bindvariable[expr] ( COMMA_TOK bindvariable[expr] )* ) RBRACK_TOK COLON_TOK fofUnitaryFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_folQuantifier_in_fofUnitaryFormula2202);
        	        folQuantifier(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_fofUnitaryFormula2205);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        {
        	            PARSER_STATE->pushScope();
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:889:5: ( bindvariable[expr] ( COMMA_TOK bindvariable[expr] )* )
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:889:7: bindvariable[expr] ( COMMA_TOK bindvariable[expr] )*
        	        {
        	            FOLLOWPUSH(FOLLOW_bindvariable_in_fofUnitaryFormula2215);
        	            bindvariable(ctx, expr);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefofUnitaryFormulaEx;
        	            }


        	            {
        	                 bv.push_back(expr); 
        	            }


        	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:890:7: ( COMMA_TOK bindvariable[expr] )*

        	            for (;;)
        	            {
        	                int alt46=2;
        	                switch ( LA(1) )
        	                {
        	                case COMMA_TOK:
        	                	{
        	                		alt46=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt46)
        	                {
        	            	case 1:
        	            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:890:9: COMMA_TOK bindvariable[expr]
        	            	    {
        	            	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_fofUnitaryFormula2228);
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulefofUnitaryFormulaEx;
        	            	        }


        	            	        FOLLOWPUSH(FOLLOW_bindvariable_in_fofUnitaryFormula2230);
        	            	        bindvariable(ctx, expr);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulefofUnitaryFormulaEx;
        	            	        }


        	            	        {
        	            	             bv.push_back(expr); 
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop46;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop46: ; /* Jump out to here if this rule does not match */


        	        }


        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_fofUnitaryFormula2240);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_fofUnitaryFormula2246);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_fofUnitaryFormula_in_fofUnitaryFormula2248);
        	        fofUnitaryFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = MK_TERM(kind, MK_TERM(cvc5::VARIABLE_LIST, bv), expr);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefofUnitaryFormulaEx; /* Prevent compiler warnings */
    rulefofUnitaryFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end fofUnitaryFormula */

/**
 * $ANTLR start bindvariable
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:897:1: bindvariable[cvc5::Term& expr] : UPPER_WORD ;
 */
static void
bindvariable(pTptpParser ctx, cvc5::Term& expr)
{
    pANTLR3_COMMON_TOKEN    UPPER_WORD5;

    /* Initialize rule variables
     */

    UPPER_WORD5       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:898:3: ( UPPER_WORD )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:898:5: UPPER_WORD
        {
            UPPER_WORD5 = (pANTLR3_COMMON_TOKEN) MATCHT(UPPER_WORD, &FOLLOW_UPPER_WORD_in_bindvariable2269);
            if  (HASEXCEPTION())
            {
                goto rulebindvariableEx;
            }


            {
                 std::string name = AntlrInput::tokenText(UPPER_WORD5);
                      expr = PARSER_STATE->bindBoundVar(name, PARSER_STATE->d_unsorted);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebindvariableEx; /* Prevent compiler warnings */
    rulebindvariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bindvariable */

/**
 * $ANTLR start fofBinaryNonAssoc
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:904:1: fofBinaryNonAssoc[cvc5::parser::tptp::NonAssoc& na] : ( IFF_TOK | REVIFF_TOK | REVOR_TOK | REVAND_TOK | IMPLIES_TOK | REVIMPLIES_TOK );
 */
static void
fofBinaryNonAssoc(pTptpParser ctx, cvc5::parser::tptp::NonAssoc& na)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:905:3: ( IFF_TOK | REVIFF_TOK | REVOR_TOK | REVAND_TOK | IMPLIES_TOK | REVIMPLIES_TOK )

            ANTLR3_UINT32 alt48;

            alt48=6;

            switch ( LA(1) )
            {
            case IFF_TOK:
            	{
            		alt48=1;
            	}
                break;
            case REVIFF_TOK:
            	{
            		alt48=2;
            	}
                break;
            case REVOR_TOK:
            	{
            		alt48=3;
            	}
                break;
            case REVAND_TOK:
            	{
            		alt48=4;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt48=5;
            	}
                break;
            case REVIMPLIES_TOK:
            	{
            		alt48=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 48;
                EXCEPTION->state        = 0;


                goto rulefofBinaryNonAssocEx;

            }

            switch (alt48)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:905:5: IFF_TOK
        	    {
        	         MATCHT(IFF_TOK, &FOLLOW_IFF_TOK_in_fofBinaryNonAssoc2289);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_IFF; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:906:5: REVIFF_TOK
        	    {
        	         MATCHT(REVIFF_TOK, &FOLLOW_REVIFF_TOK_in_fofBinaryNonAssoc2302);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_REVIFF; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:907:5: REVOR_TOK
        	    {
        	         MATCHT(REVOR_TOK, &FOLLOW_REVOR_TOK_in_fofBinaryNonAssoc2312);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_REVOR; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:908:5: REVAND_TOK
        	    {
        	         MATCHT(REVAND_TOK, &FOLLOW_REVAND_TOK_in_fofBinaryNonAssoc2323);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_REVAND; 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:909:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_fofBinaryNonAssoc2333);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_IMPLIES; 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:910:5: REVIMPLIES_TOK
        	    {
        	         MATCHT(REVIMPLIES_TOK, &FOLLOW_REVIMPLIES_TOK_in_fofBinaryNonAssoc2344);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefofBinaryNonAssocEx;
        	        }


        	        {
        	             na = tptp::NA_REVIMPLIES; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefofBinaryNonAssocEx; /* Prevent compiler warnings */
    rulefofBinaryNonAssocEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end fofBinaryNonAssoc */

/**
 * $ANTLR start folQuantifier
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:913:1: folQuantifier[cvc5::Kind& kind] : ( FORALL_TOK | EXISTS_TOK );
 */
static void
folQuantifier(pTptpParser ctx, cvc5::Kind& kind)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:914:3: ( FORALL_TOK | EXISTS_TOK )

            ANTLR3_UINT32 alt49;

            alt49=2;

            switch ( LA(1) )
            {
            case FORALL_TOK:
            	{
            		alt49=1;
            	}
                break;
            case EXISTS_TOK:
            	{
            		alt49=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 49;
                EXCEPTION->state        = 0;


                goto rulefolQuantifierEx;

            }

            switch (alt49)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:914:5: FORALL_TOK
        	    {
        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_folQuantifier2360);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefolQuantifierEx;
        	        }


        	        {
        	             kind = cvc5::FORALL; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:915:5: EXISTS_TOK
        	    {
        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_folQuantifier2368);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefolQuantifierEx;
        	        }


        	        {
        	             kind = cvc5::EXISTS; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefolQuantifierEx; /* Prevent compiler warnings */
    rulefolQuantifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end folQuantifier */

/**
 * $ANTLR start thfQuantifier
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:921:1: thfQuantifier[cvc5::Kind& kind] : ( FORALL_TOK | EXISTS_TOK | LAMBDA_TOK | CHOICE_TOK | DEF_DESC_TOK | ( TH1_UN_A | TH1_UN_E ) );
 */
static void
thfQuantifier(pTptpParser ctx, cvc5::Kind& kind)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:922:3: ( FORALL_TOK | EXISTS_TOK | LAMBDA_TOK | CHOICE_TOK | DEF_DESC_TOK | ( TH1_UN_A | TH1_UN_E ) )

            ANTLR3_UINT32 alt50;

            alt50=6;

            switch ( LA(1) )
            {
            case FORALL_TOK:
            	{
            		alt50=1;
            	}
                break;
            case EXISTS_TOK:
            	{
            		alt50=2;
            	}
                break;
            case LAMBDA_TOK:
            	{
            		alt50=3;
            	}
                break;
            case CHOICE_TOK:
            	{
            		alt50=4;
            	}
                break;
            case DEF_DESC_TOK:
            	{
            		alt50=5;
            	}
                break;
            case TH1_UN_A:
            case TH1_UN_E:
            	{
            		alt50=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 50;
                EXCEPTION->state        = 0;


                goto rulethfQuantifierEx;

            }

            switch (alt50)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:922:5: FORALL_TOK
        	    {
        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_thfQuantifier2389);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfQuantifierEx;
        	        }


        	        {
        	             kind = cvc5::FORALL; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:923:5: EXISTS_TOK
        	    {
        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_thfQuantifier2397);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfQuantifierEx;
        	        }


        	        {
        	             kind = cvc5::EXISTS; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:924:5: LAMBDA_TOK
        	    {
        	         MATCHT(LAMBDA_TOK, &FOLLOW_LAMBDA_TOK_in_thfQuantifier2405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfQuantifierEx;
        	        }


        	        {
        	             kind = cvc5::LAMBDA; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:925:5: CHOICE_TOK
        	    {
        	         MATCHT(CHOICE_TOK, &FOLLOW_CHOICE_TOK_in_thfQuantifier2413);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfQuantifierEx;
        	        }


        	        {

        	                  UNSUPPORTED("Choice operator");
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:929:5: DEF_DESC_TOK
        	    {
        	         MATCHT(DEF_DESC_TOK, &FOLLOW_DEF_DESC_TOK_in_thfQuantifier2425);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfQuantifierEx;
        	        }


        	        {

        	                  UNSUPPORTED("Description quantifier");
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:933:5: ( TH1_UN_A | TH1_UN_E )
        	    {
        	        if ( ((LA(1) >= TH1_UN_A) && (LA(1) <= TH1_UN_E)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulethfQuantifierEx;
        	        }


        	        {

        	                  UNSUPPORTED("TH1 operator");
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfQuantifierEx; /* Prevent compiler warnings */
    rulethfQuantifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfQuantifier */

/**
 * $ANTLR start thfAtomTyping
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:939:1: thfAtomTyping[std::unique_ptr<cvc5::parser::Command>& cmd] : ( LPAREN_TOK thfAtomTyping[cmd] RPAREN_TOK | nameN[name] COLON_TOK ( '$tType' | parseThfType[type] ) );
 */
static void
thfAtomTyping(pTptpParser ctx, std::unique_ptr<cvc5::parser::Command>& cmd)
{

      cvc5::Term expr;
      cvc5::Sort type;
      std::string name;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:946:3: ( LPAREN_TOK thfAtomTyping[cmd] RPAREN_TOK | nameN[name] COLON_TOK ( '$tType' | parseThfType[type] ) )

            ANTLR3_UINT32 alt52;

            alt52=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt52=1;
            	}
                break;
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt52=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 52;
                EXCEPTION->state        = 0;


                goto rulethfAtomTypingEx;

            }

            switch (alt52)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:946:5: LPAREN_TOK thfAtomTyping[cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfAtomTyping2469);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomTypingEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_thfAtomTyping_in_thfAtomTyping2471);
        	        thfAtomTyping(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomTypingEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfAtomTyping2474);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomTypingEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:947:5: nameN[name] COLON_TOK ( '$tType' | parseThfType[type] )
        	    {
        	        FOLLOWPUSH(FOLLOW_nameN_in_thfAtomTyping2480);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomTypingEx;
        	        }


        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_thfAtomTyping2483);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfAtomTypingEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:948:5: ( '$tType' | parseThfType[type] )
        	        {
        	            int alt51=2;
        	            switch ( LA(1) )
        	            {
        	            case 90:
        	            	{
        	            		alt51=1;
        	            	}
        	                break;
        	            case CNF_TOK:
        	            case DEFINED_SYMBOL:
        	            case FOF_TOK:
        	            case INCLUDE_TOK:
        	            case LBRACK_TOK:
        	            case LOWER_WORD:
        	            case LOWER_WORD_SINGLE_QUOTED:
        	            case LPAREN_TOK:
        	            case SINGLE_QUOTED:
        	            case TFF_TOK:
        	            case THF_TOK:
        	            case TYPE_TOK:
        	            	{
        	            		alt51=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 51;
        	                EXCEPTION->state        = 0;


        	                goto rulethfAtomTypingEx;

        	            }

        	            switch (alt51)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:948:7: '$tType'
        	        	    {
        	        	         MATCHT(90, &FOLLOW_90_in_thfAtomTyping2491);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomTypingEx;
        	        	        }


        	        	        {

        	        	                    if (PARSER_STATE->isDeclared(name, SYM_SORT))
        	        	                    {
        	        	                      // duplicate declaration is fine, they're compatible
        	        	                      cmd = std::make_unique<EmptyCommand>("compatible redeclaration of sort " + name);
        	        	                    }
        	        	                    else if (PARSER_STATE->isDeclared(name, SYM_VARIABLE))
        	        	                    {
        	        	                      // error: cannot be both sort and constant
        	        	                      PARSER_STATE->parseError(
        	        	                          "Symbol `" + name
        	        	                          + "' previously declared as a constant; cannot also be a sort");
        	        	                    }
        	        	                    else
        	        	                    {
        	        	                      // as yet, it's undeclared
        	        	                      cvc5::Sort atype = PARSER_STATE->mkSort(name);
        	        	                      cmd = std::make_unique<DeclareSortCommand>(name, 0, atype);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:969:7: parseThfType[type]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_parseThfType_in_thfAtomTyping2507);
        	        	        parseThfType(ctx, type);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfAtomTypingEx;
        	        	        }


        	        	        {

        	        	                    if (PARSER_STATE->isDeclared(name, SYM_SORT))
        	        	                    {
        	        	                      // error: cannot be both sort and constant
        	        	                      PARSER_STATE->parseError("Symbol `" + name
        	        	                                               + "' previously declared as a sort");
        	        	                      cmd = std::make_unique<EmptyCommand>("compatible redeclaration of sort " + name);
        	        	                    }
        	        	                    else if (PARSER_STATE->isDeclared(name, SYM_VARIABLE))
        	        	                    {
        	        	                      if (type == PARSER_STATE->getVariable(name).getSort())
        	        	                      {
        	        	                        // duplicate declaration is fine, they're compatible
        	        	                        cmd = std::make_unique<EmptyCommand>("compatible redeclaration of constant "
        	        	                                               + name);
        	        	                      }
        	        	                      else
        	        	                      {
        	        	                        // error: sorts incompatible
        	        	                        PARSER_STATE->parseError(
        	        	                            "Symbol `" + name
        	        	                            + "' declared previously with a different sort");
        	        	                      }
        	        	                    }
        	        	                    else
        	        	                    {
        	        	                      // as of yet, it's undeclared
        	        	                      cvc5::Term freshExpr;
        	        	                      if (type.isFunction())
        	        	                      {
        	        	                        freshExpr = PARSER_STATE->bindVar(name, type);
        	        	                      }
        	        	                      else
        	        	                      {
        	        	                        freshExpr = PARSER_STATE->bindVar(name, type);
        	        	                      }
        	        	                      cmd = std::make_unique<DeclareFunctionCommand>(name, freshExpr, type);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfAtomTypingEx; /* Prevent compiler warnings */
    rulethfAtomTypingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfAtomTyping */

/**
 * $ANTLR start thfLogicFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1012:1: thfLogicFormula[cvc5::ParseOp& p] : thfUnitaryFormula[p] ( equalOp[equal] thfUnitaryFormula[p1] | fofBinaryNonAssoc[na] thfUnitaryFormula[p1] | ( ( AND_TOK thfUnitaryFormula[p] )+ ) | ( ( OR_TOK thfUnitaryFormula[p] )+ ) | ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+ )? ;
 */
static void
thfLogicFormula(pTptpParser ctx, cvc5::ParseOp& p)
{

      tptp::NonAssoc na;
      std::vector<cvc5::Term> args;
      std::vector<ParseOp> p_args;
      cvc5::Term expr2;
      bool equal;
      ParseOp p1;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1023:3: ( thfUnitaryFormula[p] ( equalOp[equal] thfUnitaryFormula[p1] | fofBinaryNonAssoc[na] thfUnitaryFormula[p1] | ( ( AND_TOK thfUnitaryFormula[p] )+ ) | ( ( OR_TOK thfUnitaryFormula[p] )+ ) | ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+ )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1023:5: thfUnitaryFormula[p] ( equalOp[equal] thfUnitaryFormula[p1] | fofBinaryNonAssoc[na] thfUnitaryFormula[p1] | ( ( AND_TOK thfUnitaryFormula[p] )+ ) | ( ( OR_TOK thfUnitaryFormula[p] )+ ) | ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+ )?
        {
            FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2547);
            thfUnitaryFormula(ctx, p);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulethfLogicFormulaEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1024:5: ( equalOp[equal] thfUnitaryFormula[p1] | fofBinaryNonAssoc[na] thfUnitaryFormula[p1] | ( ( AND_TOK thfUnitaryFormula[p] )+ ) | ( ( OR_TOK thfUnitaryFormula[p] )+ ) | ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+ )?
            {
                int alt57=6;
                switch ( LA(1) )
                {
                    case DISEQUAL_TOK:
                    case EQUAL_TOK:
                    	{
                    		alt57=1;
                    	}
                        break;
                    case IFF_TOK:
                    case IMPLIES_TOK:
                    case REVAND_TOK:
                    case REVIFF_TOK:
                    case REVIMPLIES_TOK:
                    case REVOR_TOK:
                    	{
                    		alt57=2;
                    	}
                        break;
                    case AND_TOK:
                    	{
                    		alt57=3;
                    	}
                        break;
                    case OR_TOK:
                    	{
                    		alt57=4;
                    	}
                        break;
                    case APP_TOK:
                    	{
                    		alt57=5;
                    	}
                        break;
                }

                switch (alt57)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1025:7: equalOp[equal] thfUnitaryFormula[p1]
            	    {
            	        FOLLOWPUSH(FOLLOW_equalOp_in_thfLogicFormula2563);
            	        equalOp(ctx, equal);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfLogicFormulaEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2572);
            	        thfUnitaryFormula(ctx, p1);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfLogicFormulaEx;
            	        }


            	        {

            	                    if (p.d_expr.isNull() && !p1.d_expr.isNull())
            	                    {
            	                      // make p.d_expr with a lambda of the same type as p1.d_expr
            	                      p.d_expr =
            	                          PARSER_STATE->mkLambdaWrapper(p.d_kind, p1.d_expr.getSort());
            	                    }
            	                    else if (p1.d_expr.isNull() && !p.d_expr.isNull())
            	                    {
            	                      // make p1.d_expr with a lambda of the same type as p.d_expr
            	                      p1.d_expr =
            	                          PARSER_STATE->mkLambdaWrapper(p1.d_kind, p.d_expr.getSort());
            	                    }
            	                    else if (p.d_expr.isNull() && p1.d_expr.isNull())
            	                    {
            	                      // Without a reference type it's not possible in general to know what
            	                      // the lambda wrapping should be, so we fail in these cases
            	                      UNSUPPORTED("Equality between theory functions");
            	                    }
            	                    args.push_back(p.d_expr);
            	                    args.push_back(p1.d_expr);
            	                    p.d_expr = MK_TERM(cvc5::EQUAL, args);
            	                    if (!equal)
            	                    {
            	                      p.d_expr = MK_TERM(cvc5::NOT, p.d_expr);
            	                    }
            	                  
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1055:7: fofBinaryNonAssoc[na] thfUnitaryFormula[p1]
            	    {
            	        FOLLOWPUSH(FOLLOW_fofBinaryNonAssoc_in_thfLogicFormula2596);
            	        fofBinaryNonAssoc(ctx, na);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfLogicFormulaEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2599);
            	        thfUnitaryFormula(ctx, p1);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfLogicFormulaEx;
            	        }


            	        {

            	                    if (p.d_expr.isNull() || p1.d_expr.isNull())
            	                    {
            	                      PARSER_STATE->parseError(
            	                          "Non-associative operator must be applied to formulas");
            	                    }
            	                    switch (na)
            	                    {
            	                      case tptp::NA_IFF:
            	                        p.d_expr = MK_TERM(cvc5::EQUAL, p.d_expr, p1.d_expr);
            	                        break;
            	                      case tptp::NA_REVIFF:
            	                        p.d_expr = MK_TERM(cvc5::XOR, p.d_expr, p1.d_expr);
            	                        break;
            	                      case tptp::NA_IMPLIES:
            	                        p.d_expr = MK_TERM(cvc5::IMPLIES, p.d_expr, p1.d_expr);
            	                        break;
            	                      case tptp::NA_REVIMPLIES:
            	                        p.d_expr = MK_TERM(cvc5::IMPLIES, p1.d_expr, p.d_expr);
            	                        break;
            	                      case tptp::NA_REVOR:
            	                        p.d_expr =
            	                            MK_TERM(cvc5::NOT, MK_TERM(cvc5::OR, p.d_expr, p1.d_expr));
            	                        break;
            	                      case tptp::NA_REVAND:
            	                        p.d_expr =
            	                            MK_TERM(cvc5::NOT, MK_TERM(cvc5::AND, p.d_expr, p1.d_expr));
            	                        break;
            	                    }
            	                  
            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1087:7: ( ( AND_TOK thfUnitaryFormula[p] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1087:7: ( ( AND_TOK thfUnitaryFormula[p] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1088:9: ( AND_TOK thfUnitaryFormula[p] )+
            	        {
            	            {

            	                          if (p.d_expr.isNull())
            	                          {
            	                            PARSER_STATE->parseError("AND must be applied to a formula");
            	                          }
            	                          args.push_back(p.d_expr);
            	                          p = ParseOp();
            	                        
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1096:9: ( AND_TOK thfUnitaryFormula[p] )+
            	            {
            	                int cnt53=0;

            	                for (;;)
            	                {
            	                    int alt53=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case AND_TOK:
            	            		{
            	            			alt53=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt53)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1096:11: AND_TOK thfUnitaryFormula[p]
            	            	        {
            	            	             MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_thfLogicFormula2645);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulethfLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2647);
            	            	            thfUnitaryFormula(ctx, p);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulethfLogicFormulaEx;
            	            	            }


            	            	            {

            	            	                            if (p.d_expr.isNull())
            	            	                            {
            	            	                              PARSER_STATE->parseError("AND must be applied to a formula");
            	            	                            }
            	            	                            args.push_back(p.d_expr);
            	            	                            p = ParseOp();
            	            	                          
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt53 >= 1 )
            	            		{
            	            		    goto loop53;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulethfLogicFormulaEx;
            	            	}
            	            	cnt53++;
            	                }
            	                loop53: ;	/* Jump to here if this rule does not match */
            	            }

            	            {

            	                          p.d_expr = MK_TERM(cvc5::AND, args);
            	                        
            	            }


            	        }


            	    }
            	    break;
            	case 4:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1111:7: ( ( OR_TOK thfUnitaryFormula[p] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1111:7: ( ( OR_TOK thfUnitaryFormula[p] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1112:9: ( OR_TOK thfUnitaryFormula[p] )+
            	        {
            	            {

            	                          if (p.d_expr.isNull())
            	                          {
            	                            PARSER_STATE->parseError("OR must be applied to a formula");
            	                          }
            	                          args.push_back(p.d_expr);
            	                          p = ParseOp();
            	                        
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1120:9: ( OR_TOK thfUnitaryFormula[p] )+
            	            {
            	                int cnt54=0;

            	                for (;;)
            	                {
            	                    int alt54=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case OR_TOK:
            	            		{
            	            			alt54=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt54)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1120:11: OR_TOK thfUnitaryFormula[p]
            	            	        {
            	            	             MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_thfLogicFormula2726);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulethfLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2728);
            	            	            thfUnitaryFormula(ctx, p);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulethfLogicFormulaEx;
            	            	            }


            	            	            {

            	            	                            if (p.d_expr.isNull())
            	            	                            {
            	            	                              PARSER_STATE->parseError("OR must be applied to a formula");
            	            	                            }
            	            	                            args.push_back(p.d_expr);
            	            	                            p = ParseOp();
            	            	                          
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt54 >= 1 )
            	            		{
            	            		    goto loop54;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulethfLogicFormulaEx;
            	            	}
            	            	cnt54++;
            	                }
            	                loop54: ;	/* Jump to here if this rule does not match */
            	            }

            	            {

            	                          p.d_expr = MK_TERM(cvc5::OR, args);
            	                        
            	            }


            	        }


            	    }
            	    break;
            	case 5:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1140:7: ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+
            	    {
            	        {

            	                    p_args.push_back(p);
            	                    p = ParseOp();
            	                  
            	        }


            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1144:7: ( APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK ) )+
            	        {
            	            int cnt56=0;

            	            for (;;)
            	            {
            	                int alt56=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case APP_TOK:
            	        		{
            	        			alt56=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt56)
            	        	{
            	        	    case 1:
            	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1144:9: APP_TOK ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK )
            	        	        {
            	        	             MATCHT(APP_TOK, &FOLLOW_APP_TOK_in_thfLogicFormula2830);
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulethfLogicFormulaEx;
            	        	            }


            	        	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1145:9: ( thfUnitaryFormula[p] | LBRACK_TOK thfTupleForm[args] RBRACK_TOK )
            	        	            {
            	        	                int alt55=2;
            	        	                switch ( LA(1) )
            	        	                {
            	        	                case CHOICE_TOK:
            	        	                case CNF_TOK:
            	        	                case DEF_DESC_TOK:
            	        	                case DISTINCT_OBJECT:
            	        	                case EXISTS_TOK:
            	        	                case FALSE_TOK:
            	        	                case FOF_TOK:
            	        	                case FORALL_TOK:
            	        	                case INCLUDE_TOK:
            	        	                case LAMBDA_TOK:
            	        	                case LOWER_WORD:
            	        	                case LOWER_WORD_SINGLE_QUOTED:
            	        	                case LPAREN_TOK:
            	        	                case NOT_TOK:
            	        	                case NUMBER:
            	        	                case SINGLE_QUOTED:
            	        	                case TFF_TOK:
            	        	                case TH1_UN_A:
            	        	                case TH1_UN_E:
            	        	                case THF_TOK:
            	        	                case TRUE_TOK:
            	        	                case TYPE_TOK:
            	        	                case UPPER_WORD:
            	        	                case 63:
            	        	                case 64:
            	        	                case 65:
            	        	                case 66:
            	        	                case 67:
            	        	                case 68:
            	        	                case 69:
            	        	                case 70:
            	        	                case 71:
            	        	                case 73:
            	        	                case 74:
            	        	                case 75:
            	        	                case 77:
            	        	                case 79:
            	        	                case 80:
            	        	                case 81:
            	        	                case 82:
            	        	                case 83:
            	        	                case 84:
            	        	                case 85:
            	        	                case 86:
            	        	                case 87:
            	        	                case 88:
            	        	                case 89:
            	        	                case 91:
            	        	                case 92:
            	        	                case 93:
            	        	                case 94:
            	        	                case 95:
            	        	                	{
            	        	                		alt55=1;
            	        	                	}
            	        	                    break;
            	        	                case LBRACK_TOK:
            	        	                	{
            	        	                		alt55=2;
            	        	                	}
            	        	                    break;

            	        	                default:
            	        	                    CONSTRUCTEX();
            	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                    EXCEPTION->message      = (void *)"";
            	        	                    EXCEPTION->decisionNum  = 55;
            	        	                    EXCEPTION->state        = 0;


            	        	                    goto rulethfLogicFormulaEx;

            	        	                }

            	        	                switch (alt55)
            	        	                {
            	        	            	case 1:
            	        	            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1146:10: thfUnitaryFormula[p]
            	        	            	    {
            	        	            	        FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfLogicFormula2851);
            	        	            	        thfUnitaryFormula(ctx, p);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulethfLogicFormulaEx;
            	        	            	        }


            	        	            	        {

            	        	            	                       p_args.push_back(p);
            	        	            	                       p = ParseOp();
            	        	            	                     
            	        	            	        }


            	        	            	    }
            	        	            	    break;
            	        	            	case 2:
            	        	            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1151:12: LBRACK_TOK thfTupleForm[args] RBRACK_TOK
            	        	            	    {
            	        	            	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_thfLogicFormula2876);
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulethfLogicFormulaEx;
            	        	            	        }


            	        	            	        {
            	        	            	             UNSUPPORTED("Tuple terms"); 
            	        	            	        }


            	        	            	        FOLLOWPUSH(FOLLOW_thfTupleForm_in_thfLogicFormula2902);
            	        	            	        thfTupleForm(ctx, args);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulethfLogicFormulaEx;
            	        	            	        }


            	        	            	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_thfLogicFormula2916);
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulethfLogicFormulaEx;
            	        	            	        }


            	        	            	    }
            	        	            	    break;

            	        	                }
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt56 >= 1 )
            	        		{
            	        		    goto loop56;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulethfLogicFormulaEx;
            	        	}
            	        	cnt56++;
            	            }
            	            loop56: ;	/* Jump to here if this rule does not match */
            	        }

            	        {

            	                    if (p_args[0].d_expr.isNull())
            	                    {
            	                      for (unsigned i = 1, size = p_args.size(); i < size; ++i)
            	                      {
            	                        if (p_args[i].d_expr.isNull())
            	                        {
            	                          PARSER_STATE->parseError(
            	                              "Application chains with defined symbol heads and at least "
            	                              "one defined symbol as argument are unsupported.");
            	                        }
            	                        args.push_back(p_args[i].d_expr);
            	                      }
            	                      p.d_expr = PARSER_STATE->applyParseOp(p_args[0], args);
            	                    }
            	                    else
            	                    {
            	                      p.d_expr = p_args[0].d_expr;
            	                      // check if any argument is a defined function, e.g. "~", and create a
            	                      // lambda wrapper then, e.g. (\lambda x. ~ x)
            	                      for (unsigned i = 1, size = p_args.size(); i < size; ++i)
            	                      {
            	                        if (!p_args[i].d_expr.isNull())
            	                        {
            	                          args.push_back(p_args[i].d_expr);
            	                          continue;
            	                        }
            	                        // create a lambda wrapper, e.g. (\lambda x. ~ x).
            	                        //
            	                        // The type is determined by the first element of the application
            	                        // chain, which must be a function of type t1...tn -> t, so the
            	                        // lambda must have type ti
            	                        args.push_back(PARSER_STATE->mkLambdaWrapper(
            	                            p_args[i].d_kind,
            	                            p.d_expr.getSort()
            	                                .getFunctionDomainSorts()[i - 1]));
            	                      }
            	                      for (unsigned i = 0, size = args.size(); i < size; ++i)
            	                      {
            	                        p.d_expr = MK_TERM(cvc5::HO_APPLY, p.d_expr, args[i]);
            	                      }
            	                    }
            	                  
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulethfLogicFormulaEx; /* Prevent compiler warnings */
    rulethfLogicFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfLogicFormula */

/**
 * $ANTLR start thfTupleForm
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1203:1: thfTupleForm[std::vector<cvc5::Term>& args] : thfUnitaryFormula[p] ( COMMA_TOK thfUnitaryFormula[p] )+ ;
 */
static void
thfTupleForm(pTptpParser ctx, std::vector<cvc5::Term>& args)
{

      ParseOp p;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1207:3: ( thfUnitaryFormula[p] ( COMMA_TOK thfUnitaryFormula[p] )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1207:5: thfUnitaryFormula[p] ( COMMA_TOK thfUnitaryFormula[p] )+
        {
            FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfTupleForm2969);
            thfUnitaryFormula(ctx, p);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulethfTupleFormEx;
            }


            {

                     if (p.d_expr.isNull())
                     {
                       PARSER_STATE->parseError("TUPLE element must be a formula");
                     }
                     args.push_back(p.d_expr);
                   
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1215:4: ( COMMA_TOK thfUnitaryFormula[p] )+
            {
                int cnt58=0;

                for (;;)
                {
                    int alt58=2;
            	switch ( LA(1) )
            	{
            	case COMMA_TOK:
            		{
            			alt58=1;
            		}
            	    break;

            	}

            	switch (alt58)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1215:6: COMMA_TOK thfUnitaryFormula[p]
            	        {
            	             MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_thfTupleForm2982);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulethfTupleFormEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfTupleForm2984);
            	            thfUnitaryFormula(ctx, p);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulethfTupleFormEx;
            	            }


            	            {

            	                       if (p.d_expr.isNull())
            	                       {
            	                         PARSER_STATE->parseError("TUPLE element must be a formula");
            	                       }
            	                       args.push_back(p.d_expr);
            	                     
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt58 >= 1 )
            		{
            		    goto loop58;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulethfTupleFormEx;
            	}
            	cnt58++;
                }
                loop58: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulethfTupleFormEx; /* Prevent compiler warnings */
    rulethfTupleFormEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfTupleForm */

/**
 * $ANTLR start thfUnitaryFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1226:1: thfUnitaryFormula[cvc5::ParseOp& p] : ( variable[p.d_expr] | thfAtomicFormula[p] | LPAREN_TOK thfLogicFormula[p] RPAREN_TOK | NOT_TOK ( thfUnitaryFormula[p1] )? | thfQuantifier[p.d_kind] LBRACK_TOK thfBindVariable[expr] ( COMMA_TOK thfBindVariable[expr] )* RBRACK_TOK COLON_TOK thfUnitaryFormula[p1] );
 */
static void
thfUnitaryFormula(pTptpParser ctx, cvc5::ParseOp& p)
{

      cvc5::Kind kind;
      std::vector< cvc5::Term > bv;
      cvc5::Term expr;
      bool equal;
      ParseOp p1;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1234:3: ( variable[p.d_expr] | thfAtomicFormula[p] | LPAREN_TOK thfLogicFormula[p] RPAREN_TOK | NOT_TOK ( thfUnitaryFormula[p1] )? | thfQuantifier[p.d_kind] LBRACK_TOK thfBindVariable[expr] ( COMMA_TOK thfBindVariable[expr] )* RBRACK_TOK COLON_TOK thfUnitaryFormula[p1] )

            ANTLR3_UINT32 alt61;

            alt61=5;

            switch ( LA(1) )
            {
            case UPPER_WORD:
            	{
            		alt61=1;
            	}
                break;
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt61=2;
            	}
                break;
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case AND_TOK:
            		case IMPLIES_TOK:
            		case OR_TOK:
            			{
            				alt61=2;
            			}
            		    break;
            		case CHOICE_TOK:
            		case CNF_TOK:
            		case DEF_DESC_TOK:
            		case DISTINCT_OBJECT:
            		case EXISTS_TOK:
            		case FALSE_TOK:
            		case FOF_TOK:
            		case FORALL_TOK:
            		case INCLUDE_TOK:
            		case LAMBDA_TOK:
            		case LOWER_WORD:
            		case LOWER_WORD_SINGLE_QUOTED:
            		case LPAREN_TOK:
            		case NOT_TOK:
            		case NUMBER:
            		case SINGLE_QUOTED:
            		case TFF_TOK:
            		case TH1_UN_A:
            		case TH1_UN_E:
            		case THF_TOK:
            		case TRUE_TOK:
            		case TYPE_TOK:
            		case UPPER_WORD:
            		case 63:
            		case 64:
            		case 65:
            		case 66:
            		case 67:
            		case 68:
            		case 69:
            		case 70:
            		case 71:
            		case 73:
            		case 74:
            		case 75:
            		case 77:
            		case 79:
            		case 80:
            		case 81:
            		case 82:
            		case 83:
            		case 84:
            		case 85:
            		case 86:
            		case 87:
            		case 88:
            		case 89:
            		case 91:
            		case 92:
            		case 93:
            		case 94:
            		case 95:
            			{
            				alt61=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 61;
            		    EXCEPTION->state        = 42;


            		    goto rulethfUnitaryFormulaEx;

            		}

            	}
                break;
            case NOT_TOK:
            	{
            		alt61=4;
            	}
                break;
            case CHOICE_TOK:
            case DEF_DESC_TOK:
            case EXISTS_TOK:
            case FORALL_TOK:
            case LAMBDA_TOK:
            case TH1_UN_A:
            case TH1_UN_E:
            	{
            		alt61=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 61;
                EXCEPTION->state        = 0;


                goto rulethfUnitaryFormulaEx;

            }

            switch (alt61)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1234:5: variable[p.d_expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_variable_in_thfUnitaryFormula3015);
        	        variable(ctx, p.d_expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1235:5: thfAtomicFormula[p]
        	    {
        	        FOLLOWPUSH(FOLLOW_thfAtomicFormula_in_thfUnitaryFormula3022);
        	        thfAtomicFormula(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1236:5: LPAREN_TOK thfLogicFormula[p] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfUnitaryFormula3029);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_thfLogicFormula_in_thfUnitaryFormula3035);
        	        thfLogicFormula(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfUnitaryFormula3042);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1239:5: NOT_TOK ( thfUnitaryFormula[p1] )?
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_thfUnitaryFormula3048);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        {

        	                  p.d_kind = cvc5::NOT;
        	                
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1243:5: ( thfUnitaryFormula[p1] )?
        	        {
        	            int alt59=2;
        	            switch ( LA(1) )
        	            {
        	                case CHOICE_TOK:
        	                case CNF_TOK:
        	                case DEF_DESC_TOK:
        	                case DISTINCT_OBJECT:
        	                case EXISTS_TOK:
        	                case FALSE_TOK:
        	                case FOF_TOK:
        	                case FORALL_TOK:
        	                case INCLUDE_TOK:
        	                case LAMBDA_TOK:
        	                case LOWER_WORD:
        	                case LOWER_WORD_SINGLE_QUOTED:
        	                case LPAREN_TOK:
        	                case NOT_TOK:
        	                case NUMBER:
        	                case SINGLE_QUOTED:
        	                case TFF_TOK:
        	                case TH1_UN_A:
        	                case TH1_UN_E:
        	                case THF_TOK:
        	                case TRUE_TOK:
        	                case TYPE_TOK:
        	                case UPPER_WORD:
        	                case 63:
        	                case 64:
        	                case 65:
        	                case 66:
        	                case 67:
        	                case 68:
        	                case 69:
        	                case 70:
        	                case 71:
        	                case 73:
        	                case 74:
        	                case 75:
        	                case 77:
        	                case 79:
        	                case 80:
        	                case 81:
        	                case 82:
        	                case 83:
        	                case 84:
        	                case 85:
        	                case 86:
        	                case 87:
        	                case 88:
        	                case 89:
        	                case 91:
        	                case 92:
        	                case 93:
        	                case 94:
        	                case 95:
        	                	{
        	                		alt59=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt59)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1244:6: thfUnitaryFormula[p1]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3067);
        	        	        thfUnitaryFormula(ctx, p1);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfUnitaryFormulaEx;
        	        	        }


        	        	        {

        	        	                   if (p1.d_expr.isNull())
        	        	                   {
        	        	                     PARSER_STATE->parseError("NOT must be applied to a formula");
        	        	                   }
        	        	                   std::vector<cvc5::Term> args{p1.d_expr};
        	        	                   p.d_expr = PARSER_STATE->applyParseOp(p, args);
        	        	                 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1255:5: thfQuantifier[p.d_kind] LBRACK_TOK thfBindVariable[expr] ( COMMA_TOK thfBindVariable[expr] )* RBRACK_TOK COLON_TOK thfUnitaryFormula[p1]
        	    {
        	        FOLLOWPUSH(FOLLOW_thfQuantifier_in_thfUnitaryFormula3093);
        	        thfQuantifier(ctx, p.d_kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_thfUnitaryFormula3100);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        {
        	            PARSER_STATE->pushScope();
        	        }


        	        FOLLOWPUSH(FOLLOW_thfBindVariable_in_thfUnitaryFormula3108);
        	        thfBindVariable(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        {

        	                  bv.push_back(expr);
        	                
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1261:5: ( COMMA_TOK thfBindVariable[expr] )*

        	        for (;;)
        	        {
        	            int alt60=2;
        	            switch ( LA(1) )
        	            {
        	            case COMMA_TOK:
        	            	{
        	            		alt60=1;
        	            	}
        	                break;

        	            }

        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1261:7: COMMA_TOK thfBindVariable[expr]
        	        	    {
        	        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_thfUnitaryFormula3123);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfUnitaryFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_thfBindVariable_in_thfUnitaryFormula3125);
        	        	        thfBindVariable(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulethfUnitaryFormulaEx;
        	        	        }


        	        	        {

        	        	                    bv.push_back(expr);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop60;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop60: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_thfUnitaryFormula3147);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_thfUnitaryFormula3149);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_thfUnitaryFormula_in_thfUnitaryFormula3155);
        	        thfUnitaryFormula(ctx, p1);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfUnitaryFormulaEx;
        	        }


        	        {

        	                  if (p1.d_expr.isNull())
        	                  {
        	                    PARSER_STATE->parseError("In scope of binder there must be a formula.");
        	                  }
        	                  expr = p1.d_expr;
        	                  PARSER_STATE->popScope();
        	                  // handle lambda case, in which case return type must be flattened and the
        	                  // auxiliary variables introduced in the process must be added no the
        	                  // variable list
        	                  //
        	                  // see documentation of mkFlatFunctionType for how it's done
        	                  //
        	                  // flatten body via flattening its type
        	                  std::vector<cvc5::Sort> sorts;
        	                  std::vector<cvc5::Term> flattenVars;
        	                  PARSER_STATE->mkFlatFunctionType(sorts, expr.getSort(), flattenVars);
        	                  if (!flattenVars.empty())
        	                  {
        	                    // apply body of lambda to flatten vars
        	                    expr = PARSER_STATE->mkHoApply(expr, flattenVars);
        	                    // add variables to VARIABLE_LIST
        	                    bv.insert(bv.end(), flattenVars.begin(), flattenVars.end());
        	                  }
        	                  p.d_expr = MK_TERM(p.d_kind, MK_TERM(cvc5::VARIABLE_LIST, bv), expr);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfUnitaryFormulaEx; /* Prevent compiler warnings */
    rulethfUnitaryFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfUnitaryFormula */

/**
 * $ANTLR start tffFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1298:1: tffFormula[cvc5::Term& expr] : tffLogicFormula[expr] ;
 */
static void
tffFormula(pTptpParser ctx, cvc5::Term& expr)
{
    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1298:30: ( tffLogicFormula[expr] )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1298:32: tffLogicFormula[expr]
        {
            FOLLOWPUSH(FOLLOW_tffLogicFormula_in_tffFormula3178);
            tffLogicFormula(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletffFormulaEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffFormulaEx; /* Prevent compiler warnings */
    ruletffFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffFormula */

/**
 * $ANTLR start tffTypedAtom
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1300:1: tffTypedAtom[std::unique_ptr<cvc5::parser::Command>& cmd] : ( LPAREN_TOK tffTypedAtom[cmd] RPAREN_TOK | nameN[name] COLON_TOK ( '$tType' | parseType[type] ) );
 */
static void
tffTypedAtom(pTptpParser ctx, std::unique_ptr<cvc5::parser::Command>& cmd)
{

      cvc5::Term expr;
      cvc5::Sort type;
      std::string name;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1306:3: ( LPAREN_TOK tffTypedAtom[cmd] RPAREN_TOK | nameN[name] COLON_TOK ( '$tType' | parseType[type] ) )

            ANTLR3_UINT32 alt63;

            alt63=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt63=1;
            	}
                break;
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt63=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 63;
                EXCEPTION->state        = 0;


                goto ruletffTypedAtomEx;

            }

            switch (alt63)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1306:5: LPAREN_TOK tffTypedAtom[cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffTypedAtom3195);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffTypedAtomEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffTypedAtom_in_tffTypedAtom3197);
        	        tffTypedAtom(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffTypedAtomEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffTypedAtom3200);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffTypedAtomEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1307:5: nameN[name] COLON_TOK ( '$tType' | parseType[type] )
        	    {
        	        FOLLOWPUSH(FOLLOW_nameN_in_tffTypedAtom3206);
        	        nameN(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffTypedAtomEx;
        	        }


        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_tffTypedAtom3209);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffTypedAtomEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1308:5: ( '$tType' | parseType[type] )
        	        {
        	            int alt62=2;
        	            switch ( LA(1) )
        	            {
        	            case 90:
        	            	{
        	            		alt62=1;
        	            	}
        	                break;
        	            case CNF_TOK:
        	            case DEFINED_SYMBOL:
        	            case FOF_TOK:
        	            case INCLUDE_TOK:
        	            case LOWER_WORD:
        	            case LOWER_WORD_SINGLE_QUOTED:
        	            case LPAREN_TOK:
        	            case SINGLE_QUOTED:
        	            case TFF_TOK:
        	            case THF_TOK:
        	            case TYPE_TOK:
        	            	{
        	            		alt62=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 62;
        	                EXCEPTION->state        = 0;


        	                goto ruletffTypedAtomEx;

        	            }

        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1308:7: '$tType'
        	        	    {
        	        	         MATCHT(90, &FOLLOW_90_in_tffTypedAtom3217);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletffTypedAtomEx;
        	        	        }


        	        	        {
        	        	             if(PARSER_STATE->isDeclared(name, SYM_SORT)) {
        	        	                      // duplicate declaration is fine, they're compatible
        	        	                      cmd = std::make_unique<EmptyCommand>("compatible redeclaration of sort " + name);
        	        	                    } else if(PARSER_STATE->isDeclared(name, SYM_VARIABLE)) {
        	        	                      // error: cannot be both sort and constant
        	        	                      PARSER_STATE->parseError("Symbol `" + name + "' previously declared as a constant; cannot also be a sort");
        	        	                    } else {
        	        	                      // as yet, it's undeclared
        	        	                      cvc5::Sort atype = PARSER_STATE->mkSort(name);
        	        	                      cmd = std::make_unique<DeclareSortCommand>(name, 0, atype);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1321:7: parseType[type]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_parseType_in_tffTypedAtom3233);
        	        	        parseType(ctx, type);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletffTypedAtomEx;
        	        	        }


        	        	        {
        	        	             if(PARSER_STATE->isDeclared(name, SYM_SORT)) {
        	        	                      // error: cannot be both sort and constant
        	        	                      PARSER_STATE->parseError("Symbol `" + name + "' previously declared as a sort");
        	        	                      cmd = std::make_unique<EmptyCommand>("compatible redeclaration of sort " + name);
        	        	                    } else if(PARSER_STATE->isDeclared(name, SYM_VARIABLE)) {
        	        	                      if(type == PARSER_STATE->getVariable(name).getSort()) {
        	        	                        // duplicate declaration is fine, they're compatible
        	        	                        cmd = std::make_unique<EmptyCommand>("compatible redeclaration of constant " + name);
        	        	                      } else {
        	        	                        // error: sorts incompatible
        	        	                        PARSER_STATE->parseError("Symbol `" + name + "' declared previously with a different sort");
        	        	                      }
        	        	                    } else {
        	        	                      // as yet, it's undeclared
        	        	                      cvc5::Term aexpr = PARSER_STATE->bindVar(name, type);
        	        	                      cmd = std::make_unique<DeclareFunctionCommand>(name, aexpr, type);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletffTypedAtomEx; /* Prevent compiler warnings */
    ruletffTypedAtomEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffTypedAtom */

/**
 * $ANTLR start tffLogicFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1343:1: tffLogicFormula[cvc5::Term& expr] : tffUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] ) | ( ( AND_TOK tffUnitaryFormula[expr] )+ ) | ( ( OR_TOK tffUnitaryFormula[expr] )+ ) )? ;
 */
static void
tffLogicFormula(pTptpParser ctx, cvc5::Term& expr)
{

      tptp::NonAssoc na;
      std::vector< cvc5::Term > args;
      cvc5::Term expr2;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1349:3: ( tffUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] ) | ( ( AND_TOK tffUnitaryFormula[expr] )+ ) | ( ( OR_TOK tffUnitaryFormula[expr] )+ ) )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1349:5: tffUnitaryFormula[expr] ( ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] ) | ( ( AND_TOK tffUnitaryFormula[expr] )+ ) | ( ( OR_TOK tffUnitaryFormula[expr] )+ ) )?
        {
            FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffLogicFormula3267);
            tffUnitaryFormula(ctx, expr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletffLogicFormulaEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1350:5: ( ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] ) | ( ( AND_TOK tffUnitaryFormula[expr] )+ ) | ( ( OR_TOK tffUnitaryFormula[expr] )+ ) )?
            {
                int alt66=4;
                switch ( LA(1) )
                {
                    case IFF_TOK:
                    case IMPLIES_TOK:
                    case REVAND_TOK:
                    case REVIFF_TOK:
                    case REVIMPLIES_TOK:
                    case REVOR_TOK:
                    	{
                    		alt66=1;
                    	}
                        break;
                    case AND_TOK:
                    	{
                    		alt66=2;
                    	}
                        break;
                    case OR_TOK:
                    	{
                    		alt66=3;
                    	}
                        break;
                }

                switch (alt66)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1351:7: ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1351:7: ( fofBinaryNonAssoc[na] tffUnitaryFormula[expr2] )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1351:9: fofBinaryNonAssoc[na] tffUnitaryFormula[expr2]
            	        {
            	            FOLLOWPUSH(FOLLOW_fofBinaryNonAssoc_in_tffLogicFormula3285);
            	            fofBinaryNonAssoc(ctx, na);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletffLogicFormulaEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffLogicFormula3288);
            	            tffUnitaryFormula(ctx, expr2);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletffLogicFormulaEx;
            	            }


            	            {
            	                 switch(na) {
            	                           case tptp::NA_IFF:
            	                             expr = MK_TERM(cvc5::EQUAL,expr,expr2);
            	                             break;
            	                           case tptp::NA_REVIFF:
            	                             expr = MK_TERM(cvc5::XOR,expr,expr2);
            	                             break;
            	                           case tptp::NA_IMPLIES:
            	                             expr = MK_TERM(cvc5::IMPLIES,expr,expr2);
            	                             break;
            	                           case tptp::NA_REVIMPLIES:
            	                             expr = MK_TERM(cvc5::IMPLIES,expr2,expr);
            	                             break;
            	                           case tptp::NA_REVOR:
            	                             expr = MK_TERM(cvc5::NOT,MK_TERM(cvc5::OR,expr,expr2));
            	                             break;
            	                           case tptp::NA_REVAND:
            	                             expr = MK_TERM(cvc5::NOT,MK_TERM(cvc5::AND,expr,expr2));
            	                             break;
            	                          }
            	                        
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1375:7: ( ( AND_TOK tffUnitaryFormula[expr] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1375:7: ( ( AND_TOK tffUnitaryFormula[expr] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1375:9: ( AND_TOK tffUnitaryFormula[expr] )+
            	        {
            	            {
            	                 args.push_back(expr); 
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1376:9: ( AND_TOK tffUnitaryFormula[expr] )+
            	            {
            	                int cnt64=0;

            	                for (;;)
            	                {
            	                    int alt64=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case AND_TOK:
            	            		{
            	            			alt64=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt64)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1376:11: AND_TOK tffUnitaryFormula[expr]
            	            	        {
            	            	             MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_tffLogicFormula3336);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto ruletffLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffLogicFormula3338);
            	            	            tffUnitaryFormula(ctx, expr);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto ruletffLogicFormulaEx;
            	            	            }


            	            	            {
            	            	                 args.push_back(expr); 
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt64 >= 1 )
            	            		{
            	            		    goto loop64;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto ruletffLogicFormulaEx;
            	            	}
            	            	cnt64++;
            	                }
            	                loop64: ;	/* Jump to here if this rule does not match */
            	            }

            	            {
            	                 expr = MK_TERM(cvc5::AND,args); 
            	            }


            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1380:7: ( ( OR_TOK tffUnitaryFormula[expr] )+ )
            	    {
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1380:7: ( ( OR_TOK tffUnitaryFormula[expr] )+ )
            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1380:9: ( OR_TOK tffUnitaryFormula[expr] )+
            	        {
            	            {
            	                 args.push_back(expr); 
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1381:9: ( OR_TOK tffUnitaryFormula[expr] )+
            	            {
            	                int cnt65=0;

            	                for (;;)
            	                {
            	                    int alt65=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case OR_TOK:
            	            		{
            	            			alt65=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt65)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1381:11: OR_TOK tffUnitaryFormula[expr]
            	            	        {
            	            	             MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_tffLogicFormula3391);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto ruletffLogicFormulaEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffLogicFormula3393);
            	            	            tffUnitaryFormula(ctx, expr);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto ruletffLogicFormulaEx;
            	            	            }


            	            	            {
            	            	                 args.push_back(expr); 
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt65 >= 1 )
            	            		{
            	            		    goto loop65;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto ruletffLogicFormulaEx;
            	            	}
            	            	cnt65++;
            	                }
            	                loop65: ;	/* Jump to here if this rule does not match */
            	            }

            	            {
            	                 expr = MK_TERM(cvc5::OR,args); 
            	            }


            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffLogicFormulaEx; /* Prevent compiler warnings */
    ruletffLogicFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffLogicFormula */

/**
 * $ANTLR start tffUnitaryFormula
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1387:1: tffUnitaryFormula[cvc5::Term& expr] : ( atomicFormula[expr] | LPAREN_TOK tffLogicFormula[expr] RPAREN_TOK | NOT_TOK tffUnitaryFormula[expr] | folQuantifier[kind] LBRACK_TOK ( tffbindvariable[expr] ( COMMA_TOK tffbindvariable[expr] )* ) RBRACK_TOK COLON_TOK tffUnitaryFormula[expr] | '$ite_f' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK tffLogicFormula[lhs] COMMA_TOK tffLogicFormula[rhs] RPAREN_TOK | '$let_tf' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK | '$let_ff' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK );
 */
static void
tffUnitaryFormula(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Kind kind;
      std::vector< cvc5::Term > bv;
      cvc5::Term lhs, rhs;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1393:3: ( atomicFormula[expr] | LPAREN_TOK tffLogicFormula[expr] RPAREN_TOK | NOT_TOK tffUnitaryFormula[expr] | folQuantifier[kind] LBRACK_TOK ( tffbindvariable[expr] ( COMMA_TOK tffbindvariable[expr] )* ) RBRACK_TOK COLON_TOK tffUnitaryFormula[expr] | '$ite_f' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK tffLogicFormula[lhs] COMMA_TOK tffLogicFormula[rhs] RPAREN_TOK | '$let_tf' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK | '$let_ff' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK )

            ANTLR3_UINT32 alt68;

            alt68=7;

            switch ( LA(1) )
            {
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt68=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt68=2;
            	}
                break;
            case NOT_TOK:
            	{
            		alt68=3;
            	}
                break;
            case EXISTS_TOK:
            case FORALL_TOK:
            	{
            		alt68=4;
            	}
                break;
            case 72:
            	{
            		alt68=5;
            	}
                break;
            case 78:
            	{
            		alt68=6;
            	}
                break;
            case 76:
            	{
            		alt68=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 68;
                EXCEPTION->state        = 0;


                goto ruletffUnitaryFormulaEx;

            }

            switch (alt68)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1393:5: atomicFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicFormula_in_tffUnitaryFormula3443);
        	        atomicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1394:5: LPAREN_TOK tffLogicFormula[expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3450);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLogicFormula_in_tffUnitaryFormula3452);
        	        tffLogicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3455);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1395:5: NOT_TOK tffUnitaryFormula[expr]
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_tffUnitaryFormula3461);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3463);
        	        tffUnitaryFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             expr = MK_TERM(cvc5::NOT,expr); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1397:5: folQuantifier[kind] LBRACK_TOK ( tffbindvariable[expr] ( COMMA_TOK tffbindvariable[expr] )* ) RBRACK_TOK COLON_TOK tffUnitaryFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_folQuantifier_in_tffUnitaryFormula3477);
        	        folQuantifier(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_tffUnitaryFormula3480);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	            PARSER_STATE->pushScope();
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1398:5: ( tffbindvariable[expr] ( COMMA_TOK tffbindvariable[expr] )* )
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1398:7: tffbindvariable[expr] ( COMMA_TOK tffbindvariable[expr] )*
        	        {
        	            FOLLOWPUSH(FOLLOW_tffbindvariable_in_tffUnitaryFormula3490);
        	            tffbindvariable(ctx, expr);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletffUnitaryFormulaEx;
        	            }


        	            {
        	                 bv.push_back(expr); 
        	            }


        	            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1399:7: ( COMMA_TOK tffbindvariable[expr] )*

        	            for (;;)
        	            {
        	                int alt67=2;
        	                switch ( LA(1) )
        	                {
        	                case COMMA_TOK:
        	                	{
        	                		alt67=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt67)
        	                {
        	            	case 1:
        	            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1399:9: COMMA_TOK tffbindvariable[expr]
        	            	    {
        	            	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffUnitaryFormula3503);
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletffUnitaryFormulaEx;
        	            	        }


        	            	        FOLLOWPUSH(FOLLOW_tffbindvariable_in_tffUnitaryFormula3505);
        	            	        tffbindvariable(ctx, expr);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletffUnitaryFormulaEx;
        	            	        }


        	            	        {
        	            	             bv.push_back(expr); 
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop67;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop67: ; /* Jump out to here if this rule does not match */


        	        }


        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_tffUnitaryFormula3515);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_tffUnitaryFormula3521);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffUnitaryFormula3523);
        	        tffUnitaryFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = MK_TERM(kind, MK_TERM(cvc5::VARIABLE_LIST, bv), expr);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1404:5: '$ite_f' LPAREN_TOK tffLogicFormula[expr] COMMA_TOK tffLogicFormula[lhs] COMMA_TOK tffLogicFormula[rhs] RPAREN_TOK
        	    {
        	         MATCHT(72, &FOLLOW_72_in_tffUnitaryFormula3536);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3538);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLogicFormula_in_tffUnitaryFormula3540);
        	        tffLogicFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffUnitaryFormula3543);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLogicFormula_in_tffUnitaryFormula3545);
        	        tffLogicFormula(ctx, lhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffUnitaryFormula3548);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLogicFormula_in_tffUnitaryFormula3550);
        	        tffLogicFormula(ctx, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3553);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             expr = MK_TERM(cvc5::ITE, expr, lhs, rhs); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1406:5: '$let_tf' LPAREN_TOK tffLetTermDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK
        	    {
        	         MATCHT(78, &FOLLOW_78_in_tffUnitaryFormula3565);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3567);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetTermDefn_in_tffUnitaryFormula3575);
        	        tffLetTermDefn(ctx, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffUnitaryFormula3578);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffFormula_in_tffUnitaryFormula3584);
        	        tffFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = expr.substitute(lhs, rhs);
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3597);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1413:5: '$let_ff' LPAREN_TOK tffLetFormulaDefn[lhs, rhs] COMMA_TOK tffFormula[expr] RPAREN_TOK
        	    {
        	         MATCHT(76, &FOLLOW_76_in_tffUnitaryFormula3603);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffUnitaryFormula3605);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetFormulaDefn_in_tffUnitaryFormula3613);
        	        tffLetFormulaDefn(ctx, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffUnitaryFormula3616);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffFormula_in_tffUnitaryFormula3622);
        	        tffFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  expr = expr.substitute(lhs, rhs);
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffUnitaryFormula3635);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffUnitaryFormulaEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletffUnitaryFormulaEx; /* Prevent compiler warnings */
    ruletffUnitaryFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffUnitaryFormula */

/**
 * $ANTLR start tffLetTermDefn
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1422:1: tffLetTermDefn[cvc5::Term& lhs, cvc5::Term& rhs] : ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetTermBinding[bvlist, lhs, rhs] ;
 */
static void
tffLetTermDefn(pTptpParser ctx, cvc5::Term& lhs, cvc5::Term& rhs)
{

      std::vector<cvc5::Term> bvlist;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1426:3: ( ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetTermBinding[bvlist, lhs, rhs] )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1426:5: ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetTermBinding[bvlist, lhs, rhs]
        {
            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1426:5: ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )*

            for (;;)
            {
                int alt69=2;
                switch ( LA(1) )
                {
                case FORALL_TOK:
                	{
                		alt69=1;
                	}
                    break;

                }

                switch (alt69)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1426:6: FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK
            	    {
            	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_tffLetTermDefn3655);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetTermDefnEx;
            	        }


            	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_tffLetTermDefn3657);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetTermDefnEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_tffVariableList_in_tffLetTermDefn3659);
            	        tffVariableList(ctx, bvlist);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetTermDefnEx;
            	        }


            	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_tffLetTermDefn3662);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetTermDefnEx;
            	        }


            	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_tffLetTermDefn3664);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetTermDefnEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop69;	/* break out of the loop */
            	    break;
                }
            }
            loop69: ; /* Jump out to here if this rule does not match */


            FOLLOWPUSH(FOLLOW_tffLetTermBinding_in_tffLetTermDefn3672);
            tffLetTermBinding(ctx, bvlist, lhs, rhs);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletffLetTermDefnEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffLetTermDefnEx; /* Prevent compiler warnings */
    ruletffLetTermDefnEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffLetTermDefn */

/**
 * $ANTLR start tffLetTermBinding
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1430:1: tffLetTermBinding[std::vector<cvc5::Term> & bvlist,\n cvc5::Term& lhs,\n cvc5::Term& rhs] : ( term[lhs] EQUAL_TOK term[rhs] | LPAREN_TOK tffLetTermBinding[bvlist, lhs, rhs] RPAREN_TOK );
 */
static void
tffLetTermBinding(pTptpParser ctx, std::vector<cvc5::Term> & bvlist, cvc5::Term& lhs, cvc5::Term& rhs)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1433:3: ( term[lhs] EQUAL_TOK term[rhs] | LPAREN_TOK tffLetTermBinding[bvlist, lhs, rhs] RPAREN_TOK )

            ANTLR3_UINT32 alt70;

            alt70=2;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 66:
            case 71:
            case 73:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt70=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt70=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 70;
                EXCEPTION->state        = 0;


                goto ruletffLetTermBindingEx;

            }

            switch (alt70)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1433:5: term[lhs] EQUAL_TOK term[rhs]
        	    {
        	        FOLLOWPUSH(FOLLOW_term_in_tffLetTermBinding3687);
        	        term(ctx, lhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_tffLetTermBinding3690);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_tffLetTermBinding3692);
        	        term(ctx, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	        {

        	                PARSER_STATE->checkLetBinding(bvlist, lhs, rhs, false);
        	                std::vector<cvc5::Term> lchildren(++lhs.begin(), lhs.end());
        	                rhs = MK_TERM(cvc5::LAMBDA, MK_TERM(cvc5::VARIABLE_LIST, lchildren), rhs);
        	                // since lhs is always APPLY_UF (otherwise we'd have had a parser error in
        	                // checkLetBinding) the function to be replaced is always the first
        	                // argument. Note that the way in which lchildren is built above is also
        	                // relying on this.
        	                lhs = lhs[0];
        	              
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1444:5: LPAREN_TOK tffLetTermBinding[bvlist, lhs, rhs] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffLetTermBinding3703);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetTermBinding_in_tffLetTermBinding3705);
        	        tffLetTermBinding(ctx, bvlist, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffLetTermBinding3708);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetTermBindingEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletffLetTermBindingEx; /* Prevent compiler warnings */
    ruletffLetTermBindingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffLetTermBinding */

/**
 * $ANTLR start tffLetFormulaDefn
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1447:1: tffLetFormulaDefn[cvc5::Term& lhs, cvc5::Term& rhs] : ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetFormulaBinding[bvlist, lhs, rhs] ;
 */
static void
tffLetFormulaDefn(pTptpParser ctx, cvc5::Term& lhs, cvc5::Term& rhs)
{

      std::vector<cvc5::Term> bvlist;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1451:3: ( ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetFormulaBinding[bvlist, lhs, rhs] )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1451:5: ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )* tffLetFormulaBinding[bvlist, lhs, rhs]
        {
            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1451:5: ( FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK )*

            for (;;)
            {
                int alt71=2;
                switch ( LA(1) )
                {
                case FORALL_TOK:
                	{
                		alt71=1;
                	}
                    break;

                }

                switch (alt71)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1451:6: FORALL_TOK LBRACK_TOK tffVariableList[bvlist] RBRACK_TOK COLON_TOK
            	    {
            	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_tffLetFormulaDefn3728);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetFormulaDefnEx;
            	        }


            	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_tffLetFormulaDefn3730);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetFormulaDefnEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_tffVariableList_in_tffLetFormulaDefn3732);
            	        tffVariableList(ctx, bvlist);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetFormulaDefnEx;
            	        }


            	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_tffLetFormulaDefn3735);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetFormulaDefnEx;
            	        }


            	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_tffLetFormulaDefn3737);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffLetFormulaDefnEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop71;	/* break out of the loop */
            	    break;
                }
            }
            loop71: ; /* Jump out to here if this rule does not match */


            FOLLOWPUSH(FOLLOW_tffLetFormulaBinding_in_tffLetFormulaDefn3745);
            tffLetFormulaBinding(ctx, bvlist, lhs, rhs);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletffLetFormulaDefnEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffLetFormulaDefnEx; /* Prevent compiler warnings */
    ruletffLetFormulaDefnEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffLetFormulaDefn */

/**
 * $ANTLR start tffLetFormulaBinding
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1455:1: tffLetFormulaBinding[std::vector<cvc5::Term> & bvlist,\n cvc5::Term& lhs,\n cvc5::Term& rhs] : ( atomicFormula[lhs] IFF_TOK tffUnitaryFormula[rhs] | LPAREN_TOK tffLetFormulaBinding[bvlist, lhs, rhs] RPAREN_TOK );
 */
static void
tffLetFormulaBinding(pTptpParser ctx, std::vector<cvc5::Term> & bvlist, cvc5::Term& lhs, cvc5::Term& rhs)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1459:3: ( atomicFormula[lhs] IFF_TOK tffUnitaryFormula[rhs] | LPAREN_TOK tffLetFormulaBinding[bvlist, lhs, rhs] RPAREN_TOK )

            ANTLR3_UINT32 alt72;

            alt72=2;

            switch ( LA(1) )
            {
            case AND_TOK:
            case CNF_TOK:
            case DISTINCT_OBJECT:
            case FALSE_TOK:
            case FOF_TOK:
            case IMPLIES_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case NUMBER:
            case OR_TOK:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TRUE_TOK:
            case TYPE_TOK:
            case UPPER_WORD:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 74:
            case 75:
            case 77:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            	{
            		alt72=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt72=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 72;
                EXCEPTION->state        = 0;


                goto ruletffLetFormulaBindingEx;

            }

            switch (alt72)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1459:5: atomicFormula[lhs] IFF_TOK tffUnitaryFormula[rhs]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicFormula_in_tffLetFormulaBinding3761);
        	        atomicFormula(ctx, lhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	         MATCHT(IFF_TOK, &FOLLOW_IFF_TOK_in_tffLetFormulaBinding3764);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffUnitaryFormula_in_tffLetFormulaBinding3766);
        	        tffUnitaryFormula(ctx, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	        {

        	                PARSER_STATE->checkLetBinding(bvlist, lhs, rhs, true);
        	                std::vector<cvc5::Term> lchildren(++lhs.begin(), lhs.end());
        	                rhs = MK_TERM(cvc5::LAMBDA, MK_TERM(cvc5::VARIABLE_LIST, lchildren), rhs);
        	                // since lhs is always APPLY_UF (otherwise we'd have had a parser error in
        	                // checkLetBinding) the function to be replaced is always the first
        	                // argument. Note that the way in which lchildren is built above is also
        	                // relying on this.
        	                lhs = lhs[0];
        	              
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1470:5: LPAREN_TOK tffLetFormulaBinding[bvlist, lhs, rhs] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_tffLetFormulaBinding3777);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_tffLetFormulaBinding_in_tffLetFormulaBinding3779);
        	        tffLetFormulaBinding(ctx, bvlist, lhs, rhs);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_tffLetFormulaBinding3782);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletffLetFormulaBindingEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletffLetFormulaBindingEx; /* Prevent compiler warnings */
    ruletffLetFormulaBindingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffLetFormulaBinding */

/**
 * $ANTLR start thfBindVariable
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1473:1: thfBindVariable[cvc5::Term& expr] : UPPER_WORD ( COLON_TOK parseThfType[type] )? ;
 */
static void
thfBindVariable(pTptpParser ctx, cvc5::Term& expr)
{

      std::string name;
      cvc5::Sort type = PARSER_STATE->d_unsorted;

    pANTLR3_COMMON_TOKEN    UPPER_WORD6;

    /* Initialize rule variables
     */

    UPPER_WORD6       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1478:3: ( UPPER_WORD ( COLON_TOK parseThfType[type] )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1478:5: UPPER_WORD ( COLON_TOK parseThfType[type] )?
        {
            UPPER_WORD6 = (pANTLR3_COMMON_TOKEN) MATCHT(UPPER_WORD, &FOLLOW_UPPER_WORD_in_thfBindVariable3801);
            if  (HASEXCEPTION())
            {
                goto rulethfBindVariableEx;
            }


            {
                 name = AntlrInput::tokenText(UPPER_WORD6); 
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1480:5: ( COLON_TOK parseThfType[type] )?
            {
                int alt73=2;
                switch ( LA(1) )
                {
                    case COLON_TOK:
                    	{
                    		alt73=1;
                    	}
                        break;
                }

                switch (alt73)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1480:7: COLON_TOK parseThfType[type]
            	    {
            	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_thfBindVariable3815);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfBindVariableEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_parseThfType_in_thfBindVariable3817);
            	        parseThfType(ctx, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulethfBindVariableEx;
            	        }


            	    }
            	    break;

                }
            }

            {

                      expr = PARSER_STATE->bindBoundVar(name, type);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulethfBindVariableEx; /* Prevent compiler warnings */
    rulethfBindVariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfBindVariable */

/**
 * $ANTLR start tffbindvariable
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1487:1: tffbindvariable[cvc5::Term& expr] : UPPER_WORD ( COLON_TOK parseType[type] )? ;
 */
static void
tffbindvariable(pTptpParser ctx, cvc5::Term& expr)
{

      cvc5::Sort type = PARSER_STATE->d_unsorted;

    pANTLR3_COMMON_TOKEN    UPPER_WORD7;

    /* Initialize rule variables
     */

    UPPER_WORD7       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1491:3: ( UPPER_WORD ( COLON_TOK parseType[type] )? )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1491:5: UPPER_WORD ( COLON_TOK parseType[type] )?
        {
            UPPER_WORD7 = (pANTLR3_COMMON_TOKEN) MATCHT(UPPER_WORD, &FOLLOW_UPPER_WORD_in_tffbindvariable3847);
            if  (HASEXCEPTION())
            {
                goto ruletffbindvariableEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1492:5: ( COLON_TOK parseType[type] )?
            {
                int alt74=2;
                switch ( LA(1) )
                {
                    case COLON_TOK:
                    	{
                    		alt74=1;
                    	}
                        break;
                }

                switch (alt74)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1492:7: COLON_TOK parseType[type]
            	    {
            	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_tffbindvariable3855);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffbindvariableEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_parseType_in_tffbindvariable3857);
            	        parseType(ctx, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffbindvariableEx;
            	        }


            	    }
            	    break;

                }
            }

            {
                 std::string name = AntlrInput::tokenText(UPPER_WORD7);
                      expr = PARSER_STATE->bindBoundVar(name, type);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffbindvariableEx; /* Prevent compiler warnings */
    ruletffbindvariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffbindvariable */

/**
 * $ANTLR start tffVariableList
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1500:1: tffVariableList[std::vector<cvc5::Term>& bvlist] : tffbindvariable[e] ( COMMA_TOK tffbindvariable[e] )* ;
 */
static void
tffVariableList(pTptpParser ctx, std::vector<cvc5::Term>& bvlist)
{

      cvc5::Term e;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1504:3: ( tffbindvariable[e] ( COMMA_TOK tffbindvariable[e] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1504:5: tffbindvariable[e] ( COMMA_TOK tffbindvariable[e] )*
        {
            FOLLOWPUSH(FOLLOW_tffbindvariable_in_tffVariableList3888);
            tffbindvariable(ctx, e);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletffVariableListEx;
            }


            {
                 bvlist.push_back(e); 
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1505:5: ( COMMA_TOK tffbindvariable[e] )*

            for (;;)
            {
                int alt75=2;
                switch ( LA(1) )
                {
                case COMMA_TOK:
                	{
                		alt75=1;
                	}
                    break;

                }

                switch (alt75)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1505:7: COMMA_TOK tffbindvariable[e]
            	    {
            	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_tffVariableList3899);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffVariableListEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_tffbindvariable_in_tffVariableList3901);
            	        tffbindvariable(ctx, e);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletffVariableListEx;
            	        }


            	        {
            	             bvlist.push_back(e); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop75;	/* break out of the loop */
            	    break;
                }
            }
            loop75: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletffVariableListEx; /* Prevent compiler warnings */
    ruletffVariableListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end tffVariableList */

/**
 * $ANTLR start parseThfType
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1508:1: parseThfType[cvc5::Sort& type] : thfType[type] ( ( ARROW_TOK | TIMES_TOK ) thfType[type] )* ;
 */
static void
parseThfType(pTptpParser ctx, cvc5::Sort& type)
{

      std::vector<cvc5::Sort> sorts;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1513:3: ( thfType[type] ( ( ARROW_TOK | TIMES_TOK ) thfType[type] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1513:5: thfType[type] ( ( ARROW_TOK | TIMES_TOK ) thfType[type] )*
        {
            FOLLOWPUSH(FOLLOW_thfType_in_parseThfType3927);
            thfType(ctx, type);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparseThfTypeEx;
            }


            {
                 sorts.push_back(type); 
            }


            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1514:5: ( ( ARROW_TOK | TIMES_TOK ) thfType[type] )*

            for (;;)
            {
                int alt76=2;
                switch ( LA(1) )
                {
                case ARROW_TOK:
                case TIMES_TOK:
                	{
                		alt76=1;
                	}
                    break;

                }

                switch (alt76)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1515:6: ( ARROW_TOK | TIMES_TOK ) thfType[type]
            	    {
            	        if ( LA(1) == ARROW_TOK || LA(1) == TIMES_TOK )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleparseThfTypeEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_thfType_in_parseThfType3951);
            	        thfType(ctx, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparseThfTypeEx;
            	        }


            	        {
            	             sorts.push_back(type); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop76;	/* break out of the loop */
            	    break;
                }
            }
            loop76: ; /* Jump out to here if this rule does not match */


            {

                      if (sorts.size() < 1)
                      {
                        type = sorts[0];
                      }
                      else
                      {
                        cvc5::Sort range = sorts.back();
                        sorts.pop_back();
                        type = PARSER_STATE->mkFlatFunctionType(sorts, range);
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparseThfTypeEx; /* Prevent compiler warnings */
    ruleparseThfTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parseThfType */

/**
 * $ANTLR start thfType
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1531:1: thfType[cvc5::Sort& type] : ( simpleType[type] | LPAREN_TOK parseThfType[type] RPAREN_TOK | LBRACK_TOK parseThfType[type] RBRACK_TOK );
 */
static void
thfType(pTptpParser ctx, cvc5::Sort& type)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1533:3: ( simpleType[type] | LPAREN_TOK parseThfType[type] RPAREN_TOK | LBRACK_TOK parseThfType[type] RBRACK_TOK )

            ANTLR3_UINT32 alt77;

            alt77=3;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case DEFINED_SYMBOL:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt77=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt77=2;
            	}
                break;
            case LBRACK_TOK:
            	{
            		alt77=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 77;
                EXCEPTION->state        = 0;


                goto rulethfTypeEx;

            }

            switch (alt77)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1533:5: simpleType[type]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleType_in_thfType3982);
        	        simpleType(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1534:7: LPAREN_TOK parseThfType[type] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_thfType3991);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_parseThfType_in_thfType3993);
        	        parseThfType(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_thfType3996);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1535:7: LBRACK_TOK parseThfType[type] RBRACK_TOK
        	    {
        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_thfType4004);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	        {
        	             UNSUPPORTED("Tuple types"); 
        	        }


        	        FOLLOWPUSH(FOLLOW_parseThfType_in_thfType4008);
        	        parseThfType(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_thfType4011);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethfTypeEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulethfTypeEx; /* Prevent compiler warnings */
    rulethfTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end thfType */

/**
 * $ANTLR start parseType
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1538:1: parseType[cvc5::Sort & type] : ( simpleType[type] | ( simpleType[type] | LPAREN_TOK simpleType[type] ( TIMES_TOK simpleType[type] )+ RPAREN_TOK ) ARROW_TOK simpleType[type] );
 */
static void
parseType(pTptpParser ctx, cvc5::Sort & type)
{

      std::vector<cvc5::Sort> v;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1543:3: ( simpleType[type] | ( simpleType[type] | LPAREN_TOK simpleType[type] ( TIMES_TOK simpleType[type] )+ RPAREN_TOK ) ARROW_TOK simpleType[type] )

            ANTLR3_UINT32 alt80;

            alt80=2;

            switch ( LA(1) )
            {
            case DEFINED_SYMBOL:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 1;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case FOF_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 2;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case CNF_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 3;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case THF_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 4;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case TFF_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 5;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case TYPE_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 6;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case INCLUDE_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 7;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case LOWER_WORD:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 8;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case LOWER_WORD_SINGLE_QUOTED:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 9;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case SINGLE_QUOTED:
            	{
            		switch ( LA(2) )
            		{
            		case COMMA_TOK:
            		case RBRACK_TOK:
            		case RPAREN_TOK:
            			{
            				alt80=1;
            			}
            		    break;
            		case ARROW_TOK:
            			{
            				alt80=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 80;
            		    EXCEPTION->state        = 10;


            		    goto ruleparseTypeEx;

            		}

            	}
                break;
            case LPAREN_TOK:
            	{
            		alt80=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 80;
                EXCEPTION->state        = 0;


                goto ruleparseTypeEx;

            }

            switch (alt80)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1543:5: simpleType[type]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleType_in_parseType4030);
        	        simpleType(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseTypeEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1544:5: ( simpleType[type] | LPAREN_TOK simpleType[type] ( TIMES_TOK simpleType[type] )+ RPAREN_TOK ) ARROW_TOK simpleType[type]
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1544:5: ( simpleType[type] | LPAREN_TOK simpleType[type] ( TIMES_TOK simpleType[type] )+ RPAREN_TOK )
        	        {
        	            int alt79=2;
        	            switch ( LA(1) )
        	            {
        	            case CNF_TOK:
        	            case DEFINED_SYMBOL:
        	            case FOF_TOK:
        	            case INCLUDE_TOK:
        	            case LOWER_WORD:
        	            case LOWER_WORD_SINGLE_QUOTED:
        	            case SINGLE_QUOTED:
        	            case TFF_TOK:
        	            case THF_TOK:
        	            case TYPE_TOK:
        	            	{
        	            		alt79=1;
        	            	}
        	                break;
        	            case LPAREN_TOK:
        	            	{
        	            		alt79=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 79;
        	                EXCEPTION->state        = 0;


        	                goto ruleparseTypeEx;

        	            }

        	            switch (alt79)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1544:7: simpleType[type]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleType_in_parseType4039);
        	        	        simpleType(ctx, type);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseTypeEx;
        	        	        }


        	        	        {
        	        	             v.push_back(type); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1545:7: LPAREN_TOK simpleType[type] ( TIMES_TOK simpleType[type] )+ RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseType4050);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseTypeEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_simpleType_in_parseType4052);
        	        	        simpleType(ctx, type);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseTypeEx;
        	        	        }


        	        	        {
        	        	             v.push_back(type); 
        	        	        }


        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1546:7: ( TIMES_TOK simpleType[type] )+
        	        	        {
        	        	            int cnt78=0;

        	        	            for (;;)
        	        	            {
        	        	                int alt78=2;
        	        	        	switch ( LA(1) )
        	        	        	{
        	        	        	case TIMES_TOK:
        	        	        		{
        	        	        			alt78=1;
        	        	        		}
        	        	        	    break;

        	        	        	}

        	        	        	switch (alt78)
        	        	        	{
        	        	        	    case 1:
        	        	        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1546:9: TIMES_TOK simpleType[type]
        	        	        	        {
        	        	        	             MATCHT(TIMES_TOK, &FOLLOW_TIMES_TOK_in_parseType4065);
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto ruleparseTypeEx;
        	        	        	            }


        	        	        	            FOLLOWPUSH(FOLLOW_simpleType_in_parseType4067);
        	        	        	            simpleType(ctx, type);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto ruleparseTypeEx;
        	        	        	            }


        	        	        	            {
        	        	        	                 v.push_back(type); 
        	        	        	            }


        	        	        	        }
        	        	        	        break;

        	        	        	    default:

        	        	        		if ( cnt78 >= 1 )
        	        	        		{
        	        	        		    goto loop78;
        	        	        		}
        	        	        		/* mismatchedSetEx()
        	        	        		 */
        	        	        		CONSTRUCTEX();
        	        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        	        		goto ruleparseTypeEx;
        	        	        	}
        	        	        	cnt78++;
        	        	            }
        	        	            loop78: ;	/* Jump to here if this rule does not match */
        	        	        }

        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseType4081);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleparseTypeEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(ARROW_TOK, &FOLLOW_ARROW_TOK_in_parseType4093);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseTypeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_simpleType_in_parseType4095);
        	        simpleType(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseTypeEx;
        	        }


        	        {
        	             type = SOLVER->mkFunctionSort(v,type);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseTypeEx; /* Prevent compiler warnings */
    ruleparseTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parseType */

/**
 * $ANTLR start simpleType
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1555:1: simpleType[cvc5::Sort& type] : ( DEFINED_SYMBOL | atomicWord[name] );
 */
static void
simpleType(pTptpParser ctx, cvc5::Sort& type)
{

      std::string name;

    pANTLR3_COMMON_TOKEN    DEFINED_SYMBOL8;

    /* Initialize rule variables
     */

    DEFINED_SYMBOL8       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1559:3: ( DEFINED_SYMBOL | atomicWord[name] )

            ANTLR3_UINT32 alt81;

            alt81=2;

            switch ( LA(1) )
            {
            case DEFINED_SYMBOL:
            	{
            		alt81=1;
            	}
                break;
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt81=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 81;
                EXCEPTION->state        = 0;


                goto rulesimpleTypeEx;

            }

            switch (alt81)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1559:5: DEFINED_SYMBOL
        	    {
        	        DEFINED_SYMBOL8 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFINED_SYMBOL, &FOLLOW_DEFINED_SYMBOL_in_simpleType4122);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }


        	        {
        	             std::string s = AntlrInput::tokenText(DEFINED_SYMBOL8);
        	                  if(s == "$i") type = PARSER_STATE->d_unsorted;
        	                  else if(s == "$o") type = SOLVER->getBooleanSort();
        	                  else if(s == "$int") type = SOLVER->getIntegerSort();
        	                  else if(s == "$rat") type = SOLVER->getRealSort();
        	                  else if(s == "$real") type = SOLVER->getRealSort();
        	                  else if(s == "$tType") PARSER_STATE->parseError("Type of types `$tType' cannot be used here");
        	                  else PARSER_STATE->parseError("unknown defined type `" + s + "'");
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1569:5: atomicWord[name]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicWord_in_simpleType4134);
        	        atomicWord(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleTypeEx;
        	        }


        	        {
        	             type = PARSER_STATE->getSort(name); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleTypeEx; /* Prevent compiler warnings */
    rulesimpleTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleType */

/**
 * $ANTLR start anything
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1576:1: anything : ( LPAREN_TOK ( anything )* RPAREN_TOK | LBRACK_TOK ( anything )* RBRACK_TOK | COMMA_TOK | DOT_TOK | COLON_TOK | OR_TOK | NOT_TOK | FORALL_TOK | EXISTS_TOK | AND_TOK | IFF_TOK | IMPLIES_TOK | REVIMPLIES_TOK | REVIFF_TOK | REVOR_TOK | REVAND_TOK | TIMES_TOK | PLUS_TOK | MINUS_TOK | TRUE_TOK | FALSE_TOK | EQUAL_TOK | DISEQUAL_TOK | CNF_TOK | FOF_TOK | THF_TOK | TFF_TOK | TYPE_TOK | INCLUDE_TOK | DISTINCT_OBJECT | UPPER_WORD | LOWER_WORD | LOWER_WORD_SINGLE_QUOTED | SINGLE_QUOTED | NUMBER | DEFINED_SYMBOL );
 */
static void
anything(pTptpParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1577:3: ( LPAREN_TOK ( anything )* RPAREN_TOK | LBRACK_TOK ( anything )* RBRACK_TOK | COMMA_TOK | DOT_TOK | COLON_TOK | OR_TOK | NOT_TOK | FORALL_TOK | EXISTS_TOK | AND_TOK | IFF_TOK | IMPLIES_TOK | REVIMPLIES_TOK | REVIFF_TOK | REVOR_TOK | REVAND_TOK | TIMES_TOK | PLUS_TOK | MINUS_TOK | TRUE_TOK | FALSE_TOK | EQUAL_TOK | DISEQUAL_TOK | CNF_TOK | FOF_TOK | THF_TOK | TFF_TOK | TYPE_TOK | INCLUDE_TOK | DISTINCT_OBJECT | UPPER_WORD | LOWER_WORD | LOWER_WORD_SINGLE_QUOTED | SINGLE_QUOTED | NUMBER | DEFINED_SYMBOL )

            ANTLR3_UINT32 alt84;

            alt84=36;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt84=1;
            	}
                break;
            case LBRACK_TOK:
            	{
            		alt84=2;
            	}
                break;
            case COMMA_TOK:
            	{
            		alt84=3;
            	}
                break;
            case DOT_TOK:
            	{
            		alt84=4;
            	}
                break;
            case COLON_TOK:
            	{
            		alt84=5;
            	}
                break;
            case OR_TOK:
            	{
            		alt84=6;
            	}
                break;
            case NOT_TOK:
            	{
            		alt84=7;
            	}
                break;
            case FORALL_TOK:
            	{
            		alt84=8;
            	}
                break;
            case EXISTS_TOK:
            	{
            		alt84=9;
            	}
                break;
            case AND_TOK:
            	{
            		alt84=10;
            	}
                break;
            case IFF_TOK:
            	{
            		alt84=11;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt84=12;
            	}
                break;
            case REVIMPLIES_TOK:
            	{
            		alt84=13;
            	}
                break;
            case REVIFF_TOK:
            	{
            		alt84=14;
            	}
                break;
            case REVOR_TOK:
            	{
            		alt84=15;
            	}
                break;
            case REVAND_TOK:
            	{
            		alt84=16;
            	}
                break;
            case TIMES_TOK:
            	{
            		alt84=17;
            	}
                break;
            case PLUS_TOK:
            	{
            		alt84=18;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt84=19;
            	}
                break;
            case TRUE_TOK:
            	{
            		alt84=20;
            	}
                break;
            case FALSE_TOK:
            	{
            		alt84=21;
            	}
                break;
            case EQUAL_TOK:
            	{
            		alt84=22;
            	}
                break;
            case DISEQUAL_TOK:
            	{
            		alt84=23;
            	}
                break;
            case CNF_TOK:
            	{
            		alt84=24;
            	}
                break;
            case FOF_TOK:
            	{
            		alt84=25;
            	}
                break;
            case THF_TOK:
            	{
            		alt84=26;
            	}
                break;
            case TFF_TOK:
            	{
            		alt84=27;
            	}
                break;
            case TYPE_TOK:
            	{
            		alt84=28;
            	}
                break;
            case INCLUDE_TOK:
            	{
            		alt84=29;
            	}
                break;
            case DISTINCT_OBJECT:
            	{
            		alt84=30;
            	}
                break;
            case UPPER_WORD:
            	{
            		alt84=31;
            	}
                break;
            case LOWER_WORD:
            	{
            		alt84=32;
            	}
                break;
            case LOWER_WORD_SINGLE_QUOTED:
            	{
            		alt84=33;
            	}
                break;
            case SINGLE_QUOTED:
            	{
            		alt84=34;
            	}
                break;
            case NUMBER:
            	{
            		alt84=35;
            	}
                break;
            case DEFINED_SYMBOL:
            	{
            		alt84=36;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 84;
                EXCEPTION->state        = 0;


                goto ruleanythingEx;

            }

            switch (alt84)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1577:5: LPAREN_TOK ( anything )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_anything4159);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1577:16: ( anything )*

        	        for (;;)
        	        {
        	            int alt82=2;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            case CNF_TOK:
        	            case COLON_TOK:
        	            case COMMA_TOK:
        	            case DEFINED_SYMBOL:
        	            case DISEQUAL_TOK:
        	            case DISTINCT_OBJECT:
        	            case DOT_TOK:
        	            case EQUAL_TOK:
        	            case EXISTS_TOK:
        	            case FALSE_TOK:
        	            case FOF_TOK:
        	            case FORALL_TOK:
        	            case IFF_TOK:
        	            case IMPLIES_TOK:
        	            case INCLUDE_TOK:
        	            case LBRACK_TOK:
        	            case LOWER_WORD:
        	            case LOWER_WORD_SINGLE_QUOTED:
        	            case LPAREN_TOK:
        	            case MINUS_TOK:
        	            case NOT_TOK:
        	            case NUMBER:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case REVAND_TOK:
        	            case REVIFF_TOK:
        	            case REVIMPLIES_TOK:
        	            case REVOR_TOK:
        	            case SINGLE_QUOTED:
        	            case TFF_TOK:
        	            case THF_TOK:
        	            case TIMES_TOK:
        	            case TRUE_TOK:
        	            case TYPE_TOK:
        	            case UPPER_WORD:
        	            	{
        	            		alt82=1;
        	            	}
        	                break;

        	            }

        	            switch (alt82)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1577:16: anything
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_anything_in_anything4161);
        	        	        anything(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleanythingEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop82;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop82: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_anything4164);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1578:5: LBRACK_TOK ( anything )* RBRACK_TOK
        	    {
        	         MATCHT(LBRACK_TOK, &FOLLOW_LBRACK_TOK_in_anything4170);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1578:16: ( anything )*

        	        for (;;)
        	        {
        	            int alt83=2;
        	            switch ( LA(1) )
        	            {
        	            case AND_TOK:
        	            case CNF_TOK:
        	            case COLON_TOK:
        	            case COMMA_TOK:
        	            case DEFINED_SYMBOL:
        	            case DISEQUAL_TOK:
        	            case DISTINCT_OBJECT:
        	            case DOT_TOK:
        	            case EQUAL_TOK:
        	            case EXISTS_TOK:
        	            case FALSE_TOK:
        	            case FOF_TOK:
        	            case FORALL_TOK:
        	            case IFF_TOK:
        	            case IMPLIES_TOK:
        	            case INCLUDE_TOK:
        	            case LBRACK_TOK:
        	            case LOWER_WORD:
        	            case LOWER_WORD_SINGLE_QUOTED:
        	            case LPAREN_TOK:
        	            case MINUS_TOK:
        	            case NOT_TOK:
        	            case NUMBER:
        	            case OR_TOK:
        	            case PLUS_TOK:
        	            case REVAND_TOK:
        	            case REVIFF_TOK:
        	            case REVIMPLIES_TOK:
        	            case REVOR_TOK:
        	            case SINGLE_QUOTED:
        	            case TFF_TOK:
        	            case THF_TOK:
        	            case TIMES_TOK:
        	            case TRUE_TOK:
        	            case TYPE_TOK:
        	            case UPPER_WORD:
        	            	{
        	            		alt83=1;
        	            	}
        	                break;

        	            }

        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1578:16: anything
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_anything_in_anything4172);
        	        	        anything(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleanythingEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop83;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop83: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RBRACK_TOK, &FOLLOW_RBRACK_TOK_in_anything4175);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1579:5: COMMA_TOK
        	    {
        	         MATCHT(COMMA_TOK, &FOLLOW_COMMA_TOK_in_anything4181);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1580:5: DOT_TOK
        	    {
        	         MATCHT(DOT_TOK, &FOLLOW_DOT_TOK_in_anything4187);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1581:5: COLON_TOK
        	    {
        	         MATCHT(COLON_TOK, &FOLLOW_COLON_TOK_in_anything4193);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1582:5: OR_TOK
        	    {
        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_anything4199);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1583:5: NOT_TOK
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_anything4205);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1584:5: FORALL_TOK
        	    {
        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_anything4211);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1585:5: EXISTS_TOK
        	    {
        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_anything4217);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1586:5: AND_TOK
        	    {
        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_anything4223);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1587:5: IFF_TOK
        	    {
        	         MATCHT(IFF_TOK, &FOLLOW_IFF_TOK_in_anything4229);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1588:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_anything4235);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 13:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1589:5: REVIMPLIES_TOK
        	    {
        	         MATCHT(REVIMPLIES_TOK, &FOLLOW_REVIMPLIES_TOK_in_anything4241);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 14:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1590:5: REVIFF_TOK
        	    {
        	         MATCHT(REVIFF_TOK, &FOLLOW_REVIFF_TOK_in_anything4247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 15:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1591:5: REVOR_TOK
        	    {
        	         MATCHT(REVOR_TOK, &FOLLOW_REVOR_TOK_in_anything4253);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 16:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1592:5: REVAND_TOK
        	    {
        	         MATCHT(REVAND_TOK, &FOLLOW_REVAND_TOK_in_anything4259);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 17:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1593:5: TIMES_TOK
        	    {
        	         MATCHT(TIMES_TOK, &FOLLOW_TIMES_TOK_in_anything4265);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 18:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1594:5: PLUS_TOK
        	    {
        	         MATCHT(PLUS_TOK, &FOLLOW_PLUS_TOK_in_anything4271);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 19:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1595:5: MINUS_TOK
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_anything4277);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 20:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1596:5: TRUE_TOK
        	    {
        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_anything4283);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 21:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1597:5: FALSE_TOK
        	    {
        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_anything4289);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 22:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1598:5: EQUAL_TOK
        	    {
        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_anything4295);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 23:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1599:5: DISEQUAL_TOK
        	    {
        	         MATCHT(DISEQUAL_TOK, &FOLLOW_DISEQUAL_TOK_in_anything4301);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 24:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1600:5: CNF_TOK
        	    {
        	         MATCHT(CNF_TOK, &FOLLOW_CNF_TOK_in_anything4307);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 25:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1601:5: FOF_TOK
        	    {
        	         MATCHT(FOF_TOK, &FOLLOW_FOF_TOK_in_anything4313);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 26:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1602:5: THF_TOK
        	    {
        	         MATCHT(THF_TOK, &FOLLOW_THF_TOK_in_anything4319);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 27:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1603:5: TFF_TOK
        	    {
        	         MATCHT(TFF_TOK, &FOLLOW_TFF_TOK_in_anything4325);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 28:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1604:5: TYPE_TOK
        	    {
        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_anything4331);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 29:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1605:5: INCLUDE_TOK
        	    {
        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_anything4337);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 30:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1606:5: DISTINCT_OBJECT
        	    {
        	         MATCHT(DISTINCT_OBJECT, &FOLLOW_DISTINCT_OBJECT_in_anything4343);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 31:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1607:5: UPPER_WORD
        	    {
        	         MATCHT(UPPER_WORD, &FOLLOW_UPPER_WORD_in_anything4349);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 32:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1608:5: LOWER_WORD
        	    {
        	         MATCHT(LOWER_WORD, &FOLLOW_LOWER_WORD_in_anything4355);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 33:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1609:5: LOWER_WORD_SINGLE_QUOTED
        	    {
        	         MATCHT(LOWER_WORD_SINGLE_QUOTED, &FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_anything4361);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 34:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1610:5: SINGLE_QUOTED
        	    {
        	         MATCHT(SINGLE_QUOTED, &FOLLOW_SINGLE_QUOTED_in_anything4367);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 35:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1611:5: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_anything4373);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;
        	case 36:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1612:5: DEFINED_SYMBOL
        	    {
        	         MATCHT(DEFINED_SYMBOL, &FOLLOW_DEFINED_SYMBOL_in_anything4379);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanythingEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleanythingEx; /* Prevent compiler warnings */
    ruleanythingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end anything */

/**
 * $ANTLR start unquotedFileName
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1703:1: unquotedFileName[std::string& name] : (s= LOWER_WORD_SINGLE_QUOTED |s= SINGLE_QUOTED ) ;
 */
static void
unquotedFileName(pTptpParser ctx, std::string& name)
{
    pANTLR3_COMMON_TOKEN    s;

    /* Initialize rule variables
     */

    s       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1704:2: ( (s= LOWER_WORD_SINGLE_QUOTED |s= SINGLE_QUOTED ) )
        // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1704:4: (s= LOWER_WORD_SINGLE_QUOTED |s= SINGLE_QUOTED )
        {
            // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1704:4: (s= LOWER_WORD_SINGLE_QUOTED |s= SINGLE_QUOTED )
            {
                int alt85=2;
                switch ( LA(1) )
                {
                case LOWER_WORD_SINGLE_QUOTED:
                	{
                		alt85=1;
                	}
                    break;
                case SINGLE_QUOTED:
                	{
                		alt85=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 85;
                    EXCEPTION->state        = 0;


                    goto ruleunquotedFileNameEx;

                }

                switch (alt85)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1704:5: s= LOWER_WORD_SINGLE_QUOTED
            	    {
            	        s = (pANTLR3_COMMON_TOKEN) MATCHT(LOWER_WORD_SINGLE_QUOTED, &FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_unquotedFileName5059);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunquotedFileNameEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1704:34: s= SINGLE_QUOTED
            	    {
            	        s = (pANTLR3_COMMON_TOKEN) MATCHT(SINGLE_QUOTED, &FOLLOW_SINGLE_QUOTED_in_unquotedFileName5065);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunquotedFileNameEx;
            	        }


            	    }
            	    break;

                }
            }

            {
                 name = AntlrInput::tokenText(s);
                      name = name.substr(1, name.size() - 2 );
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunquotedFileNameEx; /* Prevent compiler warnings */
    ruleunquotedFileNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unquotedFileName */

/**
 * $ANTLR start nameN
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1710:1: nameN[std::string& name] : ( atomicWord[name] | NUMBER );
 */
static void
nameN(pTptpParser ctx, std::string& name)
{
    pANTLR3_COMMON_TOKEN    NUMBER9;

    /* Initialize rule variables
     */

    NUMBER9       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1711:2: ( atomicWord[name] | NUMBER )

            ANTLR3_UINT32 alt86;

            alt86=2;

            switch ( LA(1) )
            {
            case CNF_TOK:
            case FOF_TOK:
            case INCLUDE_TOK:
            case LOWER_WORD:
            case LOWER_WORD_SINGLE_QUOTED:
            case SINGLE_QUOTED:
            case TFF_TOK:
            case THF_TOK:
            case TYPE_TOK:
            	{
            		alt86=1;
            	}
                break;
            case NUMBER:
            	{
            		alt86=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 86;
                EXCEPTION->state        = 0;


                goto rulenameNEx;

            }

            switch (alt86)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1711:4: atomicWord[name]
        	    {
        	        FOLLOWPUSH(FOLLOW_atomicWord_in_nameN5084);
        	        atomicWord(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenameNEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1712:4: NUMBER
        	    {
        	        NUMBER9 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_nameN5090);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenameNEx;
        	        }


        	        {
        	             name = AntlrInput::tokenText(NUMBER9); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulenameNEx; /* Prevent compiler warnings */
    rulenameNEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nameN */

/**
 * $ANTLR start atomicWord
 * /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1716:1: atomicWord[std::string& name] : ( FOF_TOK | CNF_TOK | THF_TOK | TFF_TOK | TYPE_TOK | INCLUDE_TOK | LOWER_WORD | LOWER_WORD_SINGLE_QUOTED | SINGLE_QUOTED );
 */
static void
atomicWord(pTptpParser ctx, std::string& name)
{
    pANTLR3_COMMON_TOKEN    LOWER_WORD10;
    pANTLR3_COMMON_TOKEN    LOWER_WORD_SINGLE_QUOTED11;
    pANTLR3_COMMON_TOKEN    SINGLE_QUOTED12;

    /* Initialize rule variables
     */

    LOWER_WORD10       = NULL;
    LOWER_WORD_SINGLE_QUOTED11       = NULL;
    SINGLE_QUOTED12       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1717:2: ( FOF_TOK | CNF_TOK | THF_TOK | TFF_TOK | TYPE_TOK | INCLUDE_TOK | LOWER_WORD | LOWER_WORD_SINGLE_QUOTED | SINGLE_QUOTED )

            ANTLR3_UINT32 alt87;

            alt87=9;

            switch ( LA(1) )
            {
            case FOF_TOK:
            	{
            		alt87=1;
            	}
                break;
            case CNF_TOK:
            	{
            		alt87=2;
            	}
                break;
            case THF_TOK:
            	{
            		alt87=3;
            	}
                break;
            case TFF_TOK:
            	{
            		alt87=4;
            	}
                break;
            case TYPE_TOK:
            	{
            		alt87=5;
            	}
                break;
            case INCLUDE_TOK:
            	{
            		alt87=6;
            	}
                break;
            case LOWER_WORD:
            	{
            		alt87=7;
            	}
                break;
            case LOWER_WORD_SINGLE_QUOTED:
            	{
            		alt87=8;
            	}
                break;
            case SINGLE_QUOTED:
            	{
            		alt87=9;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 87;
                EXCEPTION->state        = 0;


                goto ruleatomicWordEx;

            }

            switch (alt87)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1717:4: FOF_TOK
        	    {
        	         MATCHT(FOF_TOK, &FOLLOW_FOF_TOK_in_atomicWord5106);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "fof"; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1718:4: CNF_TOK
        	    {
        	         MATCHT(CNF_TOK, &FOLLOW_CNF_TOK_in_atomicWord5117);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "cnf"; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1719:4: THF_TOK
        	    {
        	         MATCHT(THF_TOK, &FOLLOW_THF_TOK_in_atomicWord5128);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "thf"; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1720:4: TFF_TOK
        	    {
        	         MATCHT(TFF_TOK, &FOLLOW_TFF_TOK_in_atomicWord5139);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "tff"; 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1721:4: TYPE_TOK
        	    {
        	         MATCHT(TYPE_TOK, &FOLLOW_TYPE_TOK_in_atomicWord5150);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "type"; 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1722:4: INCLUDE_TOK
        	    {
        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_atomicWord5160);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = "include"; 
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1723:4: LOWER_WORD
        	    {
        	        LOWER_WORD10 = (pANTLR3_COMMON_TOKEN) MATCHT(LOWER_WORD, &FOLLOW_LOWER_WORD_in_atomicWord5167);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             name = AntlrInput::tokenText(LOWER_WORD10); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1724:4: LOWER_WORD_SINGLE_QUOTED
        	    {
        	        LOWER_WORD_SINGLE_QUOTED11 = (pANTLR3_COMMON_TOKEN) MATCHT(LOWER_WORD_SINGLE_QUOTED, &FOLLOW_LOWER_WORD_SINGLE_QUOTED_in_atomicWord5175);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	             /* strip off the quotes */
        	                  name = AntlrInput::tokenTextSubstr(LOWER_WORD_SINGLE_QUOTED11, 1 ,
        	                                                     (LOWER_WORD_SINGLE_QUOTED11->stop - LOWER_WORD_SINGLE_QUOTED11->start) - 1);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/tptp/Tptp.g:1729:4: SINGLE_QUOTED
        	    {
        	        SINGLE_QUOTED12 = (pANTLR3_COMMON_TOKEN) MATCHT(SINGLE_QUOTED, &FOLLOW_SINGLE_QUOTED_in_atomicWord5187);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomicWordEx;
        	        }


        	        {
        	            name = AntlrInput::tokenText(SINGLE_QUOTED12); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomicWordEx; /* Prevent compiler warnings */
    ruleatomicWordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end atomicWord */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
