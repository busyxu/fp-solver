/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g
 *     -                            On : 2024-03-19 12:01:48
 *     -                for the parser : Smt2ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/* ****************************************************************************
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2022 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Smt2Parser.h"


#include <set>
#include <sstream>
#include <string>
#include <unordered_set>
#include <vector>

#include <cvc5/cvc5.h>
#include "base/output.h"
#include "parser/antlr_input.h"
#include "parser/parser_antlr.h"
#include "parser/smt2/smt2_antlr.h"
#include "util/floatingpoint_size.h"
#include "util/hash.h"

using namespace cvc5;
using namespace cvc5::parser;

/* These need to be macros so they can refer to the PARSER macro, which
 * will be defined by ANTLR *after* this section. (If they were functions,
 * PARSER would be undefined.) */
#undef PARSER_BASE
#define PARSER_BASE ((Smt2*)PARSER->super)
#undef PARSER_STATE
#define PARSER_STATE PARSER_BASE->getSmt2State()
#undef SOLVER
#define SOLVER PARSER_STATE->getSolver()
#undef SYM_MAN
#define SYM_MAN PARSER_STATE->getSymbolManager()
#undef MK_TERM
#define MK_TERM(KIND, ...) SOLVER->mkTerm(KIND, {__VA_ARGS__})
#define UNSUPPORTED PARSER_STATE->unimplementedFeature


/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSmt2Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSmt2Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSmt2Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSmt2Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   Smt2ParserTokenNames[102+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "ASSERT_TOK",
        (pANTLR3_UINT8) "ASSUME_TOK",
        (pANTLR3_UINT8) "AS_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_INST_ADD_TO_POOL_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_INST_LEVEL",
        (pANTLR3_UINT8) "ATTRIBUTE_NAMED_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_NO_PATTERN_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_PATTERN_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_POOL_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_QUANTIFIER_ID_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK",
        (pANTLR3_UINT8) "ATTRIBUTE_TOK",
        (pANTLR3_UINT8) "BINARY_LITERAL",
        (pANTLR3_UINT8) "BLOCK_MODEL_TOK",
        (pANTLR3_UINT8) "BLOCK_MODEL_VALUES_TOK",
        (pANTLR3_UINT8) "CHAR_TOK",
        (pANTLR3_UINT8) "CHECK_SAT_ASSUMING_TOK",
        (pANTLR3_UINT8) "CHECK_SAT_TOK",
        (pANTLR3_UINT8) "CHECK_SYNTH_NEXT_TOK",
        (pANTLR3_UINT8) "CHECK_SYNTH_TOK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONSTRAINT_TOK",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "DECLARE_CODATATYPES_TOK",
        (pANTLR3_UINT8) "DECLARE_CODATATYPE_TOK",
        (pANTLR3_UINT8) "DECLARE_CONST_TOK",
        (pANTLR3_UINT8) "DECLARE_DATATYPES_TOK",
        (pANTLR3_UINT8) "DECLARE_DATATYPE_TOK",
        (pANTLR3_UINT8) "DECLARE_FUN_TOK",
        (pANTLR3_UINT8) "DECLARE_HEAP",
        (pANTLR3_UINT8) "DECLARE_POOL",
        (pANTLR3_UINT8) "DECLARE_SORT_TOK",
        (pANTLR3_UINT8) "DECLARE_VAR_TOK",
        (pANTLR3_UINT8) "DEFINE_CONST_TOK",
        (pANTLR3_UINT8) "DEFINE_FUNS_REC_TOK",
        (pANTLR3_UINT8) "DEFINE_FUN_REC_TOK",
        (pANTLR3_UINT8) "DEFINE_FUN_TOK",
        (pANTLR3_UINT8) "DEFINE_SORT_TOK",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "ECHO_TOK",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXIT_TOK",
        (pANTLR3_UINT8) "FIELD_LITERAL",
        (pANTLR3_UINT8) "FMF_CARD_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "GET_ABDUCT_NEXT_TOK",
        (pANTLR3_UINT8) "GET_ABDUCT_TOK",
        (pANTLR3_UINT8) "GET_ASSERTIONS_TOK",
        (pANTLR3_UINT8) "GET_ASSIGNMENT_TOK",
        (pANTLR3_UINT8) "GET_DIFFICULTY_TOK",
        (pANTLR3_UINT8) "GET_INFO_TOK",
        (pANTLR3_UINT8) "GET_INTERPOL_NEXT_TOK",
        (pANTLR3_UINT8) "GET_INTERPOL_TOK",
        (pANTLR3_UINT8) "GET_LEARNED_LITERALS_TOK",
        (pANTLR3_UINT8) "GET_MODEL_TOK",
        (pANTLR3_UINT8) "GET_OPTION_TOK",
        (pANTLR3_UINT8) "GET_PROOF_TOK",
        (pANTLR3_UINT8) "GET_QE_DISJUNCT_TOK",
        (pANTLR3_UINT8) "GET_QE_TOK",
        (pANTLR3_UINT8) "GET_UNSAT_ASSUMPTIONS_TOK",
        (pANTLR3_UINT8) "GET_UNSAT_CORE_TOK",
        (pANTLR3_UINT8) "GET_VALUE_TOK",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "HO_LAMBDA_TOK",
        (pANTLR3_UINT8) "INCLUDE_TOK",
        (pANTLR3_UINT8) "INDEX_TOK",
        (pANTLR3_UINT8) "INTEGER_LITERAL",
        (pANTLR3_UINT8) "INV_CONSTRAINT_TOK",
        (pANTLR3_UINT8) "KEYWORD",
        (pANTLR3_UINT8) "LET_TOK",
        (pANTLR3_UINT8) "LPAREN_TOK",
        (pANTLR3_UINT8) "MATCH_TOK",
        (pANTLR3_UINT8) "NUMERAL",
        (pANTLR3_UINT8) "PAR_TOK",
        (pANTLR3_UINT8) "POP_TOK",
        (pANTLR3_UINT8) "PUSH_TOK",
        (pANTLR3_UINT8) "QUOTED_SYMBOL",
        (pANTLR3_UINT8) "RESET_ASSERTIONS_TOK",
        (pANTLR3_UINT8) "RESET_TOK",
        (pANTLR3_UINT8) "RPAREN_TOK",
        (pANTLR3_UINT8) "SET_COMPREHENSION_TOK",
        (pANTLR3_UINT8) "SET_FEATURE_TOK",
        (pANTLR3_UINT8) "SET_INFO_TOK",
        (pANTLR3_UINT8) "SET_LOGIC_TOK",
        (pANTLR3_UINT8) "SET_OPTION_TOK",
        (pANTLR3_UINT8) "SIMPLE_SYMBOL",
        (pANTLR3_UINT8) "SIMPLIFY_TOK",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "SYGUS_CONSTANT_TOK",
        (pANTLR3_UINT8) "SYGUS_VARIABLE_TOK",
        (pANTLR3_UINT8) "SYMBOL_CHAR",
        (pANTLR3_UINT8) "SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE",
        (pANTLR3_UINT8) "SYNTH_FUN_TOK",
        (pANTLR3_UINT8) "SYNTH_INV_TOK",
        (pANTLR3_UINT8) "TESTER_TOK",
        (pANTLR3_UINT8) "UNTERMINATED_QUOTED_SYMBOL",
        (pANTLR3_UINT8) "UNTERMINATED_STRING_LITERAL",
        (pANTLR3_UINT8) "UPDATE_TOK",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'\\\\'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 cvc5::Term
	parseExpr    (pSmt2Parser ctx);
static 
 std::unique_ptr<cvc5::parser::Command>
	parseCommand    (pSmt2Parser ctx);
static 
 std::unique_ptr<cvc5::parser::Command>
	parseSygus    (pSmt2Parser ctx);
static 
 void
	command    (pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 std::unique_ptr<cvc5::parser::Command>
	sygusCommand    (pSmt2Parser ctx);
static 
 void
	sygusGrammar    (pSmt2Parser ctx, cvc5::Grammar*& ret, const std::vector<cvc5::Term>& sygusVars, const std::string& fun);
static 
 void
	setInfoInternal    (pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	setOptionInternal    (pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	smt25Command    (pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	extendedCommand    (pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	datatypeDefCommand    (pSmt2Parser ctx, bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	datatypesDefCommand    (pSmt2Parser ctx, bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	datatypesDef    (pSmt2Parser ctx, bool isCo, const std::vector<std::string>& dnames, const std::vector<int>& arities, std::unique_ptr<cvc5::parser::Command>* cmd);
static 
 void
	simpleSymbolicExprNoKeyword    (pSmt2Parser ctx, std::string& s);
static 
 void
	keyword    (pSmt2Parser ctx, std::string& s);
static 
 void
	simpleSymbolicExpr    (pSmt2Parser ctx, std::string& s);
static 
 void
	symbolicExpr    (pSmt2Parser ctx, cvc5::Term& sexpr);
static 
 void
	term    (pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& expr2);
static 
 void
	termNonVariable    (pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& expr2);
static 
 void
	qualIdentifier    (pSmt2Parser ctx, cvc5::ParseOp& p);
static 
 void
	identifier    (pSmt2Parser ctx, cvc5::ParseOp& p);
static 
 void
	termAtomic    (pSmt2Parser ctx, cvc5::Term& atomTerm);
static 
 void
	attribute    (pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& retExpr);
static 
 void
	termList    (pSmt2Parser ctx, std::vector<cvc5::Term>& formulas, cvc5::Term& expr);
static 
 void
	str    (pSmt2Parser ctx, std::string& s, bool unescape);
static 
 void
	quantOp    (pSmt2Parser ctx, cvc5::Kind& kind);
static 
 void
	functionName    (pSmt2Parser ctx, std::string& name, cvc5::parser::DeclarationCheck check);
static 
 void
	sortList    (pSmt2Parser ctx, std::vector<cvc5::Sort>& sorts);
static 
 void
	nonemptySortList    (pSmt2Parser ctx, std::vector<cvc5::Sort>& sorts);
static 
 void
	sortedVarList    (pSmt2Parser ctx, std::vector<std::pair<std::string, cvc5::Sort> >& sortedVars);
static 
 void
	boundVarList    (pSmt2Parser ctx, cvc5::Term& expr);
static 
 void
	sortName    (pSmt2Parser ctx, std::string& name, cvc5::parser::DeclarationCheck check);
static 
 void
	sortSymbol    (pSmt2Parser ctx, cvc5::Sort& t);
static 
 void
	symbolList    (pSmt2Parser ctx, std::vector<std::string>& names, cvc5::parser::DeclarationCheck check, cvc5::parser::SymbolType type);
static 
 void
	symbol    (pSmt2Parser ctx, std::string& id, cvc5::parser::DeclarationCheck check, cvc5::parser::SymbolType type);
static 
 void
	nonemptyNumeralList    (pSmt2Parser ctx, std::vector<uint32_t>& numerals);
static 
 void
	nonemptyNumeralStringList    (pSmt2Parser ctx, std::vector<std::string>& numeralStrings);
static 
 void
	datatypeDef    (pSmt2Parser ctx, bool isCo, std::vector<cvc5::DatatypeDecl>& datatypes, std::vector< cvc5::Sort >& params);
static 
 void
	constructorDef    (pSmt2Parser ctx, cvc5::DatatypeDecl& type);
static 
 void
	selector    (pSmt2Parser ctx, cvc5::DatatypeConstructorDecl& ctor);
static void	Smt2ParserFree(pSmt2Parser ctx);
static void     Smt2ParserReset (pSmt2Parser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new Smt2Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt2Parser
Smt2ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return Smt2ParserNewSSD(instream, NULL);
}

/** \brief Create a new Smt2Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt2Parser
Smt2ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSmt2Parser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSmt2Parser) ANTLR3_CALLOC(1, sizeof(Smt2Parser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Smt2Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our Smt2Parser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->parseSygus	= parseSygus;
    ctx->command	= command;
    ctx->sygusCommand	= sygusCommand;
    ctx->sygusGrammar	= sygusGrammar;
    ctx->setInfoInternal	= setInfoInternal;
    ctx->setOptionInternal	= setOptionInternal;
    ctx->smt25Command	= smt25Command;
    ctx->extendedCommand	= extendedCommand;
    ctx->datatypeDefCommand	= datatypeDefCommand;
    ctx->datatypesDefCommand	= datatypesDefCommand;
    ctx->datatypesDef	= datatypesDef;
    ctx->simpleSymbolicExprNoKeyword	= simpleSymbolicExprNoKeyword;
    ctx->keyword	= keyword;
    ctx->simpleSymbolicExpr	= simpleSymbolicExpr;
    ctx->symbolicExpr	= symbolicExpr;
    ctx->term	= term;
    ctx->termNonVariable	= termNonVariable;
    ctx->qualIdentifier	= qualIdentifier;
    ctx->identifier	= identifier;
    ctx->termAtomic	= termAtomic;
    ctx->attribute	= attribute;
    ctx->termList	= termList;
    ctx->str	= str;
    ctx->quantOp	= quantOp;
    ctx->functionName	= functionName;
    ctx->sortList	= sortList;
    ctx->nonemptySortList	= nonemptySortList;
    ctx->sortedVarList	= sortedVarList;
    ctx->boundVarList	= boundVarList;
    ctx->sortName	= sortName;
    ctx->sortSymbol	= sortSymbol;
    ctx->symbolList	= symbolList;
    ctx->symbol	= symbol;
    ctx->nonemptyNumeralList	= nonemptyNumeralList;
    ctx->nonemptyNumeralStringList	= nonemptyNumeralStringList;
    ctx->datatypeDef	= datatypeDef;
    ctx->constructorDef	= constructorDef;
    ctx->selector	= selector;
    ctx->free			= Smt2ParserFree;
    ctx->reset			= Smt2ParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = Smt2ParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
Smt2ParserReset (pSmt2Parser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 Smt2ParserFree(pSmt2Parser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return Smt2ParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_parseExpr117  */
static	ANTLR3_BITWORD FOLLOW_term_in_parseExpr117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_parseExpr117	= { FOLLOW_term_in_parseExpr117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr124  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr124	= { FOLLOW_EOF_in_parseExpr124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand153  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand153_bits[]	= { ANTLR3_UINT64_LIT(0xFFFC57DFF06C0020), ANTLR3_UINT64_LIT(0x000000001F1B0007) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand153	= { FOLLOW_LPAREN_TOK_in_parseCommand153_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_parseCommand155  */
static	ANTLR3_BITWORD FOLLOW_command_in_parseCommand155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_parseCommand155	= { FOLLOW_command_in_parseCommand155_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand158  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand158	= { FOLLOW_RPAREN_TOK_in_parseCommand158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand171  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand171	= { FOLLOW_LPAREN_TOK_in_parseCommand171_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCLUDE_TOK_in_parseCommand173  */
static	ANTLR3_BITWORD FOLLOW_INCLUDE_TOK_in_parseCommand173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INCLUDE_TOK_in_parseCommand173	= { FOLLOW_INCLUDE_TOK_in_parseCommand173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_parseCommand175  */
static	ANTLR3_BITWORD FOLLOW_str_in_parseCommand175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_parseCommand175	= { FOLLOW_str_in_parseCommand175_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseCommand178  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseCommand178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseCommand178	= { FOLLOW_RPAREN_TOK_in_parseCommand178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseCommand191  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseCommand191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseCommand191	= { FOLLOW_EOF_in_parseCommand191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseSygus220  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseSygus220_bits[]	= { ANTLR3_UINT64_LIT(0xFFFC57FFF5EC0060), ANTLR3_UINT64_LIT(0x0000000C1F9B0207) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseSygus220	= { FOLLOW_LPAREN_TOK_in_parseSygus220_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusCommand_in_parseSygus224  */
static	ANTLR3_BITWORD FOLLOW_sygusCommand_in_parseSygus224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusCommand_in_parseSygus224	= { FOLLOW_sygusCommand_in_parseSygus224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_parseSygus226  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_parseSygus226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_parseSygus226	= { FOLLOW_RPAREN_TOK_in_parseSygus226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseSygus232  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseSygus232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseSygus232	= { FOLLOW_EOF_in_parseSygus232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_LOGIC_TOK_in_command260  */
static	ANTLR3_BITWORD FOLLOW_SET_LOGIC_TOK_in_command260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_LOGIC_TOK_in_command260	= { FOLLOW_SET_LOGIC_TOK_in_command260_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command262  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command262	= { FOLLOW_symbol_in_command262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_INFO_TOK_in_command281  */
static	ANTLR3_BITWORD FOLLOW_SET_INFO_TOK_in_command281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_INFO_TOK_in_command281	= { FOLLOW_SET_INFO_TOK_in_command281_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setInfoInternal_in_command283  */
static	ANTLR3_BITWORD FOLLOW_setInfoInternal_in_command283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setInfoInternal_in_command283	= { FOLLOW_setInfoInternal_in_command283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_INFO_TOK_in_command296  */
static	ANTLR3_BITWORD FOLLOW_GET_INFO_TOK_in_command296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_INFO_TOK_in_command296	= { FOLLOW_GET_INFO_TOK_in_command296_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command298  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command298	= { FOLLOW_KEYWORD_in_command298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_OPTION_TOK_in_command316  */
static	ANTLR3_BITWORD FOLLOW_SET_OPTION_TOK_in_command316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_OPTION_TOK_in_command316	= { FOLLOW_SET_OPTION_TOK_in_command316_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setOptionInternal_in_command318  */
static	ANTLR3_BITWORD FOLLOW_setOptionInternal_in_command318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setOptionInternal_in_command318	= { FOLLOW_setOptionInternal_in_command318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_OPTION_TOK_in_command331  */
static	ANTLR3_BITWORD FOLLOW_GET_OPTION_TOK_in_command331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_OPTION_TOK_in_command331	= { FOLLOW_GET_OPTION_TOK_in_command331_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command333  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command333	= { FOLLOW_KEYWORD_in_command333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_SORT_TOK_in_command351  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_SORT_TOK_in_command351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_SORT_TOK_in_command351	= { FOLLOW_DECLARE_SORT_TOK_in_command351_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command363  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command363	= { FOLLOW_symbol_in_command363_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command378  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command378	= { FOLLOW_INTEGER_LITERAL_in_command378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_SORT_TOK_in_command396  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_SORT_TOK_in_command396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_SORT_TOK_in_command396	= { FOLLOW_DEFINE_SORT_TOK_in_command396_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command404  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command404	= { FOLLOW_symbol_in_command404_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command417  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command417_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008240000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command417	= { FOLLOW_LPAREN_TOK_in_command417_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolList_in_command419  */
static	ANTLR3_BITWORD FOLLOW_symbolList_in_command419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolList_in_command419	= { FOLLOW_symbolList_in_command419_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command422  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command422	= { FOLLOW_RPAREN_TOK_in_command422_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command434  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command434	= { FOLLOW_sortSymbol_in_command434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_FUN_TOK_in_command453  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_FUN_TOK_in_command453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_FUN_TOK_in_command453	= { FOLLOW_DECLARE_FUN_TOK_in_command453_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command461  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command461	= { FOLLOW_symbol_in_command461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command474  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008241000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command474	= { FOLLOW_LPAREN_TOK_in_command474_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_command476  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_command476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_command476	= { FOLLOW_sortList_in_command476_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command479  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command479	= { FOLLOW_RPAREN_TOK_in_command479_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command485  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command485	= { FOLLOW_sortSymbol_in_command485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUN_TOK_in_command504  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUN_TOK_in_command504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUN_TOK_in_command504	= { FOLLOW_DEFINE_FUN_TOK_in_command504_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_command512  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_command512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_command512	= { FOLLOW_symbol_in_command512_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command525  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command525	= { FOLLOW_LPAREN_TOK_in_command525_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_command527  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_command527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_command527	= { FOLLOW_sortedVarList_in_command527_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command530  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command530	= { FOLLOW_RPAREN_TOK_in_command530_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_command536  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_command536_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_command536	= { FOLLOW_sortSymbol_in_command536_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_command549  */
static	ANTLR3_BITWORD FOLLOW_term_in_command549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_command549	= { FOLLOW_term_in_command549_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_DATATYPE_TOK_in_command562  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_DATATYPE_TOK_in_command562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_DATATYPE_TOK_in_command562	= { FOLLOW_DECLARE_DATATYPE_TOK_in_command562_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypeDefCommand_in_command564  */
static	ANTLR3_BITWORD FOLLOW_datatypeDefCommand_in_command564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypeDefCommand_in_command564	= { FOLLOW_datatypeDefCommand_in_command564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_DATATYPES_TOK_in_command571  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_DATATYPES_TOK_in_command571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_DATATYPES_TOK_in_command571	= { FOLLOW_DECLARE_DATATYPES_TOK_in_command571_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDefCommand_in_command573  */
static	ANTLR3_BITWORD FOLLOW_datatypesDefCommand_in_command573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDefCommand_in_command573	= { FOLLOW_datatypesDefCommand_in_command573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_VALUE_TOK_in_command586  */
static	ANTLR3_BITWORD FOLLOW_GET_VALUE_TOK_in_command586_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR3_UINT64_LIT(0x000003FFFFFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_VALUE_TOK_in_command586	= { FOLLOW_GET_VALUE_TOK_in_command586_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command600  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command600_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command600	= { FOLLOW_LPAREN_TOK_in_command600_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_command602  */
static	ANTLR3_BITWORD FOLLOW_termList_in_command602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_command602	= { FOLLOW_termList_in_command602_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command605  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command605	= { FOLLOW_RPAREN_TOK_in_command605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_command621  */
static	ANTLR3_BITWORD FOLLOW_set_in_command621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_command621	= { FOLLOW_set_in_command621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ASSIGNMENT_TOK_in_command654  */
static	ANTLR3_BITWORD FOLLOW_GET_ASSIGNMENT_TOK_in_command654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ASSIGNMENT_TOK_in_command654	= { FOLLOW_GET_ASSIGNMENT_TOK_in_command654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSERT_TOK_in_command674  */
static	ANTLR3_BITWORD FOLLOW_ASSERT_TOK_in_command674_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSERT_TOK_in_command674	= { FOLLOW_ASSERT_TOK_in_command674_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_command688  */
static	ANTLR3_BITWORD FOLLOW_term_in_command688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_command688	= { FOLLOW_term_in_command688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SAT_TOK_in_command707  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SAT_TOK_in_command707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SAT_TOK_in_command707	= { FOLLOW_CHECK_SAT_TOK_in_command707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SAT_ASSUMING_TOK_in_command727  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SAT_ASSUMING_TOK_in_command727_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR3_UINT64_LIT(0x000003FFFFFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SAT_ASSUMING_TOK_in_command727	= { FOLLOW_CHECK_SAT_ASSUMING_TOK_in_command727_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_command737  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_command737_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_command737	= { FOLLOW_LPAREN_TOK_in_command737_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_command739  */
static	ANTLR3_BITWORD FOLLOW_termList_in_command739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_command739	= { FOLLOW_termList_in_command739_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_command742  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_command742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_command742	= { FOLLOW_RPAREN_TOK_in_command742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_command758  */
static	ANTLR3_BITWORD FOLLOW_set_in_command758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_command758	= { FOLLOW_set_in_command758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ASSERTIONS_TOK_in_command785  */
static	ANTLR3_BITWORD FOLLOW_GET_ASSERTIONS_TOK_in_command785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ASSERTIONS_TOK_in_command785	= { FOLLOW_GET_ASSERTIONS_TOK_in_command785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_PROOF_TOK_in_command805  */
static	ANTLR3_BITWORD FOLLOW_GET_PROOF_TOK_in_command805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_PROOF_TOK_in_command805	= { FOLLOW_GET_PROOF_TOK_in_command805_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command809  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command809	= { FOLLOW_KEYWORD_in_command809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_UNSAT_ASSUMPTIONS_TOK_in_command829  */
static	ANTLR3_BITWORD FOLLOW_GET_UNSAT_ASSUMPTIONS_TOK_in_command829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_UNSAT_ASSUMPTIONS_TOK_in_command829	= { FOLLOW_GET_UNSAT_ASSUMPTIONS_TOK_in_command829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_UNSAT_CORE_TOK_in_command849  */
static	ANTLR3_BITWORD FOLLOW_GET_UNSAT_CORE_TOK_in_command849_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_UNSAT_CORE_TOK_in_command849	= { FOLLOW_GET_UNSAT_CORE_TOK_in_command849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_DIFFICULTY_TOK_in_command869  */
static	ANTLR3_BITWORD FOLLOW_GET_DIFFICULTY_TOK_in_command869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_DIFFICULTY_TOK_in_command869	= { FOLLOW_GET_DIFFICULTY_TOK_in_command869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_LEARNED_LITERALS_TOK_in_command889  */
static	ANTLR3_BITWORD FOLLOW_GET_LEARNED_LITERALS_TOK_in_command889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_LEARNED_LITERALS_TOK_in_command889	= { FOLLOW_GET_LEARNED_LITERALS_TOK_in_command889_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_command893  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_command893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_command893	= { FOLLOW_KEYWORD_in_command893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUSH_TOK_in_command912  */
static	ANTLR3_BITWORD FOLLOW_PUSH_TOK_in_command912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_PUSH_TOK_in_command912	= { FOLLOW_PUSH_TOK_in_command912_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command922  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command922	= { FOLLOW_INTEGER_LITERAL_in_command922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POP_TOK_in_command956  */
static	ANTLR3_BITWORD FOLLOW_POP_TOK_in_command956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_POP_TOK_in_command956	= { FOLLOW_POP_TOK_in_command956_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_command966  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_command966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_command966	= { FOLLOW_INTEGER_LITERAL_in_command966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXIT_TOK_in_command1000  */
static	ANTLR3_BITWORD FOLLOW_EXIT_TOK_in_command1000_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXIT_TOK_in_command1000	= { FOLLOW_EXIT_TOK_in_command1000_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_smt25Command_in_command1019  */
static	ANTLR3_BITWORD FOLLOW_smt25Command_in_command1019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_smt25Command_in_command1019	= { FOLLOW_smt25Command_in_command1019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extendedCommand_in_command1033  */
static	ANTLR3_BITWORD FOLLOW_extendedCommand_in_command1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extendedCommand_in_command1033	= { FOLLOW_extendedCommand_in_command1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_command1053  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_command1053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_command1053	= { FOLLOW_SIMPLE_SYMBOL_in_command1053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_VAR_TOK_in_sygusCommand1087  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_VAR_TOK_in_sygusCommand1087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_VAR_TOK_in_sygusCommand1087	= { FOLLOW_DECLARE_VAR_TOK_in_sygusCommand1087_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1095  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1095	= { FOLLOW_symbol_in_sygusCommand1095_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1108  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1108	= { FOLLOW_sortSymbol_in_sygusCommand1108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1129  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1129	= { FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1129_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTH_INV_TOK_in_sygusCommand1141  */
static	ANTLR3_BITWORD FOLLOW_SYNTH_INV_TOK_in_sygusCommand1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTH_INV_TOK_in_sygusCommand1141	= { FOLLOW_SYNTH_INV_TOK_in_sygusCommand1141_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1161  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1161	= { FOLLOW_symbol_in_sygusCommand1161_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusCommand1168  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusCommand1168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusCommand1168	= { FOLLOW_LPAREN_TOK_in_sygusCommand1168_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_sygusCommand1170  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_sygusCommand1170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_sygusCommand1170	= { FOLLOW_sortedVarList_in_sygusCommand1170_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusCommand1173  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusCommand1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusCommand1173	= { FOLLOW_RPAREN_TOK_in_sygusCommand1173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusCommand1181  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusCommand1181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusCommand1181	= { FOLLOW_sortSymbol_in_sygusCommand1181_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGrammar_in_sygusCommand1233  */
static	ANTLR3_BITWORD FOLLOW_sygusGrammar_in_sygusCommand1233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGrammar_in_sygusCommand1233	= { FOLLOW_sygusGrammar_in_sygusCommand1233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINT_TOK_in_sygusCommand1261  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINT_TOK_in_sygusCommand1261_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINT_TOK_in_sygusCommand1261	= { FOLLOW_CONSTRAINT_TOK_in_sygusCommand1261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSUME_TOK_in_sygusCommand1267  */
static	ANTLR3_BITWORD FOLLOW_ASSUME_TOK_in_sygusCommand1267_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSUME_TOK_in_sygusCommand1267	= { FOLLOW_ASSUME_TOK_in_sygusCommand1267_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_sygusCommand1283  */
static	ANTLR3_BITWORD FOLLOW_term_in_sygusCommand1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_sygusCommand1283	= { FOLLOW_term_in_sygusCommand1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1302  */
static	ANTLR3_BITWORD FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1302	= { FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1302_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusCommand1310  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusCommand1310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusCommand1310	= { FOLLOW_symbol_in_sygusCommand1310_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1334  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1334	= { FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHECK_SYNTH_NEXT_TOK_in_sygusCommand1352  */
static	ANTLR3_BITWORD FOLLOW_CHECK_SYNTH_NEXT_TOK_in_sygusCommand1352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHECK_SYNTH_NEXT_TOK_in_sygusCommand1352	= { FOLLOW_CHECK_SYNTH_NEXT_TOK_in_sygusCommand1352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_FEATURE_TOK_in_sygusCommand1370  */
static	ANTLR3_BITWORD FOLLOW_SET_FEATURE_TOK_in_sygusCommand1370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_FEATURE_TOK_in_sygusCommand1370	= { FOLLOW_SET_FEATURE_TOK_in_sygusCommand1370_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyword_in_sygusCommand1372  */
static	ANTLR3_BITWORD FOLLOW_keyword_in_sygusCommand1372_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620020), ANTLR3_UINT64_LIT(0x000000603F1F1517) };
static  ANTLR3_BITSET_LIST FOLLOW_keyword_in_sygusCommand1372	= { FOLLOW_keyword_in_sygusCommand1372_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_sygusCommand1375  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_sygusCommand1375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_sygusCommand1375	= { FOLLOW_symbolicExpr_in_sygusCommand1375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_sygusCommand1388  */
static	ANTLR3_BITWORD FOLLOW_command_in_sygusCommand1388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_sygusCommand1388	= { FOLLOW_command_in_sygusCommand1388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1416  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1416	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1416_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1431  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1431	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1431_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGrammar1433  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGrammar1433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGrammar1433	= { FOLLOW_symbol_in_sygusGrammar1433_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGrammar1440  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGrammar1440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGrammar1440	= { FOLLOW_sortSymbol_in_sygusGrammar1440_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1465  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1465	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1465_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1481  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1481	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1481_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1498  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1498	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1498_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1509  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1509	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1509_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1519  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1519	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1519_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sygusGrammar1525  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sygusGrammar1525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sygusGrammar1525	= { FOLLOW_symbol_in_sygusGrammar1525_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGrammar1528  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGrammar1528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGrammar1528	= { FOLLOW_sortSymbol_in_sygusGrammar1528_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1541  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1541_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1541	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1541_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_sygusGrammar1555  */
static	ANTLR3_BITWORD FOLLOW_term_in_sygusGrammar1555_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_sygusGrammar1555	= { FOLLOW_term_in_sygusGrammar1555_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1568  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1568	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1568_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGrammar1570  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGrammar1570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGrammar1570	= { FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGrammar1570_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGrammar1572  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGrammar1572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGrammar1572	= { FOLLOW_sortSymbol_in_sygusGrammar1572_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1575  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1575	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1575_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sygusGrammar1587  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sygusGrammar1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sygusGrammar1587	= { FOLLOW_LPAREN_TOK_in_sygusGrammar1587_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGrammar1589  */
static	ANTLR3_BITWORD FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGrammar1589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGrammar1589	= { FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGrammar1589_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sygusGrammar1591  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sygusGrammar1591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sygusGrammar1591	= { FOLLOW_sortSymbol_in_sygusGrammar1591_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1594  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1594_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1594	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1594_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1609  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1609	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1609_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1615  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1615	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1615_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sygusGrammar1630  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sygusGrammar1630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sygusGrammar1630	= { FOLLOW_RPAREN_TOK_in_sygusGrammar1630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyword_in_setInfoInternal1651  */
static	ANTLR3_BITWORD FOLLOW_keyword_in_setInfoInternal1651_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620020), ANTLR3_UINT64_LIT(0x000000603F1F1517) };
static  ANTLR3_BITSET_LIST FOLLOW_keyword_in_setInfoInternal1651	= { FOLLOW_keyword_in_setInfoInternal1651_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_setInfoInternal1654  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_setInfoInternal1654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_setInfoInternal1654	= { FOLLOW_symbolicExpr_in_setInfoInternal1654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyword_in_setOptionInternal1680  */
static	ANTLR3_BITWORD FOLLOW_keyword_in_setOptionInternal1680_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620020), ANTLR3_UINT64_LIT(0x000000603F1F1517) };
static  ANTLR3_BITSET_LIST FOLLOW_keyword_in_setOptionInternal1680	= { FOLLOW_keyword_in_setOptionInternal1680_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_setOptionInternal1683  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_setOptionInternal1683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_setOptionInternal1683	= { FOLLOW_symbolicExpr_in_setOptionInternal1683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_CONST_TOK_in_smt25Command1715  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_CONST_TOK_in_smt25Command1715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_CONST_TOK_in_smt25Command1715	= { FOLLOW_DECLARE_CONST_TOK_in_smt25Command1715_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command1723  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command1723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command1723	= { FOLLOW_symbol_in_smt25Command1723_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command1736  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command1736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command1736	= { FOLLOW_sortSymbol_in_smt25Command1736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_MODEL_TOK_in_smt25Command1756  */
static	ANTLR3_BITWORD FOLLOW_GET_MODEL_TOK_in_smt25Command1756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_MODEL_TOK_in_smt25Command1756	= { FOLLOW_GET_MODEL_TOK_in_smt25Command1756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECHO_TOK_in_smt25Command1777  */
static	ANTLR3_BITWORD FOLLOW_ECHO_TOK_in_smt25Command1777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000004020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ECHO_TOK_in_smt25Command1777	= { FOLLOW_ECHO_TOK_in_smt25Command1777_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_smt25Command1785  */
static	ANTLR3_BITWORD FOLLOW_str_in_smt25Command1785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_smt25Command1785	= { FOLLOW_str_in_smt25Command1785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_TOK_in_smt25Command1821  */
static	ANTLR3_BITWORD FOLLOW_RESET_TOK_in_smt25Command1821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_TOK_in_smt25Command1821	= { FOLLOW_RESET_TOK_in_smt25Command1821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1839  */
static	ANTLR3_BITWORD FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1839	= { FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1851  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1851	= { FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1851_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command1863  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command1863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command1863	= { FOLLOW_symbol_in_smt25Command1863_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command1876  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command1876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command1876	= { FOLLOW_LPAREN_TOK_in_smt25Command1876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_smt25Command1878  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_smt25Command1878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_smt25Command1878	= { FOLLOW_sortedVarList_in_smt25Command1878_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command1881  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command1881	= { FOLLOW_RPAREN_TOK_in_smt25Command1881_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command1887  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command1887_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command1887	= { FOLLOW_sortSymbol_in_smt25Command1887_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_smt25Command1900  */
static	ANTLR3_BITWORD FOLLOW_term_in_smt25Command1900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_smt25Command1900	= { FOLLOW_term_in_smt25Command1900_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1913  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1913	= { FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1913_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command1925  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command1925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command1925	= { FOLLOW_LPAREN_TOK_in_smt25Command1925_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command1933  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command1933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command1933	= { FOLLOW_LPAREN_TOK_in_smt25Command1933_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_smt25Command1941  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_smt25Command1941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_smt25Command1941	= { FOLLOW_symbol_in_smt25Command1941_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command1958  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command1958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command1958	= { FOLLOW_LPAREN_TOK_in_smt25Command1958_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_smt25Command1960  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_smt25Command1960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_smt25Command1960	= { FOLLOW_sortedVarList_in_smt25Command1960_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command1963  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command1963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command1963	= { FOLLOW_RPAREN_TOK_in_smt25Command1963_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_smt25Command1971  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_smt25Command1971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_smt25Command1971	= { FOLLOW_sortSymbol_in_smt25Command1971_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command1988  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command1988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command1988	= { FOLLOW_RPAREN_TOK_in_smt25Command1988_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2001  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2001	= { FOLLOW_RPAREN_TOK_in_smt25Command2001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_smt25Command2007  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_smt25Command2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_smt25Command2007	= { FOLLOW_LPAREN_TOK_in_smt25Command2007_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_smt25Command2025  */
static	ANTLR3_BITWORD FOLLOW_term_in_smt25Command2025_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_smt25Command2025	= { FOLLOW_term_in_smt25Command2025_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_smt25Command2045  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_smt25Command2045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_smt25Command2045	= { FOLLOW_RPAREN_TOK_in_smt25Command2045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_CODATATYPE_TOK_in_extendedCommand2076  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_CODATATYPE_TOK_in_extendedCommand2076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_CODATATYPE_TOK_in_extendedCommand2076	= { FOLLOW_DECLARE_CODATATYPE_TOK_in_extendedCommand2076_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypeDefCommand_in_extendedCommand2078  */
static	ANTLR3_BITWORD FOLLOW_datatypeDefCommand_in_extendedCommand2078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypeDefCommand_in_extendedCommand2078	= { FOLLOW_datatypeDefCommand_in_extendedCommand2078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2085  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2085	= { FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2085_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDefCommand_in_extendedCommand2087  */
static	ANTLR3_BITWORD FOLLOW_datatypesDefCommand_in_extendedCommand2087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDefCommand_in_extendedCommand2087	= { FOLLOW_datatypesDefCommand_in_extendedCommand2087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2107  */
static	ANTLR3_BITWORD FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2107	= { FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2107_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2115  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2115	= { FOLLOW_symbol_in_extendedCommand2115_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_extendedCommand2128  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_extendedCommand2128_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_extendedCommand2128	= { FOLLOW_sortSymbol_in_extendedCommand2128_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2135  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2135	= { FOLLOW_term_in_extendedCommand2135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLIFY_TOK_in_extendedCommand2149  */
static	ANTLR3_BITWORD FOLLOW_SIMPLIFY_TOK_in_extendedCommand2149_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLIFY_TOK_in_extendedCommand2149	= { FOLLOW_SIMPLIFY_TOK_in_extendedCommand2149_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2157  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2157	= { FOLLOW_term_in_extendedCommand2157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_QE_TOK_in_extendedCommand2170  */
static	ANTLR3_BITWORD FOLLOW_GET_QE_TOK_in_extendedCommand2170_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_QE_TOK_in_extendedCommand2170	= { FOLLOW_GET_QE_TOK_in_extendedCommand2170_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2178  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2178	= { FOLLOW_term_in_extendedCommand2178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2191  */
static	ANTLR3_BITWORD FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2191_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2191	= { FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2191_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2199  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2199	= { FOLLOW_term_in_extendedCommand2199_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ABDUCT_TOK_in_extendedCommand2212  */
static	ANTLR3_BITWORD FOLLOW_GET_ABDUCT_TOK_in_extendedCommand2212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ABDUCT_TOK_in_extendedCommand2212	= { FOLLOW_GET_ABDUCT_TOK_in_extendedCommand2212_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2220  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2220_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2220	= { FOLLOW_symbol_in_extendedCommand2220_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2227  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2227	= { FOLLOW_term_in_extendedCommand2227_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGrammar_in_extendedCommand2242  */
static	ANTLR3_BITWORD FOLLOW_sygusGrammar_in_extendedCommand2242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGrammar_in_extendedCommand2242	= { FOLLOW_sygusGrammar_in_extendedCommand2242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_ABDUCT_NEXT_TOK_in_extendedCommand2262  */
static	ANTLR3_BITWORD FOLLOW_GET_ABDUCT_NEXT_TOK_in_extendedCommand2262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_ABDUCT_NEXT_TOK_in_extendedCommand2262	= { FOLLOW_GET_ABDUCT_NEXT_TOK_in_extendedCommand2262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_INTERPOL_TOK_in_extendedCommand2270  */
static	ANTLR3_BITWORD FOLLOW_GET_INTERPOL_TOK_in_extendedCommand2270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_INTERPOL_TOK_in_extendedCommand2270	= { FOLLOW_GET_INTERPOL_TOK_in_extendedCommand2270_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2278  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2278_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2278	= { FOLLOW_symbol_in_extendedCommand2278_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2285  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2285	= { FOLLOW_term_in_extendedCommand2285_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sygusGrammar_in_extendedCommand2300  */
static	ANTLR3_BITWORD FOLLOW_sygusGrammar_in_extendedCommand2300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sygusGrammar_in_extendedCommand2300	= { FOLLOW_sygusGrammar_in_extendedCommand2300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GET_INTERPOL_NEXT_TOK_in_extendedCommand2320  */
static	ANTLR3_BITWORD FOLLOW_GET_INTERPOL_NEXT_TOK_in_extendedCommand2320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GET_INTERPOL_NEXT_TOK_in_extendedCommand2320	= { FOLLOW_GET_INTERPOL_NEXT_TOK_in_extendedCommand2320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_HEAP_in_extendedCommand2328  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_HEAP_in_extendedCommand2328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_HEAP_in_extendedCommand2328	= { FOLLOW_DECLARE_HEAP_in_extendedCommand2328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2330  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2330	= { FOLLOW_LPAREN_TOK_in_extendedCommand2330_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_extendedCommand2336  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_extendedCommand2336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_extendedCommand2336	= { FOLLOW_sortSymbol_in_extendedCommand2336_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_extendedCommand2343  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_extendedCommand2343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_extendedCommand2343	= { FOLLOW_sortSymbol_in_extendedCommand2343_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2356  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2356	= { FOLLOW_RPAREN_TOK_in_extendedCommand2356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARE_POOL_in_extendedCommand2362  */
static	ANTLR3_BITWORD FOLLOW_DECLARE_POOL_in_extendedCommand2362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARE_POOL_in_extendedCommand2362	= { FOLLOW_DECLARE_POOL_in_extendedCommand2362_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_extendedCommand2370  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_extendedCommand2370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_extendedCommand2370	= { FOLLOW_symbol_in_extendedCommand2370_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_extendedCommand2383  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_extendedCommand2383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_extendedCommand2383	= { FOLLOW_sortSymbol_in_extendedCommand2383_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2390  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2390_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2390	= { FOLLOW_LPAREN_TOK_in_extendedCommand2390_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_extendedCommand2398  */
static	ANTLR3_BITWORD FOLLOW_term_in_extendedCommand2398_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_extendedCommand2398	= { FOLLOW_term_in_extendedCommand2398_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2416  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2416	= { FOLLOW_RPAREN_TOK_in_extendedCommand2416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_MODEL_TOK_in_extendedCommand2428  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_MODEL_TOK_in_extendedCommand2428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_MODEL_TOK_in_extendedCommand2428	= { FOLLOW_BLOCK_MODEL_TOK_in_extendedCommand2428_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_extendedCommand2430  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_extendedCommand2430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_extendedCommand2430	= { FOLLOW_KEYWORD_in_extendedCommand2430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_MODEL_VALUES_TOK_in_extendedCommand2444  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_MODEL_VALUES_TOK_in_extendedCommand2444_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR3_UINT64_LIT(0x000003FFFFFFFFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_MODEL_VALUES_TOK_in_extendedCommand2444	= { FOLLOW_BLOCK_MODEL_VALUES_TOK_in_extendedCommand2444_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_extendedCommand2454  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_extendedCommand2454_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_extendedCommand2454	= { FOLLOW_LPAREN_TOK_in_extendedCommand2454_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_extendedCommand2456  */
static	ANTLR3_BITWORD FOLLOW_termList_in_extendedCommand2456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_extendedCommand2456	= { FOLLOW_termList_in_extendedCommand2456_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_extendedCommand2459  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_extendedCommand2459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_extendedCommand2459	= { FOLLOW_RPAREN_TOK_in_extendedCommand2459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extendedCommand2475  */
static	ANTLR3_BITWORD FOLLOW_set_in_extendedCommand2475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extendedCommand2475	= { FOLLOW_set_in_extendedCommand2475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypeDefCommand2511  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypeDefCommand2511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypeDefCommand2511	= { FOLLOW_symbol_in_datatypeDefCommand2511_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDef_in_datatypeDefCommand2518  */
static	ANTLR3_BITWORD FOLLOW_datatypesDef_in_datatypeDefCommand2518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDef_in_datatypeDefCommand2518	= { FOLLOW_datatypesDef_in_datatypeDefCommand2518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2541  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2541	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2541_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2549  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2549	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2549_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypesDefCommand2551  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypesDefCommand2551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypesDefCommand2551	= { FOLLOW_symbol_in_datatypesDefCommand2551_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_datatypesDefCommand2556  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_datatypesDefCommand2556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_datatypesDefCommand2556	= { FOLLOW_INTEGER_LITERAL_in_datatypesDefCommand2556_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2558  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2558	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2558_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2573  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2573	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2573_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDefCommand2577  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDefCommand2577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDefCommand2577	= { FOLLOW_LPAREN_TOK_in_datatypesDefCommand2577_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_datatypesDef_in_datatypesDefCommand2581  */
static	ANTLR3_BITWORD FOLLOW_datatypesDef_in_datatypesDefCommand2581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_datatypesDef_in_datatypesDefCommand2581	= { FOLLOW_datatypesDef_in_datatypesDefCommand2581_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDefCommand2586  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDefCommand2586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDefCommand2586	= { FOLLOW_RPAREN_TOK_in_datatypesDefCommand2586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDef2615  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDef2615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000009000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDef2615	= { FOLLOW_LPAREN_TOK_in_datatypesDef2615_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAR_TOK_in_datatypesDef2625  */
static	ANTLR3_BITWORD FOLLOW_PAR_TOK_in_datatypesDef2625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_PAR_TOK_in_datatypesDef2625	= { FOLLOW_PAR_TOK_in_datatypesDef2625_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDef2629  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDef2629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008240000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDef2629	= { FOLLOW_LPAREN_TOK_in_datatypesDef2629_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypesDef2639  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypesDef2639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008240000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypesDef2639	= { FOLLOW_symbol_in_datatypesDef2639_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDef2667  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDef2667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDef2667	= { FOLLOW_RPAREN_TOK_in_datatypesDef2667_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDef2677  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDef2677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDef2677	= { FOLLOW_LPAREN_TOK_in_datatypesDef2677_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDef2687  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDef2687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDef2687	= { FOLLOW_LPAREN_TOK_in_datatypesDef2687_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypesDef2689  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypesDef2689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypesDef2689	= { FOLLOW_constructorDef_in_datatypesDef2689_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDef2692  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDef2692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDef2692	= { FOLLOW_RPAREN_TOK_in_datatypesDef2692_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDef2703  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDef2703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDef2703	= { FOLLOW_RPAREN_TOK_in_datatypesDef2703_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypesDef2723  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypesDef2723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypesDef2723	= { FOLLOW_LPAREN_TOK_in_datatypesDef2723_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypesDef2725  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypesDef2725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypesDef2725	= { FOLLOW_constructorDef_in_datatypesDef2725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDef2728  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDef2728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDef2728	= { FOLLOW_RPAREN_TOK_in_datatypesDef2728_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypesDef2743  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypesDef2743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypesDef2743	= { FOLLOW_RPAREN_TOK_in_datatypesDef2743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2768  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2768	= { FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2780  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2780	= { FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2792  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2792	= { FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2804  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2804	= { FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FIELD_LITERAL_in_simpleSymbolicExprNoKeyword2816  */
static	ANTLR3_BITWORD FOLLOW_FIELD_LITERAL_in_simpleSymbolicExprNoKeyword2816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FIELD_LITERAL_in_simpleSymbolicExprNoKeyword2816	= { FOLLOW_FIELD_LITERAL_in_simpleSymbolicExprNoKeyword2816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_simpleSymbolicExprNoKeyword2828  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_simpleSymbolicExprNoKeyword2828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_simpleSymbolicExprNoKeyword2828	= { FOLLOW_symbol_in_simpleSymbolicExprNoKeyword2828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_simpleSymbolicExprNoKeyword2835  */
static	ANTLR3_BITWORD FOLLOW_str_in_simpleSymbolicExprNoKeyword2835_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_simpleSymbolicExprNoKeyword2835	= { FOLLOW_str_in_simpleSymbolicExprNoKeyword2835_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_simpleSymbolicExprNoKeyword2844  */
static	ANTLR3_BITWORD FOLLOW_set_in_simpleSymbolicExprNoKeyword2844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_simpleSymbolicExprNoKeyword2844	= { FOLLOW_set_in_simpleSymbolicExprNoKeyword2844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_keyword3046  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_keyword3046_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_keyword3046	= { FOLLOW_KEYWORD_in_keyword3046_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3066  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3066	= { FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3066_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_simpleSymbolicExpr3073  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_simpleSymbolicExpr3073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_simpleSymbolicExpr3073	= { FOLLOW_KEYWORD_in_simpleSymbolicExpr3073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExpr_in_symbolicExpr3094  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExpr_in_symbolicExpr3094_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExpr_in_symbolicExpr3094	= { FOLLOW_simpleSymbolicExpr_in_symbolicExpr3094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_symbolicExpr3107  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_symbolicExpr3107_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620020), ANTLR3_UINT64_LIT(0x000000603F3F1517) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_symbolicExpr3107	= { FOLLOW_LPAREN_TOK_in_symbolicExpr3107_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolicExpr_in_symbolicExpr3115  */
static	ANTLR3_BITWORD FOLLOW_symbolicExpr_in_symbolicExpr3115_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620020), ANTLR3_UINT64_LIT(0x000000603F3F1517) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolicExpr_in_symbolicExpr3115	= { FOLLOW_symbolicExpr_in_symbolicExpr3115_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_symbolicExpr3123  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_symbolicExpr3123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_symbolicExpr3123	= { FOLLOW_RPAREN_TOK_in_symbolicExpr3123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termNonVariable_in_term3148  */
static	ANTLR3_BITWORD FOLLOW_termNonVariable_in_term3148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_termNonVariable_in_term3148	= { FOLLOW_termNonVariable_in_term3148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualIdentifier_in_term3160  */
static	ANTLR3_BITWORD FOLLOW_qualIdentifier_in_term3160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualIdentifier_in_term3160	= { FOLLOW_qualIdentifier_in_term3160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3188  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3188_bits[]	= { ANTLR3_UINT64_LIT(0x0002200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3188	= { FOLLOW_LPAREN_TOK_in_termNonVariable3188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quantOp_in_termNonVariable3190  */
static	ANTLR3_BITWORD FOLLOW_quantOp_in_termNonVariable3190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_quantOp_in_termNonVariable3190	= { FOLLOW_quantOp_in_termNonVariable3190_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarList_in_termNonVariable3203  */
static	ANTLR3_BITWORD FOLLOW_boundVarList_in_termNonVariable3203_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarList_in_termNonVariable3203	= { FOLLOW_boundVarList_in_termNonVariable3203_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3210  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3210	= { FOLLOW_term_in_termNonVariable3210_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3213  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3213	= { FOLLOW_RPAREN_TOK_in_termNonVariable3213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3225  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3225	= { FOLLOW_LPAREN_TOK_in_termNonVariable3225_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_COMPREHENSION_TOK_in_termNonVariable3227  */
static	ANTLR3_BITWORD FOLLOW_SET_COMPREHENSION_TOK_in_termNonVariable3227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_COMPREHENSION_TOK_in_termNonVariable3227	= { FOLLOW_SET_COMPREHENSION_TOK_in_termNonVariable3227_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarList_in_termNonVariable3239  */
static	ANTLR3_BITWORD FOLLOW_boundVarList_in_termNonVariable3239_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarList_in_termNonVariable3239	= { FOLLOW_boundVarList_in_termNonVariable3239_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3252  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3252_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3252	= { FOLLOW_term_in_termNonVariable3252_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3261  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3261	= { FOLLOW_term_in_termNonVariable3261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3270  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3270	= { FOLLOW_RPAREN_TOK_in_termNonVariable3270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3276  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3276	= { FOLLOW_LPAREN_TOK_in_termNonVariable3276_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualIdentifier_in_termNonVariable3278  */
static	ANTLR3_BITWORD FOLLOW_qualIdentifier_in_termNonVariable3278_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_qualIdentifier_in_termNonVariable3278	= { FOLLOW_qualIdentifier_in_termNonVariable3278_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termList_in_termNonVariable3285  */
static	ANTLR3_BITWORD FOLLOW_termList_in_termNonVariable3285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_termList_in_termNonVariable3285	= { FOLLOW_termList_in_termNonVariable3285_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3288  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3288	= { FOLLOW_RPAREN_TOK_in_termNonVariable3288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3306  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3306	= { FOLLOW_LPAREN_TOK_in_termNonVariable3306_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_termNonVariable3314  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_termNonVariable3314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_termNonVariable3314	= { FOLLOW_LET_TOK_in_termNonVariable3314_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3316  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3316	= { FOLLOW_LPAREN_TOK_in_termNonVariable3316_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3334  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3334	= { FOLLOW_LPAREN_TOK_in_termNonVariable3334_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_termNonVariable3336  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_termNonVariable3336_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_termNonVariable3336	= { FOLLOW_symbol_in_termNonVariable3336_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3347  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3347	= { FOLLOW_term_in_termNonVariable3347_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3358  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3358	= { FOLLOW_RPAREN_TOK_in_termNonVariable3358_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3401  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3401_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3401	= { FOLLOW_RPAREN_TOK_in_termNonVariable3401_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3407  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3407	= { FOLLOW_term_in_termNonVariable3407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3414  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3414	= { FOLLOW_RPAREN_TOK_in_termNonVariable3414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3432  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3432	= { FOLLOW_LPAREN_TOK_in_termNonVariable3432_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MATCH_TOK_in_termNonVariable3434  */
static	ANTLR3_BITWORD FOLLOW_MATCH_TOK_in_termNonVariable3434_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_MATCH_TOK_in_termNonVariable3434	= { FOLLOW_MATCH_TOK_in_termNonVariable3434_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3436  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3436	= { FOLLOW_term_in_termNonVariable3436_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3445  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3445	= { FOLLOW_LPAREN_TOK_in_termNonVariable3445_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3466  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3466	= { FOLLOW_LPAREN_TOK_in_termNonVariable3466_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3468  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3468_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3468	= { FOLLOW_LPAREN_TOK_in_termNonVariable3468_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3470  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008240000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3470	= { FOLLOW_term_in_termNonVariable3470_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_termNonVariable3494  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_termNonVariable3494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008240000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_termNonVariable3494	= { FOLLOW_symbol_in_termNonVariable3494_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3518  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3518_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3518	= { FOLLOW_RPAREN_TOK_in_termNonVariable3518_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3520  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3520	= { FOLLOW_term_in_termNonVariable3520_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3533  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3533	= { FOLLOW_RPAREN_TOK_in_termNonVariable3533_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3550  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3550	= { FOLLOW_LPAREN_TOK_in_termNonVariable3550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_termNonVariable3552  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_termNonVariable3552_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_termNonVariable3552	= { FOLLOW_symbol_in_termNonVariable3552_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3565  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3565	= { FOLLOW_term_in_termNonVariable3565_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3578  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3578	= { FOLLOW_RPAREN_TOK_in_termNonVariable3578_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3591  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3591	= { FOLLOW_RPAREN_TOK_in_termNonVariable3591_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3593  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3593	= { FOLLOW_RPAREN_TOK_in_termNonVariable3593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3609  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3609	= { FOLLOW_LPAREN_TOK_in_termNonVariable3609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_TOK_in_termNonVariable3611  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_TOK_in_termNonVariable3611_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_TOK_in_termNonVariable3611	= { FOLLOW_ATTRIBUTE_TOK_in_termNonVariable3611_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3613  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3613_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000FF00), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3613	= { FOLLOW_term_in_termNonVariable3613_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_termNonVariable3622  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_termNonVariable3622_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000FF00), ANTLR3_UINT64_LIT(0x0000000000200400) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_termNonVariable3622	= { FOLLOW_attribute_in_termNonVariable3622_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3640  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3640	= { FOLLOW_RPAREN_TOK_in_termNonVariable3640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termNonVariable3658  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termNonVariable3658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termNonVariable3658	= { FOLLOW_LPAREN_TOK_in_termNonVariable3658_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HO_LAMBDA_TOK_in_termNonVariable3660  */
static	ANTLR3_BITWORD FOLLOW_HO_LAMBDA_TOK_in_termNonVariable3660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_HO_LAMBDA_TOK_in_termNonVariable3660	= { FOLLOW_HO_LAMBDA_TOK_in_termNonVariable3660_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boundVarList_in_termNonVariable3672  */
static	ANTLR3_BITWORD FOLLOW_boundVarList_in_termNonVariable3672_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_boundVarList_in_termNonVariable3672	= { FOLLOW_boundVarList_in_termNonVariable3672_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termNonVariable3679  */
static	ANTLR3_BITWORD FOLLOW_term_in_termNonVariable3679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termNonVariable3679	= { FOLLOW_term_in_termNonVariable3679_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termNonVariable3682  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termNonVariable3682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termNonVariable3682	= { FOLLOW_RPAREN_TOK_in_termNonVariable3682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAtomic_in_termNonVariable3700  */
static	ANTLR3_BITWORD FOLLOW_termAtomic_in_termNonVariable3700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_termAtomic_in_termNonVariable3700	= { FOLLOW_termAtomic_in_termNonVariable3700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_qualIdentifier3723  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_qualIdentifier3723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_qualIdentifier3723	= { FOLLOW_identifier_in_qualIdentifier3723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_qualIdentifier3730  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_qualIdentifier3730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_qualIdentifier3730	= { FOLLOW_LPAREN_TOK_in_qualIdentifier3730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_TOK_in_qualIdentifier3732  */
static	ANTLR3_BITWORD FOLLOW_AS_TOK_in_qualIdentifier3732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_TOK_in_qualIdentifier3732	= { FOLLOW_AS_TOK_in_qualIdentifier3732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_qualIdentifier3734  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_qualIdentifier3734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_qualIdentifier3734	= { FOLLOW_identifier_in_qualIdentifier3734_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_qualIdentifier3737  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_qualIdentifier3737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_qualIdentifier3737	= { FOLLOW_sortSymbol_in_qualIdentifier3737_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_qualIdentifier3740  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_qualIdentifier3740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_qualIdentifier3740	= { FOLLOW_RPAREN_TOK_in_qualIdentifier3740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_identifier3765  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_identifier3765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_identifier3765	= { FOLLOW_functionName_in_identifier3765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_identifier3777  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_identifier3777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_identifier3777	= { FOLLOW_LPAREN_TOK_in_identifier3777_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_identifier3779  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_identifier3779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000B008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_identifier3779	= { FOLLOW_INDEX_TOK_in_identifier3779_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TESTER_TOK_in_identifier3787  */
static	ANTLR3_BITWORD FOLLOW_TESTER_TOK_in_identifier3787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_TESTER_TOK_in_identifier3787	= { FOLLOW_TESTER_TOK_in_identifier3787_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_identifier3789  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_identifier3789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_identifier3789	= { FOLLOW_symbol_in_identifier3789_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UPDATE_TOK_in_identifier3806  */
static	ANTLR3_BITWORD FOLLOW_UPDATE_TOK_in_identifier3806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_UPDATE_TOK_in_identifier3806	= { FOLLOW_UPDATE_TOK_in_identifier3806_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_identifier3808  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_identifier3808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_identifier3808	= { FOLLOW_symbol_in_identifier3808_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_identifier3825  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_identifier3825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_identifier3825	= { FOLLOW_functionName_in_identifier3825_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonemptyNumeralList_in_identifier3828  */
static	ANTLR3_BITWORD FOLLOW_nonemptyNumeralList_in_identifier3828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_nonemptyNumeralList_in_identifier3828	= { FOLLOW_nonemptyNumeralList_in_identifier3828_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_identifier3849  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_identifier3849_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_identifier3849	= { FOLLOW_RPAREN_TOK_in_identifier3849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_termAtomic3876  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_termAtomic3876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_termAtomic3876	= { FOLLOW_INTEGER_LITERAL_in_termAtomic3876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECIMAL_LITERAL_in_termAtomic3888  */
static	ANTLR3_BITWORD FOLLOW_DECIMAL_LITERAL_in_termAtomic3888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DECIMAL_LITERAL_in_termAtomic3888	= { FOLLOW_DECIMAL_LITERAL_in_termAtomic3888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_termAtomic3907  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_termAtomic3907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_termAtomic3907	= { FOLLOW_LPAREN_TOK_in_termAtomic3907_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_termAtomic3909  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_termAtomic3909_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000100000), ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_termAtomic3909	= { FOLLOW_INDEX_TOK_in_termAtomic3909_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHAR_TOK_in_termAtomic3917  */
static	ANTLR3_BITWORD FOLLOW_CHAR_TOK_in_termAtomic3917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_CHAR_TOK_in_termAtomic3917	= { FOLLOW_CHAR_TOK_in_termAtomic3917_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_termAtomic3919  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_termAtomic3919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_termAtomic3919	= { FOLLOW_HEX_LITERAL_in_termAtomic3919_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FMF_CARD_TOK_in_termAtomic3935  */
static	ANTLR3_BITWORD FOLLOW_FMF_CARD_TOK_in_termAtomic3935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_FMF_CARD_TOK_in_termAtomic3935	= { FOLLOW_FMF_CARD_TOK_in_termAtomic3935_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_termAtomic3937  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_termAtomic3937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_termAtomic3937	= { FOLLOW_sortSymbol_in_termAtomic3937_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_termAtomic3940  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_termAtomic3940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_termAtomic3940	= { FOLLOW_INTEGER_LITERAL_in_termAtomic3940_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_termAtomic3958  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_termAtomic3958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_termAtomic3958	= { FOLLOW_SIMPLE_SYMBOL_in_termAtomic3958_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonemptyNumeralList_in_termAtomic3960  */
static	ANTLR3_BITWORD FOLLOW_nonemptyNumeralList_in_termAtomic3960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_nonemptyNumeralList_in_termAtomic3960	= { FOLLOW_nonemptyNumeralList_in_termAtomic3960_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_termAtomic3981  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_termAtomic3981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_termAtomic3981	= { FOLLOW_RPAREN_TOK_in_termAtomic3981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_termAtomic3991  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_termAtomic3991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_termAtomic3991	= { FOLLOW_HEX_LITERAL_in_termAtomic3991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINARY_LITERAL_in_termAtomic4003  */
static	ANTLR3_BITWORD FOLLOW_BINARY_LITERAL_in_termAtomic4003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BINARY_LITERAL_in_termAtomic4003	= { FOLLOW_BINARY_LITERAL_in_termAtomic4003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FIELD_LITERAL_in_termAtomic4015  */
static	ANTLR3_BITWORD FOLLOW_FIELD_LITERAL_in_termAtomic4015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FIELD_LITERAL_in_termAtomic4015	= { FOLLOW_FIELD_LITERAL_in_termAtomic4015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_str_in_termAtomic4031  */
static	ANTLR3_BITWORD FOLLOW_str_in_termAtomic4031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_str_in_termAtomic4031	= { FOLLOW_str_in_termAtomic4031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEYWORD_in_attribute4055  */
static	ANTLR3_BITWORD FOLLOW_KEYWORD_in_attribute4055_bits[]	= { ANTLR3_UINT64_LIT(0x38F0D79288620022), ANTLR3_UINT64_LIT(0x000000603F1F0117) };
static  ANTLR3_BITSET_LIST FOLLOW_KEYWORD_in_attribute4055	= { FOLLOW_KEYWORD_in_attribute4055_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4059  */
static	ANTLR3_BITWORD FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4059	= { FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4075  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4075	= { FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4075_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_POOL_TOK_in_attribute4087  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_POOL_TOK_in_attribute4087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_POOL_TOK_in_attribute4087	= { FOLLOW_ATTRIBUTE_POOL_TOK_in_attribute4087_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_INST_ADD_TO_POOL_TOK_in_attribute4100  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_INST_ADD_TO_POOL_TOK_in_attribute4100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_INST_ADD_TO_POOL_TOK_in_attribute4100	= { FOLLOW_ATTRIBUTE_INST_ADD_TO_POOL_TOK_in_attribute4100_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK_in_attribute4113  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK_in_attribute4113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK_in_attribute4113	= { FOLLOW_ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK_in_attribute4113_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_attribute4126  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_attribute4126_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_attribute4126	= { FOLLOW_LPAREN_TOK_in_attribute4126_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_attribute4134  */
static	ANTLR3_BITWORD FOLLOW_term_in_attribute4134_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028241110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_attribute4134	= { FOLLOW_term_in_attribute4134_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_attribute4152  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_attribute4152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_attribute4152	= { FOLLOW_RPAREN_TOK_in_attribute4152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4164  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4164_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020000), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4164	= { FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4164_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_attribute4166  */
static	ANTLR3_BITWORD FOLLOW_term_in_attribute4166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_attribute4166	= { FOLLOW_term_in_attribute4166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_INST_LEVEL_in_attribute4183  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_INST_LEVEL_in_attribute4183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_INST_LEVEL_in_attribute4183	= { FOLLOW_ATTRIBUTE_INST_LEVEL_in_attribute4183_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_attribute4187  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_attribute4187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_attribute4187	= { FOLLOW_INTEGER_LITERAL_in_attribute4187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_QUANTIFIER_ID_TOK_in_attribute4203  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_QUANTIFIER_ID_TOK_in_attribute4203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_QUANTIFIER_ID_TOK_in_attribute4203	= { FOLLOW_ATTRIBUTE_QUANTIFIER_ID_TOK_in_attribute4203_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_attribute4207  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_attribute4207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_attribute4207	= { FOLLOW_symbol_in_attribute4207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4220  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4220	= { FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4220_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_attribute4222  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_attribute4222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_attribute4222	= { FOLLOW_symbol_in_attribute4222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_termList4254  */
static	ANTLR3_BITWORD FOLLOW_term_in_termList4254_bits[]	= { ANTLR3_UINT64_LIT(0x0000800008020002), ANTLR3_UINT64_LIT(0x0000006028041110) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_termList4254	= { FOLLOW_term_in_termList4254_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_str4276  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_str4276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_str4276	= { FOLLOW_STRING_LITERAL_in_str4276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTERMINATED_STRING_LITERAL_in_str4288  */
static	ANTLR3_BITWORD FOLLOW_UNTERMINATED_STRING_LITERAL_in_str4288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTERMINATED_STRING_LITERAL_in_str4288	= { FOLLOW_UNTERMINATED_STRING_LITERAL_in_str4288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_str4290  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_str4290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_str4290	= { FOLLOW_EOF_in_str4290_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_quantOp4315  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_quantOp4315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_quantOp4315	= { FOLLOW_EXISTS_TOK_in_quantOp4315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_quantOp4326  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_quantOp4326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_quantOp4326	= { FOLLOW_FORALL_TOK_in_quantOp4326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_functionName4347  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_functionName4347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_functionName4347	= { FOLLOW_symbol_in_functionName4347_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortList4371  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortList4371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortList4371	= { FOLLOW_sortSymbol_in_sortList4371_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_nonemptySortList4398  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_nonemptySortList4398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_nonemptySortList4398	= { FOLLOW_sortSymbol_in_nonemptySortList4398_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sortedVarList4427  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sortedVarList4427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sortedVarList4427	= { FOLLOW_LPAREN_TOK_in_sortedVarList4427_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortedVarList4429  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortedVarList4429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortedVarList4429	= { FOLLOW_symbol_in_sortedVarList4429_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortedVarList4438  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortedVarList4438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortedVarList4438	= { FOLLOW_sortSymbol_in_sortedVarList4438_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sortedVarList4441  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sortedVarList4441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sortedVarList4441	= { FOLLOW_RPAREN_TOK_in_sortedVarList4441_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_boundVarList4476  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_boundVarList4476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000201000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_boundVarList4476	= { FOLLOW_LPAREN_TOK_in_boundVarList4476_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortedVarList_in_boundVarList4478  */
static	ANTLR3_BITWORD FOLLOW_sortedVarList_in_boundVarList4478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortedVarList_in_boundVarList4478	= { FOLLOW_sortedVarList_in_boundVarList4478_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_boundVarList4481  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_boundVarList4481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_boundVarList4481	= { FOLLOW_RPAREN_TOK_in_boundVarList4481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortName4501  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortName4501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortName4501	= { FOLLOW_symbol_in_sortName4501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortSymbol4521  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortSymbol4521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortSymbol4521	= { FOLLOW_sortName_in_sortSymbol4521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_sortSymbol4534  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_sortSymbol4534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040080) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_sortSymbol4534	= { FOLLOW_LPAREN_TOK_in_sortSymbol4534_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INDEX_TOK_in_sortSymbol4537  */
static	ANTLR3_BITWORD FOLLOW_INDEX_TOK_in_sortSymbol4537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_INDEX_TOK_in_sortSymbol4537	= { FOLLOW_INDEX_TOK_in_sortSymbol4537_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_sortSymbol4550  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_sortSymbol4550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008241100) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_sortSymbol4550	= { FOLLOW_symbol_in_sortSymbol4550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonemptyNumeralStringList_in_sortSymbol4559  */
static	ANTLR3_BITWORD FOLLOW_nonemptyNumeralStringList_in_sortSymbol4559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_nonemptyNumeralStringList_in_sortSymbol4559	= { FOLLOW_nonemptyNumeralStringList_in_sortSymbol4559_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_sortSymbol4576  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_sortSymbol4576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_sortSymbol4576	= { FOLLOW_sortList_in_sortSymbol4576_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_sortSymbol4593  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_sortSymbol4593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_sortSymbol4593	= { FOLLOW_RPAREN_TOK_in_sortSymbol4593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_symbolList4616  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_symbolList4616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_symbolList4616	= { FOLLOW_symbol_in_symbolList4616_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_SYMBOL_in_symbol4638  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_SYMBOL_in_symbol4638_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_SYMBOL_in_symbol4638	= { FOLLOW_SIMPLE_SYMBOL_in_symbol4638_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUOTED_SYMBOL_in_symbol4650  */
static	ANTLR3_BITWORD FOLLOW_QUOTED_SYMBOL_in_symbol4650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUOTED_SYMBOL_in_symbol4650	= { FOLLOW_QUOTED_SYMBOL_in_symbol4650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol4662  */
static	ANTLR3_BITWORD FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol4662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol4662	= { FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol4662_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_symbol4670  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_symbol4670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_symbol4670	= { FOLLOW_EOF_in_symbol4670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_symbol4686  */
static	ANTLR3_BITWORD FOLLOW_105_in_symbol4686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_105_in_symbol4686	= { FOLLOW_105_in_symbol4686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList4718  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList4718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList4718	= { FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList4718_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralStringList4751  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralStringList4751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralStringList4751	= { FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralStringList4751_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_datatypeDef4793  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_datatypeDef4793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_datatypeDef4793	= { FOLLOW_symbol_in_datatypeDef4793_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_datatypeDef4810  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_datatypeDef4810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_datatypeDef4810	= { FOLLOW_LPAREN_TOK_in_datatypeDef4810_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructorDef_in_datatypeDef4812  */
static	ANTLR3_BITWORD FOLLOW_constructorDef_in_datatypeDef4812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructorDef_in_datatypeDef4812	= { FOLLOW_constructorDef_in_datatypeDef4812_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_datatypeDef4815  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_datatypeDef4815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_datatypeDef4815	= { FOLLOW_RPAREN_TOK_in_datatypeDef4815_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_constructorDef4845  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_constructorDef4845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_constructorDef4845	= { FOLLOW_symbol_in_constructorDef4845_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_constructorDef4860  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_constructorDef4860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_constructorDef4860	= { FOLLOW_LPAREN_TOK_in_constructorDef4860_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selector_in_constructorDef4862  */
static	ANTLR3_BITWORD FOLLOW_selector_in_constructorDef4862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_selector_in_constructorDef4862	= { FOLLOW_selector_in_constructorDef4862_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_constructorDef4865  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_constructorDef4865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_constructorDef4865	= { FOLLOW_RPAREN_TOK_in_constructorDef4865_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_selector4893  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_selector4893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002008041000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_selector4893	= { FOLLOW_symbol_in_selector4893_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_selector4896  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_selector4896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_selector4896	= { FOLLOW_sortSymbol_in_selector4896_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:136:1: parseExpr returns [cvc5::Term expr = cvc5::Term()] : ( term[expr, expr2] | EOF );
 */
static cvc5::Term
parseExpr(pSmt2Parser ctx)
{
    cvc5::Term expr;



      cvc5::Term expr2;

    /* Initialize rule variables
     */
    expr =  cvc5::Term();


    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:140:3: ( term[expr, expr2] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FIELD_LITERAL:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case LPAREN_TOK:
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case STRING_LITERAL:
            case UNTERMINATED_QUOTED_SYMBOL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:140:5: term[expr, expr2]
        	    {
        	        FOLLOWPUSH(FOLLOW_term_in_parseExpr117);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:141:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr124);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:148:1: parseCommand returns [std::unique_ptr<cvc5::parser::Command> cmd_return = NULL] : ( LPAREN_TOK command[&cmd] RPAREN_TOK | LPAREN_TOK INCLUDE_TOK str[name, true] RPAREN_TOK | EOF );
 */
static std::unique_ptr<cvc5::parser::Command>
parseCommand(pSmt2Parser ctx)
{
    std::unique_ptr<cvc5::parser::Command> cmd_return;



      std::unique_ptr<cvc5::parser::Command> cmd;
      std::string name;

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:156:3: ( LPAREN_TOK command[&cmd] RPAREN_TOK | LPAREN_TOK INCLUDE_TOK str[name, true] RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt2;

            alt2=3;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case INCLUDE_TOK:
            			{
            				alt2=2;
            			}
            		    break;
            		case ASSERT_TOK:
            		case BLOCK_MODEL_TOK:
            		case BLOCK_MODEL_VALUES_TOK:
            		case CHECK_SAT_ASSUMING_TOK:
            		case CHECK_SAT_TOK:
            		case DECLARE_CODATATYPES_TOK:
            		case DECLARE_CODATATYPE_TOK:
            		case DECLARE_CONST_TOK:
            		case DECLARE_DATATYPES_TOK:
            		case DECLARE_DATATYPE_TOK:
            		case DECLARE_FUN_TOK:
            		case DECLARE_HEAP:
            		case DECLARE_POOL:
            		case DECLARE_SORT_TOK:
            		case DEFINE_CONST_TOK:
            		case DEFINE_FUNS_REC_TOK:
            		case DEFINE_FUN_REC_TOK:
            		case DEFINE_FUN_TOK:
            		case DEFINE_SORT_TOK:
            		case ECHO_TOK:
            		case EXIT_TOK:
            		case GET_ABDUCT_NEXT_TOK:
            		case GET_ABDUCT_TOK:
            		case GET_ASSERTIONS_TOK:
            		case GET_ASSIGNMENT_TOK:
            		case GET_DIFFICULTY_TOK:
            		case GET_INFO_TOK:
            		case GET_INTERPOL_NEXT_TOK:
            		case GET_INTERPOL_TOK:
            		case GET_LEARNED_LITERALS_TOK:
            		case GET_MODEL_TOK:
            		case GET_OPTION_TOK:
            		case GET_PROOF_TOK:
            		case GET_QE_DISJUNCT_TOK:
            		case GET_QE_TOK:
            		case GET_UNSAT_ASSUMPTIONS_TOK:
            		case GET_UNSAT_CORE_TOK:
            		case GET_VALUE_TOK:
            		case POP_TOK:
            		case PUSH_TOK:
            		case RESET_ASSERTIONS_TOK:
            		case RESET_TOK:
            		case SET_INFO_TOK:
            		case SET_LOGIC_TOK:
            		case SET_OPTION_TOK:
            		case SIMPLE_SYMBOL:
            		case SIMPLIFY_TOK:
            			{
            				alt2=1;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 2;
            		    EXCEPTION->state        = 1;


            		    goto ruleparseCommandEx;

            		}

            	}
                break;
            case EOF:
            	{
            		alt2=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:156:5: LPAREN_TOK command[&cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand153);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_command_in_parseCommand155);
        	        command(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand158);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:161:5: LPAREN_TOK INCLUDE_TOK str[name, true] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand171);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(INCLUDE_TOK, &FOLLOW_INCLUDE_TOK_in_parseCommand173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_str_in_parseCommand175);
        	        str(ctx, name, true);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseCommand178);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             if(!PARSER_BASE->canIncludeFile()) {
        	                    PARSER_STATE->parseError("include-file feature was disabled for this "
        	                                             "run.");
        	                  }
        	                  if(PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError("Extended commands are not permitted while "
        	                                             "operating in strict compliance mode.");
        	                  }
        	                  PARSER_BASE->includeSmt2File(name);
        	                  // The command of the included file will be produced at the next
        	                  // parseCommand() call
        	                  cmd.reset(new EmptyCommand("include::" + name));
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:176:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseCommand191);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd_return = std::move(cmd);

                }
            }


    return cmd_return;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start parseSygus
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:184:1: parseSygus returns [std::unique_ptr<cvc5::parser::Command> cmd_return = NULL] : ( LPAREN_TOK cmd= sygusCommand RPAREN_TOK | EOF );
 */
static std::unique_ptr<cvc5::parser::Command>
parseSygus(pSmt2Parser ctx)
{
    std::unique_ptr<cvc5::parser::Command> cmd_return;



      std::string name;

    std::unique_ptr<cvc5::parser::Command> cmd;
    #undef	RETURN_TYPE_cmd
    #define	RETURN_TYPE_cmd std::unique_ptr<cvc5::parser::Command>

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:191:3: ( LPAREN_TOK cmd= sygusCommand RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt3=1;
            	}
                break;
            case EOF:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruleparseSygusEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:191:5: LPAREN_TOK cmd= sygusCommand RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseSygus220);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sygusCommand_in_parseSygus224);
        	        cmd=sygusCommand(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_parseSygus226);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:192:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseSygus232);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseSygusEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseSygusEx; /* Prevent compiler warnings */
    ruleparseSygusEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd_return = std::move(cmd);

                }
            }


    return cmd_return;
}
/* $ANTLR end parseSygus */

/**
 * $ANTLR start command
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:199:1: command[std::unique_ptr<cvc5::parser::Command>* cmd] : ( SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT] | SET_INFO_TOK setInfoInternal[cmd] | GET_INFO_TOK KEYWORD | SET_OPTION_TOK setOptionInternal[cmd] | GET_OPTION_TOK KEYWORD | DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL | DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_UNDECLARED,SYM_SORT] RPAREN_TOK sortSymbol[t] | DECLARE_FUN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t] | DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2] | DECLARE_DATATYPE_TOK datatypeDefCommand[false, cmd] | DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd] | GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSIGNMENT_TOK | ASSERT_TOK term[expr, expr2] | CHECK_SAT_TOK | CHECK_SAT_ASSUMING_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSERTIONS_TOK | GET_PROOF_TOK ( KEYWORD )? | GET_UNSAT_ASSUMPTIONS_TOK | GET_UNSAT_CORE_TOK | GET_DIFFICULTY_TOK | GET_LEARNED_LITERALS_TOK ( KEYWORD )? | PUSH_TOK (k= INTEGER_LITERAL |) | POP_TOK (k= INTEGER_LITERAL |) | EXIT_TOK | smt25Command[cmd] | extendedCommand[cmd] | SIMPLE_SYMBOL );
 */
static void
command(pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::string name;
      std::vector<std::string> names;
      cvc5::Term expr, expr2;
      cvc5::Sort t;
      std::vector<cvc5::Term> terms;
      std::vector<cvc5::Sort> sorts;
      std::vector<std::pair<std::string, cvc5::Sort> > sortedVarNames;
      std::vector<cvc5::Term> flattenVars;
      bool readKeyword = false;

    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    k;
    pANTLR3_COMMON_TOKEN    KEYWORD1;
    pANTLR3_COMMON_TOKEN    KEYWORD2;
    pANTLR3_COMMON_TOKEN    KEYWORD3;
    pANTLR3_COMMON_TOKEN    KEYWORD4;
    pANTLR3_COMMON_TOKEN    SIMPLE_SYMBOL5;

    /* Initialize rule variables
     */

    n       = NULL;
    k       = NULL;
    KEYWORD1       = NULL;
    KEYWORD2       = NULL;
    KEYWORD3       = NULL;
    KEYWORD4       = NULL;
    SIMPLE_SYMBOL5       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:211:3: ( SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT] | SET_INFO_TOK setInfoInternal[cmd] | GET_INFO_TOK KEYWORD | SET_OPTION_TOK setOptionInternal[cmd] | GET_OPTION_TOK KEYWORD | DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL | DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_UNDECLARED,SYM_SORT] RPAREN_TOK sortSymbol[t] | DECLARE_FUN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t] | DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2] | DECLARE_DATATYPE_TOK datatypeDefCommand[false, cmd] | DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd] | GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSIGNMENT_TOK | ASSERT_TOK term[expr, expr2] | CHECK_SAT_TOK | CHECK_SAT_ASSUMING_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK ) | GET_ASSERTIONS_TOK | GET_PROOF_TOK ( KEYWORD )? | GET_UNSAT_ASSUMPTIONS_TOK | GET_UNSAT_CORE_TOK | GET_DIFFICULTY_TOK | GET_LEARNED_LITERALS_TOK ( KEYWORD )? | PUSH_TOK (k= INTEGER_LITERAL |) | POP_TOK (k= INTEGER_LITERAL |) | EXIT_TOK | smt25Command[cmd] | extendedCommand[cmd] | SIMPLE_SYMBOL )

            ANTLR3_UINT32 alt10;

            alt10=28;

            switch ( LA(1) )
            {
            case SET_LOGIC_TOK:
            	{
            		alt10=1;
            	}
                break;
            case SET_INFO_TOK:
            	{
            		alt10=2;
            	}
                break;
            case GET_INFO_TOK:
            	{
            		alt10=3;
            	}
                break;
            case SET_OPTION_TOK:
            	{
            		alt10=4;
            	}
                break;
            case GET_OPTION_TOK:
            	{
            		alt10=5;
            	}
                break;
            case DECLARE_SORT_TOK:
            	{
            		alt10=6;
            	}
                break;
            case DEFINE_SORT_TOK:
            	{
            		alt10=7;
            	}
                break;
            case DECLARE_FUN_TOK:
            	{
            		alt10=8;
            	}
                break;
            case DEFINE_FUN_TOK:
            	{
            		alt10=9;
            	}
                break;
            case DECLARE_DATATYPE_TOK:
            	{
            		alt10=10;
            	}
                break;
            case DECLARE_DATATYPES_TOK:
            	{
            		alt10=11;
            	}
                break;
            case GET_VALUE_TOK:
            	{
            		alt10=12;
            	}
                break;
            case GET_ASSIGNMENT_TOK:
            	{
            		alt10=13;
            	}
                break;
            case ASSERT_TOK:
            	{
            		alt10=14;
            	}
                break;
            case CHECK_SAT_TOK:
            	{
            		alt10=15;
            	}
                break;
            case CHECK_SAT_ASSUMING_TOK:
            	{
            		alt10=16;
            	}
                break;
            case GET_ASSERTIONS_TOK:
            	{
            		alt10=17;
            	}
                break;
            case GET_PROOF_TOK:
            	{
            		alt10=18;
            	}
                break;
            case GET_UNSAT_ASSUMPTIONS_TOK:
            	{
            		alt10=19;
            	}
                break;
            case GET_UNSAT_CORE_TOK:
            	{
            		alt10=20;
            	}
                break;
            case GET_DIFFICULTY_TOK:
            	{
            		alt10=21;
            	}
                break;
            case GET_LEARNED_LITERALS_TOK:
            	{
            		alt10=22;
            	}
                break;
            case PUSH_TOK:
            	{
            		alt10=23;
            	}
                break;
            case POP_TOK:
            	{
            		alt10=24;
            	}
                break;
            case EXIT_TOK:
            	{
            		alt10=25;
            	}
                break;
            case DECLARE_CONST_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case ECHO_TOK:
            case GET_MODEL_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            	{
            		alt10=26;
            	}
                break;
            case BLOCK_MODEL_TOK:
            case BLOCK_MODEL_VALUES_TOK:
            case DECLARE_CODATATYPES_TOK:
            case DECLARE_CODATATYPE_TOK:
            case DECLARE_HEAP:
            case DECLARE_POOL:
            case DEFINE_CONST_TOK:
            case GET_ABDUCT_NEXT_TOK:
            case GET_ABDUCT_TOK:
            case GET_INTERPOL_NEXT_TOK:
            case GET_INTERPOL_TOK:
            case GET_QE_DISJUNCT_TOK:
            case GET_QE_TOK:
            case SIMPLIFY_TOK:
            	{
            		alt10=27;
            	}
                break;
            case SIMPLE_SYMBOL:
            	{
            		alt10=28;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulecommandEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:212:5: SET_LOGIC_TOK symbol[name,CHECK_NONE,SYM_SORT]
        	    {
        	         MATCHT(SET_LOGIC_TOK, &FOLLOW_SET_LOGIC_TOK_in_command260);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command262);
        	        symbol(ctx, name, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {

        	                  cmd->reset(PARSER_STATE->setLogic(name));
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:217:5: SET_INFO_TOK setInfoInternal[cmd]
        	    {
        	         MATCHT(SET_INFO_TOK, &FOLLOW_SET_INFO_TOK_in_command281);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_setInfoInternal_in_command283);
        	        setInfoInternal(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:219:5: GET_INFO_TOK KEYWORD
        	    {
        	         MATCHT(GET_INFO_TOK, &FOLLOW_GET_INFO_TOK_in_command296);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        KEYWORD1 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command298);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new GetInfoCommand(
        	                      AntlrInput::tokenText(KEYWORD1).c_str() + 1));
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:224:5: SET_OPTION_TOK setOptionInternal[cmd]
        	    {
        	         MATCHT(SET_OPTION_TOK, &FOLLOW_SET_OPTION_TOK_in_command316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_setOptionInternal_in_command318);
        	        setOptionInternal(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:226:5: GET_OPTION_TOK KEYWORD
        	    {
        	         MATCHT(GET_OPTION_TOK, &FOLLOW_GET_OPTION_TOK_in_command331);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        KEYWORD2 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command333);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new GetOptionCommand(
        	                      AntlrInput::tokenText(KEYWORD2).c_str() + 1));
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:231:5: DECLARE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL
        	    {
        	         MATCHT(DECLARE_SORT_TOK, &FOLLOW_DECLARE_SORT_TOK_in_command351);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  PARSER_STATE->checkLogicAllowsFreeSorts();
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command363);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command378);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             Trace("parser") << "declare sort: '" << name
        	                                  << "' arity=" << n << std::endl;
        	                  unsigned arity = AntlrInput::tokenToUnsigned(n);
        	                  if(arity == 0) {
        	                    cvc5::Sort type = SOLVER->mkUninterpretedSort(name);
        	                    cmd->reset(new DeclareSortCommand(name, 0, type));
        	                  } else {
        	                    cvc5::Sort type = SOLVER->mkUninterpretedSortConstructorSort(arity, name);
        	                    cmd->reset(new DeclareSortCommand(name, arity, type));
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:251:5: DEFINE_SORT_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] LPAREN_TOK symbolList[names,CHECK_UNDECLARED,SYM_SORT] RPAREN_TOK sortSymbol[t]
        	    {
        	         MATCHT(DEFINE_SORT_TOK, &FOLLOW_DEFINE_SORT_TOK_in_command396);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command404);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command417);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbolList_in_command419);
        	        symbolList(ctx, names, CHECK_UNDECLARED, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command422);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope();
        	                  for(std::vector<std::string>::const_iterator i = names.begin(),
        	                        iend = names.end();
        	                      i != iend;
        	                      ++i) {
        	                    sorts.push_back(PARSER_STATE->mkSort(*i));
        	                  }
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command434);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  cmd->reset(new DefineSortCommand(name, sorts, t));
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:268:5: DECLARE_FUN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortList[sorts] RPAREN_TOK sortSymbol[t]
        	    {
        	         MATCHT(DECLARE_FUN_TOK, &FOLLOW_DECLARE_FUN_TOK_in_command453);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command461);
        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command474);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortList_in_command476);
        	        sortList(ctx, sorts);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command479);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command485);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             Trace("parser") << "declare fun: '" << name << "'" << std::endl;
        	                  if( !sorts.empty() ) {
        	                    t = PARSER_STATE->mkFlatFunctionType(sorts, t);
        	                  }
        	                  if(t.isFunction())
        	                  {
        	                    PARSER_STATE->checkLogicAllowsFunctions();
        	                  }
        	                  // we allow overloading for function declarations
        	                  if( PARSER_STATE->sygus() )
        	                  {
        	                    PARSER_STATE->parseError("declare-fun are not allowed in sygus "
        	                                             "version 2.0");
        	                  }
        	                  else
        	                  {
        	                    cvc5::Term func = SOLVER->mkConst(t, name);
        	                    cmd->reset(new DeclareFunctionCommand(name, func, t));
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:294:5: DEFINE_FUN_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2]
        	    {
        	         MATCHT(DEFINE_FUN_TOK, &FOLLOW_DEFINE_FUN_TOK_in_command504);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_command512);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command525);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_command527);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command530);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_command536);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             /* add variables to parser state before parsing term */
        	                  Trace("parser") << "define fun: '" << name << "'" << std::endl;
        	                  if( sortedVarNames.size() > 0 ) {
        	                    sorts.reserve(sortedVarNames.size());
        	                    for(std::vector<std::pair<std::string, cvc5::Sort> >::const_iterator i =
        	                          sortedVarNames.begin(), iend = sortedVarNames.end();
        	                        i != iend;
        	                        ++i) {
        	                      sorts.push_back((*i).second);
        	                    }
        	                  }

        	                  t = PARSER_STATE->mkFlatFunctionType(sorts, t, flattenVars);
        	                  if (t.isFunction())
        	                  {
        	                    t = t.getFunctionCodomainSort();
        	                  }
        	                  if (sortedVarNames.size() > 0)
        	                  {
        	                    PARSER_STATE->pushScope();
        	                  }
        	                  terms = PARSER_STATE->bindBoundVars(sortedVarNames);
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_command549);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {

        	                  if( !flattenVars.empty() ){
        	                    // if this function has any implicit variables flattenVars,
        	                    // we apply the body of the definition to the flatten vars
        	                    expr = PARSER_STATE->mkHoApply(expr, flattenVars);
        	                    terms.insert(terms.end(), flattenVars.begin(), flattenVars.end());
        	                  }
        	                  if (sortedVarNames.size() > 0)
        	                  {
        	                    PARSER_STATE->popScope();
        	                  }
        	                  cmd->reset(new DefineFunctionCommand(name, terms, t, expr));
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:336:5: DECLARE_DATATYPE_TOK datatypeDefCommand[false, cmd]
        	    {
        	         MATCHT(DECLARE_DATATYPE_TOK, &FOLLOW_DECLARE_DATATYPE_TOK_in_command562);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypeDefCommand_in_command564);
        	        datatypeDefCommand(ctx, false, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:337:5: DECLARE_DATATYPES_TOK datatypesDefCommand[false, cmd]
        	    {
        	         MATCHT(DECLARE_DATATYPES_TOK, &FOLLOW_DECLARE_DATATYPES_TOK_in_command571);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypesDefCommand_in_command573);
        	        datatypesDefCommand(ctx, false, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:339:5: GET_VALUE_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	    {
        	         MATCHT(GET_VALUE_TOK, &FOLLOW_GET_VALUE_TOK_in_command586);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  // bind all symbols specific to the model, e.g. uninterpreted constant
        	                  // values
        	                  PARSER_STATE->pushGetValueScope();
        	                
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:346:5: ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	        {
        	            int alt4=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case ALPHA:
        	            case ASSERT_TOK:
        	            case ASSUME_TOK:
        	            case AS_TOK:
        	            case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_INST_LEVEL:
        	            case ATTRIBUTE_NAMED_TOK:
        	            case ATTRIBUTE_NO_PATTERN_TOK:
        	            case ATTRIBUTE_PATTERN_TOK:
        	            case ATTRIBUTE_POOL_TOK:
        	            case ATTRIBUTE_QUANTIFIER_ID_TOK:
        	            case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_TOK:
        	            case BINARY_LITERAL:
        	            case BLOCK_MODEL_TOK:
        	            case BLOCK_MODEL_VALUES_TOK:
        	            case CHAR_TOK:
        	            case CHECK_SAT_ASSUMING_TOK:
        	            case CHECK_SAT_TOK:
        	            case CHECK_SYNTH_NEXT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case COMMENT:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_CODATATYPES_TOK:
        	            case DECLARE_CODATATYPE_TOK:
        	            case DECLARE_CONST_TOK:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_DATATYPE_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_HEAP:
        	            case DECLARE_POOL:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_CONST_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DIGIT:
        	            case ECHO_TOK:
        	            case EXISTS_TOK:
        	            case EXIT_TOK:
        	            case FIELD_LITERAL:
        	            case FMF_CARD_TOK:
        	            case FORALL_TOK:
        	            case GET_ABDUCT_NEXT_TOK:
        	            case GET_ABDUCT_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_DIFFICULTY_TOK:
        	            case GET_INFO_TOK:
        	            case GET_INTERPOL_NEXT_TOK:
        	            case GET_INTERPOL_TOK:
        	            case GET_LEARNED_LITERALS_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_QE_DISJUNCT_TOK:
        	            case GET_QE_TOK:
        	            case GET_UNSAT_ASSUMPTIONS_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case HEX_DIGIT:
        	            case HEX_LITERAL:
        	            case HO_LAMBDA_TOK:
        	            case INCLUDE_TOK:
        	            case INDEX_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case KEYWORD:
        	            case LET_TOK:
        	            case MATCH_TOK:
        	            case NUMERAL:
        	            case PAR_TOK:
        	            case POP_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case RPAREN_TOK:
        	            case SET_COMPREHENSION_TOK:
        	            case SET_FEATURE_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STRING_LITERAL:
        	            case SYGUS_CONSTANT_TOK:
        	            case SYGUS_VARIABLE_TOK:
        	            case SYMBOL_CHAR:
        	            case SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case TESTER_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            case UPDATE_TOK:
        	            case WHITESPACE:
        	            case 105:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 4;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:346:7: LPAREN_TOK termList[terms,expr] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command600);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_termList_in_command602);
        	        	        termList(ctx, terms, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command605);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             cmd->reset(new GetValueCommand(terms)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:348:7: ~ LPAREN_TOK
        	        	    {
        	        	        if ( ((LA(1) >= ALPHA) && (LA(1) <= LET_TOK)) || ((LA(1) >= MATCH_TOK) && (LA(1) <= 105)) )
        	        	        {
        	        	            CONSUME();
        	        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        	        }
        	        	        else
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	        	            EXCEPTION->expectingSet = NULL;

        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->parseError("The get-value command expects a list of "
        	        	                                             "terms.  Perhaps you forgot a pair of "
        	        	                                             "parentheses?");
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:356:5: GET_ASSIGNMENT_TOK
        	    {
        	         MATCHT(GET_ASSIGNMENT_TOK, &FOLLOW_GET_ASSIGNMENT_TOK_in_command654);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetAssignmentCommand()); 
        	        }


        	    }
        	    break;
        	case 14:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:359:5: ASSERT_TOK term[expr, expr2]
        	    {
        	         MATCHT(ASSERT_TOK, &FOLLOW_ASSERT_TOK_in_command674);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             PARSER_STATE->clearLastNamedTerm(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_command688);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new AssertCommand(expr));
        	                  if (PARSER_STATE->lastNamedTerm().first == expr)
        	                  {
        	                    Trace("parser") << "Process top-level name: " << expr << std::endl;
        	                    // set the expression name, if there was a named term
        	                    std::pair<cvc5::Term, std::string> namedTerm =
        	                        PARSER_STATE->lastNamedTerm();
        	                    SYM_MAN->setExpressionName(namedTerm.first, namedTerm.second, true);
        	                    Trace("parser") << "finished process top-level name" << std::endl;
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 15:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:374:5: CHECK_SAT_TOK
        	    {
        	         MATCHT(CHECK_SAT_TOK, &FOLLOW_CHECK_SAT_TOK_in_command707);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {

        	                  if (PARSER_STATE->sygus()) {
        	                    PARSER_STATE->parseError("Sygus does not support check-sat command.");
        	                  }
        	                  cmd->reset(new CheckSatCommand());
        	                
        	        }


        	    }
        	    break;
        	case 16:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:382:5: CHECK_SAT_ASSUMING_TOK ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	    {
        	         MATCHT(CHECK_SAT_ASSUMING_TOK, &FOLLOW_CHECK_SAT_ASSUMING_TOK_in_command727);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:383:5: ( LPAREN_TOK termList[terms,expr] RPAREN_TOK |~ LPAREN_TOK )
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt5=1;
        	            	}
        	                break;
        	            case ALPHA:
        	            case ASSERT_TOK:
        	            case ASSUME_TOK:
        	            case AS_TOK:
        	            case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_INST_LEVEL:
        	            case ATTRIBUTE_NAMED_TOK:
        	            case ATTRIBUTE_NO_PATTERN_TOK:
        	            case ATTRIBUTE_PATTERN_TOK:
        	            case ATTRIBUTE_POOL_TOK:
        	            case ATTRIBUTE_QUANTIFIER_ID_TOK:
        	            case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_TOK:
        	            case BINARY_LITERAL:
        	            case BLOCK_MODEL_TOK:
        	            case BLOCK_MODEL_VALUES_TOK:
        	            case CHAR_TOK:
        	            case CHECK_SAT_ASSUMING_TOK:
        	            case CHECK_SAT_TOK:
        	            case CHECK_SYNTH_NEXT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case COMMENT:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_CODATATYPES_TOK:
        	            case DECLARE_CODATATYPE_TOK:
        	            case DECLARE_CONST_TOK:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_DATATYPE_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_HEAP:
        	            case DECLARE_POOL:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_CONST_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DIGIT:
        	            case ECHO_TOK:
        	            case EXISTS_TOK:
        	            case EXIT_TOK:
        	            case FIELD_LITERAL:
        	            case FMF_CARD_TOK:
        	            case FORALL_TOK:
        	            case GET_ABDUCT_NEXT_TOK:
        	            case GET_ABDUCT_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_DIFFICULTY_TOK:
        	            case GET_INFO_TOK:
        	            case GET_INTERPOL_NEXT_TOK:
        	            case GET_INTERPOL_TOK:
        	            case GET_LEARNED_LITERALS_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_QE_DISJUNCT_TOK:
        	            case GET_QE_TOK:
        	            case GET_UNSAT_ASSUMPTIONS_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case HEX_DIGIT:
        	            case HEX_LITERAL:
        	            case HO_LAMBDA_TOK:
        	            case INCLUDE_TOK:
        	            case INDEX_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case KEYWORD:
        	            case LET_TOK:
        	            case MATCH_TOK:
        	            case NUMERAL:
        	            case PAR_TOK:
        	            case POP_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case RPAREN_TOK:
        	            case SET_COMPREHENSION_TOK:
        	            case SET_FEATURE_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STRING_LITERAL:
        	            case SYGUS_CONSTANT_TOK:
        	            case SYGUS_VARIABLE_TOK:
        	            case SYMBOL_CHAR:
        	            case SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case TESTER_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            case UPDATE_TOK:
        	            case WHITESPACE:
        	            case 105:
        	            	{
        	            		alt5=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 5;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:383:7: LPAREN_TOK termList[terms,expr] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_command737);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_termList_in_command739);
        	        	        termList(ctx, terms, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_command742);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {

        	        	                    cmd->reset(new CheckSatAssumingCommand(terms));
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:387:7: ~ LPAREN_TOK
        	        	    {
        	        	        if ( ((LA(1) >= ALPHA) && (LA(1) <= LET_TOK)) || ((LA(1) >= MATCH_TOK) && (LA(1) <= 105)) )
        	        	        {
        	        	            CONSUME();
        	        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        	        }
        	        	        else
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	        	            EXCEPTION->expectingSet = NULL;

        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->parseError("The check-sat-assuming command expects a "
        	        	                                             "list of terms.  Perhaps you forgot a pair of "
        	        	                                             "parentheses?");
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 17:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:394:5: GET_ASSERTIONS_TOK
        	    {
        	         MATCHT(GET_ASSERTIONS_TOK, &FOLLOW_GET_ASSERTIONS_TOK_in_command785);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetAssertionsCommand()); 
        	        }


        	    }
        	    break;
        	case 18:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:397:5: GET_PROOF_TOK ( KEYWORD )?
        	    {
        	         MATCHT(GET_PROOF_TOK, &FOLLOW_GET_PROOF_TOK_in_command805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:397:19: ( KEYWORD )?
        	        {
        	            int alt6=2;
        	            switch ( LA(1) )
        	            {
        	                case KEYWORD:
        	                	{
        	                		alt6=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt6)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:397:21: KEYWORD
        	        	    {
        	        	        KEYWORD3 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command809);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             readKeyword = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  modes::ProofComponent pc = modes::PROOF_COMPONENT_FULL;
        	                  if (readKeyword)
        	                  {
        	                    pc = PARSER_STATE->getProofComponent(
        	                           AntlrInput::tokenText(KEYWORD3).c_str() + 1);
        	                  }
        	                  cmd->reset(new GetProofCommand(pc));
        	                
        	        }


        	    }
        	    break;
        	case 19:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:408:5: GET_UNSAT_ASSUMPTIONS_TOK
        	    {
        	         MATCHT(GET_UNSAT_ASSUMPTIONS_TOK, &FOLLOW_GET_UNSAT_ASSUMPTIONS_TOK_in_command829);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetUnsatAssumptionsCommand); 
        	        }


        	    }
        	    break;
        	case 20:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:411:5: GET_UNSAT_CORE_TOK
        	    {
        	         MATCHT(GET_UNSAT_CORE_TOK, &FOLLOW_GET_UNSAT_CORE_TOK_in_command849);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetUnsatCoreCommand); 
        	        }


        	    }
        	    break;
        	case 21:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:414:5: GET_DIFFICULTY_TOK
        	    {
        	         MATCHT(GET_DIFFICULTY_TOK, &FOLLOW_GET_DIFFICULTY_TOK_in_command869);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetDifficultyCommand); 
        	        }


        	    }
        	    break;
        	case 22:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:417:5: GET_LEARNED_LITERALS_TOK ( KEYWORD )?
        	    {
        	         MATCHT(GET_LEARNED_LITERALS_TOK, &FOLLOW_GET_LEARNED_LITERALS_TOK_in_command889);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:417:30: ( KEYWORD )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	                case KEYWORD:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:417:32: KEYWORD
        	        	    {
        	        	        KEYWORD4 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_command893);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {
        	        	             readKeyword = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  modes::LearnedLitType llt = modes::LEARNED_LIT_INPUT;
        	                  if (readKeyword)
        	                  {
        	                    llt = PARSER_STATE->getLearnedLitType(
        	                            AntlrInput::tokenText(KEYWORD4).c_str() + 1);
        	                  }
        	                  cmd->reset(new GetLearnedLiteralsCommand(llt)); 
        	        }


        	    }
        	    break;
        	case 23:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:427:5: PUSH_TOK (k= INTEGER_LITERAL |)
        	    {
        	         MATCHT(PUSH_TOK, &FOLLOW_PUSH_TOK_in_command912);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:428:5: (k= INTEGER_LITERAL |)
        	        {
        	            int alt8=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt8=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 8;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:428:7: k= INTEGER_LITERAL
        	        	    {
        	        	        k = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command922);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {

        	        	                    uint32_t num = AntlrInput::tokenToUnsigned(k);
        	        	                    *cmd = PARSER_STATE->handlePush(num);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:433:7: 
        	        	    {
        	        	        {

        	        	                    *cmd = PARSER_STATE->handlePush(std::nullopt);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:438:5: POP_TOK (k= INTEGER_LITERAL |)
        	    {
        	         MATCHT(POP_TOK, &FOLLOW_POP_TOK_in_command956);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:439:5: (k= INTEGER_LITERAL |)
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt9=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 9;
        	                EXCEPTION->state        = 0;


        	                goto rulecommandEx;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:439:7: k= INTEGER_LITERAL
        	        	    {
        	        	        k = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_command966);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	        {

        	        	                    uint32_t num = AntlrInput::tokenToUnsigned(k);
        	        	                    *cmd = PARSER_STATE->handlePop(num);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:444:7: 
        	        	    {
        	        	        {

        	        	                    *cmd = PARSER_STATE->handlePop(std::nullopt);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 25:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:449:5: EXIT_TOK
        	    {
        	         MATCHT(EXIT_TOK, &FOLLOW_EXIT_TOK_in_command1000);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             cmd->reset(new QuitCommand()); 
        	        }


        	    }
        	    break;
        	case 26:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:453:5: smt25Command[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_smt25Command_in_command1019);
        	        smt25Command(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	    }
        	    break;
        	case 27:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:456:5: extendedCommand[cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_extendedCommand_in_command1033);
        	        extendedCommand(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             if(PARSER_STATE->strictModeEnabled()) {
        	                    PARSER_STATE->parseError(
        	                        "Extended commands are not permitted while operating in strict "
        	                        "compliance mode.");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 28:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:465:5: SIMPLE_SYMBOL
        	    {
        	        SIMPLE_SYMBOL5 = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_command1053);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        {
        	             std::string id = AntlrInput::tokenText(SIMPLE_SYMBOL5);
        	                  if(id == "benchmark") {
        	                    PARSER_STATE->parseError(
        	                        "In SMT-LIBv2 mode, but got something that looks like SMT-LIBv1, "
        	                        "which is not supported anymore.");
        	                  } else {
        	                    PARSER_STATE->parseError("expected SMT-LIBv2 command, got `" + id +
        	                                             "'.");
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecommandEx; /* Prevent compiler warnings */
    rulecommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end command */

/**
 * $ANTLR start sygusCommand
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:478:1: sygusCommand returns [std::unique_ptr<cvc5::parser::Command> cmd] : ( DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t] | ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range] )? ( sygusGrammar[grammar, sygusVars, name] )? | ( CONSTRAINT_TOK | ASSUME_TOK ) term[expr, expr2] | INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+ | CHECK_SYNTH_TOK | CHECK_SYNTH_NEXT_TOK | SET_FEATURE_TOK keyword[name] symbolicExpr[expr] | command[&cmd] );
 */
static std::unique_ptr<cvc5::parser::Command>
sygusCommand(pSmt2Parser ctx)
{
    std::unique_ptr<cvc5::parser::Command> cmd;



      cvc5::Term expr, expr2, fun;
      cvc5::Sort t, range;
      std::vector<std::string> names;
      std::vector<std::pair<std::string, cvc5::Sort> > sortedVarNames;
      std::vector<cvc5::Term> sygusVars;
      std::string name;
      bool isAssume;
      bool isInv;
      cvc5::Grammar* grammar = nullptr;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:490:3: ( DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t] | ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range] )? ( sygusGrammar[grammar, sygusVars, name] )? | ( CONSTRAINT_TOK | ASSUME_TOK ) term[expr, expr2] | INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+ | CHECK_SYNTH_TOK | CHECK_SYNTH_NEXT_TOK | SET_FEATURE_TOK keyword[name] symbolicExpr[expr] | command[&cmd] )

            ANTLR3_UINT32 alt16;

            alt16=8;

            switch ( LA(1) )
            {
            case DECLARE_VAR_TOK:
            	{
            		alt16=1;
            	}
                break;
            case SYNTH_FUN_TOK:
            case SYNTH_INV_TOK:
            	{
            		alt16=2;
            	}
                break;
            case ASSUME_TOK:
            case CONSTRAINT_TOK:
            	{
            		alt16=3;
            	}
                break;
            case INV_CONSTRAINT_TOK:
            	{
            		alt16=4;
            	}
                break;
            case CHECK_SYNTH_TOK:
            	{
            		alt16=5;
            	}
                break;
            case CHECK_SYNTH_NEXT_TOK:
            	{
            		alt16=6;
            	}
                break;
            case SET_FEATURE_TOK:
            	{
            		alt16=7;
            	}
                break;
            case ASSERT_TOK:
            case BLOCK_MODEL_TOK:
            case BLOCK_MODEL_VALUES_TOK:
            case CHECK_SAT_ASSUMING_TOK:
            case CHECK_SAT_TOK:
            case DECLARE_CODATATYPES_TOK:
            case DECLARE_CODATATYPE_TOK:
            case DECLARE_CONST_TOK:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_DATATYPE_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_HEAP:
            case DECLARE_POOL:
            case DECLARE_SORT_TOK:
            case DEFINE_CONST_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case GET_ABDUCT_NEXT_TOK:
            case GET_ABDUCT_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_DIFFICULTY_TOK:
            case GET_INFO_TOK:
            case GET_INTERPOL_NEXT_TOK:
            case GET_INTERPOL_TOK:
            case GET_LEARNED_LITERALS_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_QE_DISJUNCT_TOK:
            case GET_QE_TOK:
            case GET_UNSAT_ASSUMPTIONS_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case POP_TOK:
            case PUSH_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            	{
            		alt16=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulesygusCommandEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:491:5: DECLARE_VAR_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t]
        	    {
        	         MATCHT(DECLARE_VAR_TOK, &FOLLOW_DECLARE_VAR_TOK_in_sygusCommand1087);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1095);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1108);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {

        	                  cvc5::Term var = SOLVER->declareSygusVar(name, t);
        	                  cmd.reset(new DeclareSygusVarCommand(name, var, t));
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:500:5: ( SYNTH_FUN_TOK | SYNTH_INV_TOK ) symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ( sortSymbol[range] )? ( sygusGrammar[grammar, sygusVars, name] )?
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:500:5: ( SYNTH_FUN_TOK | SYNTH_INV_TOK )
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	            case SYNTH_FUN_TOK:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;
        	            case SYNTH_INV_TOK:
        	            	{
        	            		alt11=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 11;
        	                EXCEPTION->state        = 0;


        	                goto rulesygusCommandEx;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:500:7: SYNTH_FUN_TOK
        	        	    {
        	        	         MATCHT(SYNTH_FUN_TOK, &FOLLOW_SYNTH_FUN_TOK_in_sygusCommand1129);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             isInv = false; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:501:9: SYNTH_INV_TOK
        	        	    {
        	        	         MATCHT(SYNTH_INV_TOK, &FOLLOW_SYNTH_INV_TOK_in_sygusCommand1141);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             isInv = true; range = SOLVER->getBooleanSort(); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1161);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusCommand1168);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_sygusCommand1170);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusCommand1173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:506:5: ( sortSymbol[range] )?
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	                case QUOTED_SYMBOL:
        	                case SIMPLE_SYMBOL:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                	{
        	                		alt12=1;
        	                	}
        	                    break;
        	                case LPAREN_TOK:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case INDEX_TOK:
        	                		    case QUOTED_SYMBOL:
        	                		    case SIMPLE_SYMBOL:
        	                		    case UNTERMINATED_QUOTED_SYMBOL:
        	                		    	{
        	                		    		alt12=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:506:7: sortSymbol[range]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusCommand1181);
        	        	        sortSymbol(ctx, range);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  PARSER_STATE->pushScope();
        	                  sygusVars = PARSER_STATE->bindBoundVars(sortedVarNames);
        	                
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:511:5: ( sygusGrammar[grammar, sygusVars, name] )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:516:7: sygusGrammar[grammar, sygusVars, name]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sygusGrammar_in_sygusCommand1233);
        	        	        sygusGrammar(ctx, grammar, sygusVars, name);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  Trace("parser-sygus") << "Define synth fun : " << name << std::endl;

        	                  fun = isInv ? (grammar == nullptr
        	                                     ? SOLVER->synthInv(name, sygusVars)
        	                                     : SOLVER->synthInv(name, sygusVars, *grammar))
        	                              : (grammar == nullptr
        	                                     ? SOLVER->synthFun(name, sygusVars, range)
        	                                     : SOLVER->synthFun(name, sygusVars, range, *grammar));

        	                  Trace("parser-sygus") << "...read synth fun " << name << std::endl;
        	                  PARSER_STATE->popScope();
        	                  // we do not allow overloading for synth fun
        	                  cmd = std::unique_ptr<cvc5::parser::Command>(
        	                      new SynthFunCommand(name, fun, sygusVars, range, isInv, grammar));
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:535:5: ( CONSTRAINT_TOK | ASSUME_TOK ) term[expr, expr2]
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:535:5: ( CONSTRAINT_TOK | ASSUME_TOK )
        	        {
        	            int alt14=2;
        	            switch ( LA(1) )
        	            {
        	            case CONSTRAINT_TOK:
        	            	{
        	            		alt14=1;
        	            	}
        	                break;
        	            case ASSUME_TOK:
        	            	{
        	            		alt14=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 14;
        	                EXCEPTION->state        = 0;


        	                goto rulesygusCommandEx;

        	            }

        	            switch (alt14)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:535:7: CONSTRAINT_TOK
        	        	    {
        	        	         MATCHT(CONSTRAINT_TOK, &FOLLOW_CONSTRAINT_TOK_in_sygusCommand1261);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             isAssume = false; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:535:46: ASSUME_TOK
        	        	    {
        	        	         MATCHT(ASSUME_TOK, &FOLLOW_ASSUME_TOK_in_sygusCommand1267);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesygusCommandEx;
        	        	        }


        	        	        {
        	        	             isAssume = true; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_sygusCommand1283);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {
        	             Trace("parser-sygus") << "...read constraint " << expr << std::endl;
        	                  cmd.reset(new SygusConstraintCommand(expr, isAssume));
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:544:5: INV_CONSTRAINT_TOK ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+
        	    {
        	         MATCHT(INV_CONSTRAINT_TOK, &FOLLOW_INV_CONSTRAINT_TOK_in_sygusCommand1302);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:545:5: ( symbol[name,CHECK_NONE,SYM_VARIABLE] )+
        	        {
        	            int cnt15=0;

        	            for (;;)
        	            {
        	                int alt15=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case QUOTED_SYMBOL:
        	        	case SIMPLE_SYMBOL:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        		{
        	        			alt15=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt15)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:545:7: symbol[name,CHECK_NONE,SYM_VARIABLE]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_symbol_in_sygusCommand1310);
        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesygusCommandEx;
        	        	            }


        	        	            {
        	        	                 names.push_back(name); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt15 >= 1 )
        	        		{
        	        		    goto loop15;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesygusCommandEx;
        	        	}
        	        	cnt15++;
        	            }
        	            loop15: ;	/* Jump to here if this rule does not match */
        	        }

        	        {

        	                  cmd = PARSER_STATE->invConstraint(names);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:550:5: CHECK_SYNTH_TOK
        	    {
        	         MATCHT(CHECK_SYNTH_TOK, &FOLLOW_CHECK_SYNTH_TOK_in_sygusCommand1334);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  cmd.reset(new CheckSynthCommand());
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:556:5: CHECK_SYNTH_NEXT_TOK
        	    {
        	         MATCHT(CHECK_SYNTH_NEXT_TOK, &FOLLOW_CHECK_SYNTH_NEXT_TOK_in_sygusCommand1352);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  cmd.reset(new CheckSynthCommand(true));
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:562:5: SET_FEATURE_TOK keyword[name] symbolicExpr[expr]
        	    {
        	         MATCHT(SET_FEATURE_TOK, &FOLLOW_SET_FEATURE_TOK_in_sygusCommand1370);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_keyword_in_sygusCommand1372);
        	        keyword(ctx, name);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_sygusCommand1375);
        	        symbolicExpr(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  // ":grammars" is defined in the SyGuS version 2.1 standard and is by
        	                  // default supported, all other features are not.
        	                  if (name != ":grammars")
        	                  {
        	                    std::stringstream ss;
        	                    ss << "SyGuS feature " << name.substr(1) << " not currently supported";
        	                    PARSER_STATE->warning(ss.str());
        	                  }
        	                  cmd.reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:575:5: command[&cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_command_in_sygusCommand1388);
        	        command(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesygusCommandEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesygusCommandEx; /* Prevent compiler warnings */
    rulesygusCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return cmd;
}
/* $ANTLR end sygusCommand */

/**
 * $ANTLR start sygusGrammar
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:588:1: sygusGrammar[cvc5::Grammar*& ret,\n const std::vector<cvc5::Term>& sygusVars,\n const std::string& fun] : LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] ( LPAREN_TOK | RPAREN_TOK ) )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK symbol[name, CHECK_DECLARED, SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK ;
 */
static void
sygusGrammar(pSmt2Parser ctx, cvc5::Grammar*& ret, const std::vector<cvc5::Term>& sygusVars, const std::string& fun)
{

      // the pre-declaration
      std::vector<std::pair<std::string, cvc5::Sort>> sortedVarNames;
      // non-terminal symbols of the grammar
      std::vector<cvc5::Term> ntSyms;
      cvc5::Sort t;
      std::string name;
      cvc5::Term e, e2;
      unsigned dtProcessed = 0;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:602:3: ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] ( LPAREN_TOK | RPAREN_TOK ) )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK symbol[name, CHECK_DECLARED, SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:604:3: LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] ( LPAREN_TOK | RPAREN_TOK ) )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK symbol[name, CHECK_DECLARED, SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK )+ RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1416);
            if  (HASEXCEPTION())
            {
                goto rulesygusGrammarEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:608:3: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] ( LPAREN_TOK | RPAREN_TOK ) )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:608:5: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] ( LPAREN_TOK | RPAREN_TOK )
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1431);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesygusGrammarEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_symbol_in_sygusGrammar1433);
            	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesygusGrammarEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGrammar1440);
            	        sortSymbol(ctx, t);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesygusGrammarEx;
            	        }


            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:609:19: ( LPAREN_TOK | RPAREN_TOK )
            	        {
            	            int alt17=2;
            	            switch ( LA(1) )
            	            {
            	            case LPAREN_TOK:
            	            	{
            	            		alt17=1;
            	            	}
            	                break;
            	            case RPAREN_TOK:
            	            	{
            	            		alt17=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 17;
            	                EXCEPTION->state        = 0;


            	                goto rulesygusGrammarEx;

            	            }

            	            switch (alt17)
            	            {
            	        	case 1:
            	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:612:7: LPAREN_TOK
            	        	    {
            	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1465);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesygusGrammarEx;
            	        	        }


            	        	        {

            	        	                    std::stringstream sse;
            	        	                    if (sortedVarNames.empty())
            	        	                    {
            	        	                      sse << "The expected SyGuS language is version 2.0, whereas the "
            	        	                          << "input appears to be SyGuS version 1.0 format. The version "
            	        	                          << "2.0 format requires a predeclaration of the non-terminal "
            	        	                          << "symbols of the grammar to be given prior to the definition "
            	        	                          << "of the grammar. See https://sygus.org/language/ for details "
            	        	                          << "and examples. cvc5 versions past 1.8 do not support SyGuS "
            	        	                          << "version 1.0.";
            	        	                    }
            	        	                    else
            	        	                    {
            	        	                      // an unknown syntax error
            	        	                      sse << "Unexpected syntax for SyGuS predeclaration.";
            	        	                    }
            	        	                    PARSER_STATE->parseError(sse.str().c_str());
            	        	                  
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:632:7: RPAREN_TOK
            	        	    {
            	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1481);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesygusGrammarEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	             sortedVarNames.push_back(make_pair(name, t)); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1498);
            if  (HASEXCEPTION())
            {
                goto rulesygusGrammarEx;
            }


            {

                    // non-terminal symbols in the pre-declaration are locally scoped
                    PARSER_STATE->pushScope();
                    for (std::pair<std::string, cvc5::Sort>& i : sortedVarNames)
                    {
                      PARSER_STATE->checkDeclaration(name, CHECK_UNDECLARED, SYM_SORT);
                      // make the non-terminal symbol, which will be parsed as an ordinary
                      // free variable.
                      cvc5::Term nts = PARSER_STATE->bindBoundVar(i.first, i.second);
                      ntSyms.push_back(nts);
                    }
                    ret = PARSER_STATE->mkGrammar(sygusVars, ntSyms);
                  
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1509);
            if  (HASEXCEPTION())
            {
                goto rulesygusGrammarEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:651:3: ( LPAREN_TOK symbol[name, CHECK_DECLARED, SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK )+
            {
                int cnt20=0;

                for (;;)
                {
                    int alt20=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            		{
            			alt20=1;
            		}
            	    break;

            	}

            	switch (alt20)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:652:5: LPAREN_TOK symbol[name, CHECK_DECLARED, SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK
            	        {
            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1519);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_symbol_in_sygusGrammar1525);
            	            symbol(ctx, name, CHECK_DECLARED, SYM_VARIABLE);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGrammar1528);
            	            sortSymbol(ctx, t);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	            {

            	                      // check that it matches sortedVarNames
            	                      if (sortedVarNames[dtProcessed].first != name)
            	                      {
            	                        std::stringstream sse;
            	                        sse << "Grouped rule listing " << name
            	                            << " does not match the name (in order) from the predeclaration ("
            	                            << sortedVarNames[dtProcessed].first << ")." << std::endl;
            	                        PARSER_STATE->parseError(sse.str().c_str());
            	                      }
            	                      if (sortedVarNames[dtProcessed].second != t)
            	                      {
            	                        std::stringstream sse;
            	                        sse << "Type for grouped rule listing " << name
            	                            << " does not match the type (in order) from the predeclaration ("
            	                            << sortedVarNames[dtProcessed].second << ")." << std::endl;
            	                        PARSER_STATE->parseError(sse.str().c_str());
            	                      }
            	                    
            	            }


            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1541);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:674:5: ( term[e,e2] | LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK | LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK )+
            	            {
            	                int cnt19=0;

            	                for (;;)
            	                {
            	                    int alt19=4;
            	            	switch ( LA(1) )
            	            	{
            	            	case LPAREN_TOK:
            	            		{
            	            			switch ( LA(2) )
            	            			{
            	            			case AS_TOK:
            	            			case ATTRIBUTE_TOK:
            	            			case EXISTS_TOK:
            	            			case FORALL_TOK:
            	            			case HO_LAMBDA_TOK:
            	            			case INDEX_TOK:
            	            			case LET_TOK:
            	            			case LPAREN_TOK:
            	            			case MATCH_TOK:
            	            			case QUOTED_SYMBOL:
            	            			case SET_COMPREHENSION_TOK:
            	            			case SIMPLE_SYMBOL:
            	            			case UNTERMINATED_QUOTED_SYMBOL:
            	            				{
            	            					alt19=1;
            	            				}
            	            			    break;
            	            			case SYGUS_CONSTANT_TOK:
            	            				{
            	            					alt19=2;
            	            				}
            	            			    break;
            	            			case SYGUS_VARIABLE_TOK:
            	            				{
            	            					alt19=3;
            	            				}
            	            			    break;

            	            			}

            	            		}
            	            	    break;
            	            	case BINARY_LITERAL:
            	            	case DECIMAL_LITERAL:
            	            	case FIELD_LITERAL:
            	            	case HEX_LITERAL:
            	            	case INTEGER_LITERAL:
            	            	case QUOTED_SYMBOL:
            	            	case SIMPLE_SYMBOL:
            	            	case STRING_LITERAL:
            	            	case UNTERMINATED_QUOTED_SYMBOL:
            	            	case UNTERMINATED_STRING_LITERAL:
            	            		{
            	            			alt19=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt19)
            	            	{
            	            	    case 1:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:675:7: term[e,e2]
            	            	        {
            	            	            FOLLOWPUSH(FOLLOW_term_in_sygusGrammar1555);
            	            	            term(ctx, e, e2);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	            {

            	            	                        // add term as constructor to datatype
            	            	                        ret->addRule(ntSyms[dtProcessed], e);
            	            	                      
            	            	            }


            	            	        }
            	            	        break;
            	            	    case 2:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:679:9: LPAREN_TOK SYGUS_CONSTANT_TOK sortSymbol[t] RPAREN_TOK
            	            	        {
            	            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1568);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	             MATCHT(SYGUS_CONSTANT_TOK, &FOLLOW_SYGUS_CONSTANT_TOK_in_sygusGrammar1570);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGrammar1572);
            	            	            sortSymbol(ctx, t);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1575);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	            {

            	            	                        // allow constants in datatype for ntSyms[dtProcessed]
            	            	                        ret->addAnyConstant(ntSyms[dtProcessed]);
            	            	                      
            	            	            }


            	            	        }
            	            	        break;
            	            	    case 3:
            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:683:9: LPAREN_TOK SYGUS_VARIABLE_TOK sortSymbol[t] RPAREN_TOK
            	            	        {
            	            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sygusGrammar1587);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	             MATCHT(SYGUS_VARIABLE_TOK, &FOLLOW_SYGUS_VARIABLE_TOK_in_sygusGrammar1589);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	            FOLLOWPUSH(FOLLOW_sortSymbol_in_sygusGrammar1591);
            	            	            sortSymbol(ctx, t);

            	            	            FOLLOWPOP();
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1594);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulesygusGrammarEx;
            	            	            }


            	            	            {

            	            	                        // add variable constructors to datatype
            	            	                        ret->addAnyVariable(ntSyms[dtProcessed]);
            	            	                      
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt19 >= 1 )
            	            		{
            	            		    goto loop19;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulesygusGrammarEx;
            	            	}
            	            	cnt19++;
            	                }
            	                loop19: ;	/* Jump to here if this rule does not match */
            	            }

            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1609);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1615);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesygusGrammarEx;
            	            }


            	            {

            	                      dtProcessed++;
            	                    
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt20 >= 1 )
            		{
            		    goto loop20;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesygusGrammarEx;
            	}
            	cnt20++;
                }
                loop20: ;	/* Jump to here if this rule does not match */
            }

             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sygusGrammar1630);
            if  (HASEXCEPTION())
            {
                goto rulesygusGrammarEx;
            }


            {

                    // pop scope from the pre-declaration
                    PARSER_STATE->popScope();
                  
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesygusGrammarEx; /* Prevent compiler warnings */
    rulesygusGrammarEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sygusGrammar */

/**
 * $ANTLR start setInfoInternal
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:701:1: setInfoInternal[std::unique_ptr<cvc5::parser::Command>* cmd] : keyword[name] symbolicExpr[sexpr] ;
 */
static void
setInfoInternal(pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::string name;
      cvc5::Term sexpr;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:706:3: ( keyword[name] symbolicExpr[sexpr] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:706:5: keyword[name] symbolicExpr[sexpr]
        {
            FOLLOWPUSH(FOLLOW_keyword_in_setInfoInternal1651);
            keyword(ctx, name);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetInfoInternalEx;
            }


            FOLLOWPUSH(FOLLOW_symbolicExpr_in_setInfoInternal1654);
            symbolicExpr(ctx, sexpr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetInfoInternalEx;
            }


            {
                 cmd->reset(new SetInfoCommand(name.c_str() + 1, sexprToString(sexpr))); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesetInfoInternalEx; /* Prevent compiler warnings */
    rulesetInfoInternalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end setInfoInternal */

/**
 * $ANTLR start setOptionInternal
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:710:1: setOptionInternal[std::unique_ptr<cvc5::parser::Command>* cmd] : keyword[name] symbolicExpr[sexpr] ;
 */
static void
setOptionInternal(pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd)
{
    /* Initialize rule variables
     */


      std::string name;
      cvc5::Term sexpr;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:715:3: ( keyword[name] symbolicExpr[sexpr] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:715:5: keyword[name] symbolicExpr[sexpr]
        {
            FOLLOWPUSH(FOLLOW_keyword_in_setOptionInternal1680);
            keyword(ctx, name);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetOptionInternalEx;
            }


            FOLLOWPUSH(FOLLOW_symbolicExpr_in_setOptionInternal1683);
            symbolicExpr(ctx, sexpr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesetOptionInternalEx;
            }


            {
                 
                      std::string key = name.c_str() + 1;
                      std::string ss = sexprToString(sexpr);
                      // special case: for channel settings, we are expected to parse e.g.
                      // `"stdin"` which should be treated as `stdin`
                      // Note we could consider a more general solution where knowing whether
                      // this special case holds can be queried via OptionInfo.
                      if (key == "diagnostic-output-channel" || key == "regular-output-channel"
                          || key == "in" || key == "out")
                      {
                        ss = PARSER_STATE->stripQuotes(ss);
                      }
                      cmd->reset(new SetOptionCommand(key, ss));
                      // Ugly that this changes the state of the parser; but
                      // global-declarations affects parsing, so we can't hold off
                      // on this until some SolverEngine eventually (if ever) executes it.
                      if(key == "global-declarations")
                      {
                        SYM_MAN->setGlobalDeclarations(sexprToString(sexpr) == "true");
                      }
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesetOptionInternalEx; /* Prevent compiler warnings */
    rulesetOptionInternalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end setOptionInternal */

/**
 * $ANTLR start smt25Command
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:739:1: smt25Command[std::unique_ptr<cvc5::parser::Command>* cmd] : ( DECLARE_CONST_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] | GET_MODEL_TOK | ECHO_TOK ( str[s, true] |) | RESET_TOK | RESET_ASSERTIONS_TOK | DEFINE_FUN_REC_TOK symbol[fname,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2] | DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK );
 */
static void
smt25Command(pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::string name;
      std::string fname;
      cvc5::Term expr, expr2;
      std::vector<std::pair<std::string, cvc5::Sort> > sortedVarNames;
      std::string s;
      cvc5::Sort t;
      cvc5::Term func;
      std::vector<cvc5::Term> bvs;
      std::vector<std::vector<std::pair<std::string, cvc5::Sort>>>
          sortedVarNamesList;
      std::vector<std::vector<cvc5::Term>> flattenVarsList;
      std::vector<std::vector<cvc5::Term>> formals;
      std::vector<cvc5::Term> funcs;
      std::vector<cvc5::Term> func_defs;
      cvc5::Term aexpr;
      std::vector<cvc5::Sort> sorts;
      std::vector<cvc5::Term> flattenVars;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:760:3: ( DECLARE_CONST_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] | GET_MODEL_TOK | ECHO_TOK ( str[s, true] |) | RESET_TOK | RESET_ASSERTIONS_TOK | DEFINE_FUN_REC_TOK symbol[fname,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2] | DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK )

            ANTLR3_UINT32 alt24;

            alt24=7;

            switch ( LA(1) )
            {
            case DECLARE_CONST_TOK:
            	{
            		alt24=1;
            	}
                break;
            case GET_MODEL_TOK:
            	{
            		alt24=2;
            	}
                break;
            case ECHO_TOK:
            	{
            		alt24=3;
            	}
                break;
            case RESET_TOK:
            	{
            		alt24=4;
            	}
                break;
            case RESET_ASSERTIONS_TOK:
            	{
            		alt24=5;
            	}
                break;
            case DEFINE_FUN_REC_TOK:
            	{
            		alt24=6;
            	}
                break;
            case DEFINE_FUNS_REC_TOK:
            	{
            		alt24=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulesmt25CommandEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:760:5: DECLARE_CONST_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t]
        	    {
        	         MATCHT(DECLARE_CONST_TOK, &FOLLOW_DECLARE_CONST_TOK_in_smt25Command1715);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_smt25Command1723);
        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command1736);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             // allow overloading here
        	                  if( PARSER_STATE->sygus() )
        	                  {
        	                    PARSER_STATE->parseError("declare-const is not allowed in sygus "
        	                                             "version 2.0");
        	                  }
        	                  cvc5::Term c = SOLVER->mkConst(t, name);
        	                  cmd->reset(new DeclareFunctionCommand(name, c, t)); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:774:5: GET_MODEL_TOK
        	    {
        	         MATCHT(GET_MODEL_TOK, &FOLLOW_GET_MODEL_TOK_in_smt25Command1756);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {
        	             cmd->reset(new GetModelCommand()); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:778:5: ECHO_TOK ( str[s, true] |)
        	    {
        	         MATCHT(ECHO_TOK, &FOLLOW_ECHO_TOK_in_smt25Command1777);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:779:5: ( str[s, true] |)
        	        {
        	            int alt21=2;
        	            switch ( LA(1) )
        	            {
        	            case STRING_LITERAL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            	{
        	            		alt21=1;
        	            	}
        	                break;
        	            case RPAREN_TOK:
        	            	{
        	            		alt21=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 21;
        	                EXCEPTION->state        = 0;


        	                goto rulesmt25CommandEx;

        	            }

        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:779:7: str[s, true]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_str_in_smt25Command1785);
        	        	        str(ctx, s, true);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesmt25CommandEx;
        	        	        }


        	        	        {
        	        	             cmd->reset(new EchoCommand(s)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:781:7: 
        	        	    {
        	        	        {
        	        	             cmd->reset(new EchoCommand()); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:786:5: RESET_TOK
        	    {
        	         MATCHT(RESET_TOK, &FOLLOW_RESET_TOK_in_smt25Command1821);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {

        	                  cmd->reset(new ResetCommand());
        	                  // reset the state of the parser, which is independent of the symbol
        	                  // manager
        	                  PARSER_STATE->reset();
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:795:5: RESET_ASSERTIONS_TOK
        	    {
        	         MATCHT(RESET_ASSERTIONS_TOK, &FOLLOW_RESET_ASSERTIONS_TOK_in_smt25Command1839);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             cmd->reset(new ResetAssertionsCommand());
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:798:5: DEFINE_FUN_REC_TOK symbol[fname,CHECK_NONE,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] term[expr, expr2]
        	    {
        	         MATCHT(DEFINE_FUN_REC_TOK, &FOLLOW_DEFINE_FUN_REC_TOK_in_smt25Command1851);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_smt25Command1863);
        	        symbol(ctx, fname, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(fname); 
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command1876);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortedVarList_in_smt25Command1878);
        	        sortedVarList(ctx, sortedVarNames);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command1881);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command1887);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {

        	                  func =
        	                      PARSER_STATE->bindDefineFunRec(fname, sortedVarNames, t, flattenVars);
        	                  PARSER_STATE->pushDefineFunRecScope(
        	                      sortedVarNames, func, flattenVars, bvs);
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_smt25Command1900);
        	        term(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->popScope();
        	                  if( !flattenVars.empty() ){
        	                    expr = PARSER_STATE->mkHoApply( expr, flattenVars );
        	                  }
        	                  cmd->reset(new DefineFunctionRecCommand(func, bvs, expr));
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:817:5: DEFINE_FUNS_REC_TOK LPAREN_TOK ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] RPAREN_TOK )+ RPAREN_TOK LPAREN_TOK ( term[expr,expr2] )+ RPAREN_TOK
        	    {
        	         MATCHT(DEFINE_FUNS_REC_TOK, &FOLLOW_DEFINE_FUNS_REC_TOK_in_smt25Command1913);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet();
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command1925);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:820:5: ( LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] RPAREN_TOK )+
        	        {
        	            int cnt22=0;

        	            for (;;)
        	            {
        	                int alt22=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt22=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt22)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:820:7: LPAREN_TOK symbol[fname,CHECK_UNDECLARED,SYM_VARIABLE] LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK sortSymbol[t] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command1933);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_smt25Command1941);
        	        	            symbol(ctx, fname, CHECK_UNDECLARED, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {
        	        	                 PARSER_STATE->checkUserSymbol(fname); 
        	        	            }


        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command1958);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortedVarList_in_smt25Command1960);
        	        	            sortedVarList(ctx, sortedVarNames);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command1963);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_smt25Command1971);
        	        	            sortSymbol(ctx, t);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {

        	        	                        flattenVars.clear();
        	        	                        func = PARSER_STATE->bindDefineFunRec(
        	        	                            fname, sortedVarNames, t, flattenVars);
        	        	                        funcs.push_back( func );

        	        	                        // add to lists (need to remember for when parsing the bodies)
        	        	                        sortedVarNamesList.push_back( sortedVarNames );
        	        	                        flattenVarsList.push_back( flattenVars );

        	        	                        // set up parsing the next variable list block
        	        	                        sortedVarNames.clear();
        	        	                        flattenVars.clear();
        	        	                      
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command1988);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt22 >= 1 )
        	        		{
        	        		    goto loop22;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesmt25CommandEx;
        	        	}
        	        	cnt22++;
        	            }
        	            loop22: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2001);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_smt25Command2007);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {

        	                  //set up the first scope
        	                  if( sortedVarNamesList.empty() ){
        	                    PARSER_STATE->parseError("Must define at least one function in "
        	                                             "define-funs-rec");
        	                  }
        	                  bvs.clear();
        	                  PARSER_STATE->pushDefineFunRecScope( sortedVarNamesList[0], funcs[0],
        	                                                       flattenVarsList[0], bvs);
        	                
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:853:5: ( term[expr,expr2] )+
        	        {
        	            int cnt23=0;

        	            for (;;)
        	            {
        	                int alt23=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case BINARY_LITERAL:
        	        	case DECIMAL_LITERAL:
        	        	case FIELD_LITERAL:
        	        	case HEX_LITERAL:
        	        	case INTEGER_LITERAL:
        	        	case LPAREN_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case SIMPLE_SYMBOL:
        	        	case STRING_LITERAL:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case UNTERMINATED_STRING_LITERAL:
        	        		{
        	        			alt23=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt23)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:854:5: term[expr,expr2]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_term_in_smt25Command2025);
        	        	            term(ctx, expr, expr2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulesmt25CommandEx;
        	        	            }


        	        	            {

        	        	                      unsigned j = func_defs.size();
        	        	                      if( !flattenVarsList[j].empty() ){
        	        	                        expr = PARSER_STATE->mkHoApply( expr, flattenVarsList[j] );
        	        	                      }
        	        	                      func_defs.push_back( expr );
        	        	                      formals.push_back(bvs);
        	        	                      j++;
        	        	                      //set up the next scope
        	        	                      PARSER_STATE->popScope();
        	        	                      if( func_defs.size()<funcs.size() ){
        	        	                        bvs.clear();
        	        	                        PARSER_STATE->pushDefineFunRecScope( sortedVarNamesList[j], funcs[j],
        	        	                                                             flattenVarsList[j], bvs);
        	        	                      }
        	        	                    
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt23 >= 1 )
        	        		{
        	        		    goto loop23;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulesmt25CommandEx;
        	        	}
        	        	cnt23++;
        	            }
        	            loop23: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_smt25Command2045);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesmt25CommandEx;
        	        }


        	        {
        	             if( funcs.size()!=func_defs.size() ){
        	                    PARSER_STATE->parseError(std::string(
        	                        "Number of functions defined does not match number listed in "
        	                        "define-funs-rec"));
        	                  }
        	                  cmd->reset(new DefineFunctionRecCommand(funcs, formals, func_defs));
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesmt25CommandEx; /* Prevent compiler warnings */
    rulesmt25CommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end smt25Command */

/**
 * $ANTLR start extendedCommand
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:882:1: extendedCommand[std::unique_ptr<cvc5::parser::Command>* cmd] : ( DECLARE_CODATATYPE_TOK datatypeDefCommand[true, cmd] | DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd] | DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t] term[e, e2] | SIMPLIFY_TOK term[e,e2] | GET_QE_TOK term[e,e2] | GET_QE_DISJUNCT_TOK term[e,e2] | GET_ABDUCT_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )? | GET_ABDUCT_NEXT_TOK | GET_INTERPOL_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )? | GET_INTERPOL_NEXT_TOK | DECLARE_HEAP LPAREN_TOK sortSymbol[t] sortSymbol[s] RPAREN_TOK | DECLARE_POOL symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e, e2] )* RPAREN_TOK | BLOCK_MODEL_TOK KEYWORD | BLOCK_MODEL_VALUES_TOK ( LPAREN_TOK termList[terms,e] RPAREN_TOK |~ LPAREN_TOK ) );
 */
static void
extendedCommand(pSmt2Parser ctx, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::vector<cvc5::DatatypeDecl> dts;
      cvc5::Term e, e2;
      cvc5::Sort t, s;
      std::string name;
      std::vector<std::string> names;
      std::vector<cvc5::Term> terms;
      std::vector<cvc5::Sort> sorts;
      std::vector<std::pair<std::string, cvc5::Sort> > sortedVarNames;
      cvc5::Grammar* g = nullptr;

    pANTLR3_COMMON_TOKEN    KEYWORD6;

    /* Initialize rule variables
     */

    KEYWORD6       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:896:3: ( DECLARE_CODATATYPE_TOK datatypeDefCommand[true, cmd] | DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd] | DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t] term[e, e2] | SIMPLIFY_TOK term[e,e2] | GET_QE_TOK term[e,e2] | GET_QE_DISJUNCT_TOK term[e,e2] | GET_ABDUCT_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )? | GET_ABDUCT_NEXT_TOK | GET_INTERPOL_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )? | GET_INTERPOL_NEXT_TOK | DECLARE_HEAP LPAREN_TOK sortSymbol[t] sortSymbol[s] RPAREN_TOK | DECLARE_POOL symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e, e2] )* RPAREN_TOK | BLOCK_MODEL_TOK KEYWORD | BLOCK_MODEL_VALUES_TOK ( LPAREN_TOK termList[terms,e] RPAREN_TOK |~ LPAREN_TOK ) )

            ANTLR3_UINT32 alt29;

            alt29=14;

            switch ( LA(1) )
            {
            case DECLARE_CODATATYPE_TOK:
            	{
            		alt29=1;
            	}
                break;
            case DECLARE_CODATATYPES_TOK:
            	{
            		alt29=2;
            	}
                break;
            case DEFINE_CONST_TOK:
            	{
            		alt29=3;
            	}
                break;
            case SIMPLIFY_TOK:
            	{
            		alt29=4;
            	}
                break;
            case GET_QE_TOK:
            	{
            		alt29=5;
            	}
                break;
            case GET_QE_DISJUNCT_TOK:
            	{
            		alt29=6;
            	}
                break;
            case GET_ABDUCT_TOK:
            	{
            		alt29=7;
            	}
                break;
            case GET_ABDUCT_NEXT_TOK:
            	{
            		alt29=8;
            	}
                break;
            case GET_INTERPOL_TOK:
            	{
            		alt29=9;
            	}
                break;
            case GET_INTERPOL_NEXT_TOK:
            	{
            		alt29=10;
            	}
                break;
            case DECLARE_HEAP:
            	{
            		alt29=11;
            	}
                break;
            case DECLARE_POOL:
            	{
            		alt29=12;
            	}
                break;
            case BLOCK_MODEL_TOK:
            	{
            		alt29=13;
            	}
                break;
            case BLOCK_MODEL_VALUES_TOK:
            	{
            		alt29=14;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruleextendedCommandEx;

            }

            switch (alt29)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:896:5: DECLARE_CODATATYPE_TOK datatypeDefCommand[true, cmd]
        	    {
        	         MATCHT(DECLARE_CODATATYPE_TOK, &FOLLOW_DECLARE_CODATATYPE_TOK_in_extendedCommand2076);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypeDefCommand_in_extendedCommand2078);
        	        datatypeDefCommand(ctx, true, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:897:5: DECLARE_CODATATYPES_TOK datatypesDefCommand[true, cmd]
        	    {
        	         MATCHT(DECLARE_CODATATYPES_TOK, &FOLLOW_DECLARE_CODATATYPES_TOK_in_extendedCommand2085);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_datatypesDefCommand_in_extendedCommand2087);
        	        datatypesDefCommand(ctx, true, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:902:5: DEFINE_CONST_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] sortSymbol[t] term[e, e2]
        	    {
        	         MATCHT(DEFINE_CONST_TOK, &FOLLOW_DEFINE_CONST_TOK_in_extendedCommand2107);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2115);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_extendedCommand2128);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2135);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {

        	                  // declare the name down here (while parsing term, signature
        	                  // must not be extended with the name itself; no recursion
        	                  // permitted)
        	                  cmd->reset(new DefineFunctionCommand(name, t, e));
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:914:5: SIMPLIFY_TOK term[e,e2]
        	    {
        	         MATCHT(SIMPLIFY_TOK, &FOLLOW_SIMPLIFY_TOK_in_extendedCommand2149);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2157);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new SimplifyCommand(e)); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:917:5: GET_QE_TOK term[e,e2]
        	    {
        	         MATCHT(GET_QE_TOK, &FOLLOW_GET_QE_TOK_in_extendedCommand2170);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2178);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new GetQuantifierEliminationCommand(e, true)); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:920:5: GET_QE_DISJUNCT_TOK term[e,e2]
        	    {
        	         MATCHT(GET_QE_DISJUNCT_TOK, &FOLLOW_GET_QE_DISJUNCT_TOK_in_extendedCommand2191);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2199);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new GetQuantifierEliminationCommand(e, false)); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:923:5: GET_ABDUCT_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )?
        	    {
        	         MATCHT(GET_ABDUCT_TOK, &FOLLOW_GET_ABDUCT_TOK_in_extendedCommand2212);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2220);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2227);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:928:5: ( sygusGrammar[g, terms, name] )?
        	        {
        	            int alt25=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt25=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:929:7: sygusGrammar[g, terms, name]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sygusGrammar_in_extendedCommand2242);
        	        	        sygusGrammar(ctx, g, terms, name);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  cmd->reset(new GetAbductCommand(name, e, g));
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:934:5: GET_ABDUCT_NEXT_TOK
        	    {
        	         MATCHT(GET_ABDUCT_NEXT_TOK, &FOLLOW_GET_ABDUCT_NEXT_TOK_in_extendedCommand2262);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  cmd->reset(new GetAbductNextCommand);
        	                
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:938:5: GET_INTERPOL_TOK symbol[name,CHECK_UNDECLARED,SYM_VARIABLE] term[e,e2] ( sygusGrammar[g, terms, name] )?
        	    {
        	         MATCHT(GET_INTERPOL_TOK, &FOLLOW_GET_INTERPOL_TOK_in_extendedCommand2270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2278);
        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2285);
        	        term(ctx, e, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:943:5: ( sygusGrammar[g, terms, name] )?
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	                case LPAREN_TOK:
        	                	{
        	                		alt26=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:944:7: sygusGrammar[g, terms, name]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sygusGrammar_in_extendedCommand2300);
        	        	        sygusGrammar(ctx, g, terms, name);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                  cmd->reset(new GetInterpolantCommand(name, e, g));
        	                
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:949:5: GET_INTERPOL_NEXT_TOK
        	    {
        	         MATCHT(GET_INTERPOL_NEXT_TOK, &FOLLOW_GET_INTERPOL_NEXT_TOK_in_extendedCommand2320);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {

        	                  PARSER_STATE->checkThatLogicIsSet();
        	                  cmd->reset(new GetInterpolantNextCommand);
        	                
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:953:5: DECLARE_HEAP LPAREN_TOK sortSymbol[t] sortSymbol[s] RPAREN_TOK
        	    {
        	         MATCHT(DECLARE_HEAP, &FOLLOW_DECLARE_HEAP_in_extendedCommand2328);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2330);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_extendedCommand2336);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_extendedCommand2343);
        	        sortSymbol(ctx, s);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             cmd->reset(new DeclareHeapCommand(t, s)); 
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2356);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:958:5: DECLARE_POOL symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] LPAREN_TOK ( term[e, e2] )* RPAREN_TOK
        	    {
        	         MATCHT(DECLARE_POOL, &FOLLOW_DECLARE_POOL_in_extendedCommand2362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_extendedCommand2370);
        	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkUserSymbol(name); 
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_extendedCommand2383);
        	        sortSymbol(ctx, t);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2390);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:963:5: ( term[e, e2] )*

        	        for (;;)
        	        {
        	            int alt27=2;
        	            switch ( LA(1) )
        	            {
        	            case BINARY_LITERAL:
        	            case DECIMAL_LITERAL:
        	            case FIELD_LITERAL:
        	            case HEX_LITERAL:
        	            case INTEGER_LITERAL:
        	            case LPAREN_TOK:
        	            case QUOTED_SYMBOL:
        	            case SIMPLE_SYMBOL:
        	            case STRING_LITERAL:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;

        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:963:7: term[e, e2]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_term_in_extendedCommand2398);
        	        	        term(ctx, e, e2);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             terms.push_back( e ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop27;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop27: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2416);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             Trace("parser") << "declare pool: '" << name << "'" << std::endl;
        	                  cvc5::Term pool = SOLVER->declarePool(name, t, terms);
        	                  cmd->reset(new DeclarePoolCommand(name, pool, t, terms));
        	                
        	        }


        	    }
        	    break;
        	case 13:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:970:5: BLOCK_MODEL_TOK KEYWORD
        	    {
        	         MATCHT(BLOCK_MODEL_TOK, &FOLLOW_BLOCK_MODEL_TOK_in_extendedCommand2428);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        KEYWORD6 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_extendedCommand2430);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        {

        	                  modes::BlockModelsMode mode =
        	                    PARSER_STATE->getBlockModelsMode(
        	                      AntlrInput::tokenText(KEYWORD6).c_str() + 1);
        	                  cmd->reset(new BlockModelCommand(mode));
        	                
        	        }


        	    }
        	    break;
        	case 14:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:977:5: BLOCK_MODEL_VALUES_TOK ( LPAREN_TOK termList[terms,e] RPAREN_TOK |~ LPAREN_TOK )
        	    {
        	         MATCHT(BLOCK_MODEL_VALUES_TOK, &FOLLOW_BLOCK_MODEL_VALUES_TOK_in_extendedCommand2444);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextendedCommandEx;
        	        }


        	        {
        	             PARSER_STATE->checkThatLogicIsSet(); 
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:978:5: ( LPAREN_TOK termList[terms,e] RPAREN_TOK |~ LPAREN_TOK )
        	        {
        	            int alt28=2;
        	            switch ( LA(1) )
        	            {
        	            case LPAREN_TOK:
        	            	{
        	            		alt28=1;
        	            	}
        	                break;
        	            case ALPHA:
        	            case ASSERT_TOK:
        	            case ASSUME_TOK:
        	            case AS_TOK:
        	            case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_INST_LEVEL:
        	            case ATTRIBUTE_NAMED_TOK:
        	            case ATTRIBUTE_NO_PATTERN_TOK:
        	            case ATTRIBUTE_PATTERN_TOK:
        	            case ATTRIBUTE_POOL_TOK:
        	            case ATTRIBUTE_QUANTIFIER_ID_TOK:
        	            case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
        	            case ATTRIBUTE_TOK:
        	            case BINARY_LITERAL:
        	            case BLOCK_MODEL_TOK:
        	            case BLOCK_MODEL_VALUES_TOK:
        	            case CHAR_TOK:
        	            case CHECK_SAT_ASSUMING_TOK:
        	            case CHECK_SAT_TOK:
        	            case CHECK_SYNTH_NEXT_TOK:
        	            case CHECK_SYNTH_TOK:
        	            case COMMENT:
        	            case CONSTRAINT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_CODATATYPES_TOK:
        	            case DECLARE_CODATATYPE_TOK:
        	            case DECLARE_CONST_TOK:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_DATATYPE_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_HEAP:
        	            case DECLARE_POOL:
        	            case DECLARE_SORT_TOK:
        	            case DECLARE_VAR_TOK:
        	            case DEFINE_CONST_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case DIGIT:
        	            case ECHO_TOK:
        	            case EXISTS_TOK:
        	            case EXIT_TOK:
        	            case FIELD_LITERAL:
        	            case FMF_CARD_TOK:
        	            case FORALL_TOK:
        	            case GET_ABDUCT_NEXT_TOK:
        	            case GET_ABDUCT_TOK:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_DIFFICULTY_TOK:
        	            case GET_INFO_TOK:
        	            case GET_INTERPOL_NEXT_TOK:
        	            case GET_INTERPOL_TOK:
        	            case GET_LEARNED_LITERALS_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_QE_DISJUNCT_TOK:
        	            case GET_QE_TOK:
        	            case GET_UNSAT_ASSUMPTIONS_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case HEX_DIGIT:
        	            case HEX_LITERAL:
        	            case HO_LAMBDA_TOK:
        	            case INCLUDE_TOK:
        	            case INDEX_TOK:
        	            case INTEGER_LITERAL:
        	            case INV_CONSTRAINT_TOK:
        	            case KEYWORD:
        	            case LET_TOK:
        	            case MATCH_TOK:
        	            case NUMERAL:
        	            case PAR_TOK:
        	            case POP_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case RPAREN_TOK:
        	            case SET_COMPREHENSION_TOK:
        	            case SET_FEATURE_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STRING_LITERAL:
        	            case SYGUS_CONSTANT_TOK:
        	            case SYGUS_VARIABLE_TOK:
        	            case SYMBOL_CHAR:
        	            case SYMBOL_CHAR_NOUNDERSCORE_NOATTRIBUTE:
        	            case SYNTH_FUN_TOK:
        	            case SYNTH_INV_TOK:
        	            case TESTER_TOK:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            case UPDATE_TOK:
        	            case WHITESPACE:
        	            case 105:
        	            	{
        	            		alt28=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 28;
        	                EXCEPTION->state        = 0;


        	                goto ruleextendedCommandEx;

        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:978:7: LPAREN_TOK termList[terms,e] RPAREN_TOK
        	        	    {
        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_extendedCommand2454);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_termList_in_extendedCommand2456);
        	        	        termList(ctx, terms, e);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_extendedCommand2459);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             cmd->reset(new BlockModelValuesCommand(terms)); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:980:7: ~ LPAREN_TOK
        	        	    {
        	        	        if ( ((LA(1) >= ALPHA) && (LA(1) <= LET_TOK)) || ((LA(1) >= MATCH_TOK) && (LA(1) <= 105)) )
        	        	        {
        	        	            CONSUME();
        	        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        	        }
        	        	        else
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	        	            EXCEPTION->expectingSet = NULL;

        	        	            goto ruleextendedCommandEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->parseError("The block-model-value command expects a list "
        	        	                                             "of terms.  Perhaps you forgot a pair of "
        	        	                                             "parentheses?");
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextendedCommandEx; /* Prevent compiler warnings */
    ruleextendedCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end extendedCommand */

/**
 * $ANTLR start datatypeDefCommand
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:988:1: datatypeDefCommand[bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd] : symbol[name,CHECK_UNDECLARED,SYM_SORT] datatypesDef[isCo, dnames, arities, cmd] ;
 */
static void
datatypeDefCommand(pSmt2Parser ctx, bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::vector<cvc5::DatatypeDecl> dts;
      std::string name;
      std::vector<std::string> dnames;
      std::vector<int> arities;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:995:2: ( symbol[name,CHECK_UNDECLARED,SYM_SORT] datatypesDef[isCo, dnames, arities, cmd] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:995:4: symbol[name,CHECK_UNDECLARED,SYM_SORT] datatypesDef[isCo, dnames, arities, cmd]
        {
            {
                 PARSER_STATE->checkThatLogicIsSet(); 
            }


            FOLLOWPUSH(FOLLOW_symbol_in_datatypeDefCommand2511);
            symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefCommandEx;
            }


            {

                   dnames.push_back(name);
                   arities.push_back(-1);
                 
            }


            FOLLOWPUSH(FOLLOW_datatypesDef_in_datatypeDefCommand2518);
            datatypesDef(ctx, isCo, dnames, arities, cmd);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefCommandEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypeDefCommandEx; /* Prevent compiler warnings */
    ruledatatypeDefCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypeDefCommand */

/**
 * $ANTLR start datatypesDefCommand
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1004:1: datatypesDefCommand[bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd] : LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL RPAREN_TOK )* RPAREN_TOK LPAREN_TOK datatypesDef[isCo, dnames, arities, cmd] RPAREN_TOK ;
 */
static void
datatypesDefCommand(pSmt2Parser ctx, bool isCo, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::vector<cvc5::DatatypeDecl> dts;
      std::string name;
      std::vector<std::string> dnames;
      std::vector<int> arities;

    pANTLR3_COMMON_TOKEN    n;

    /* Initialize rule variables
     */

    n       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1011:3: ( LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL RPAREN_TOK )* RPAREN_TOK LPAREN_TOK datatypesDef[isCo, dnames, arities, cmd] RPAREN_TOK )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1011:5: LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL RPAREN_TOK )* RPAREN_TOK LPAREN_TOK datatypesDef[isCo, dnames, arities, cmd] RPAREN_TOK
        {
            {
                 PARSER_STATE->checkThatLogicIsSet(); 
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2541);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1013:3: ( LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL RPAREN_TOK )*

            for (;;)
            {
                int alt30=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt30=1;
                	}
                    break;

                }

                switch (alt30)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1013:5: LPAREN_TOK symbol[name,CHECK_UNDECLARED,SYM_SORT] n= INTEGER_LITERAL RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2549);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypesDefCommandEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_symbol_in_datatypesDefCommand2551);
            	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypesDefCommandEx;
            	        }


            	        n = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_datatypesDefCommand2556);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypesDefCommandEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2558);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledatatypesDefCommandEx;
            	        }


            	        {
            	             unsigned arity = AntlrInput::tokenToUnsigned(n);
            	                  Trace("parser-dt") << "Datatype : " << name << ", arity = " << arity << std::endl;
            	                  dnames.push_back(name);
            	                  arities.push_back( static_cast<int>(arity) );
            	                
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2573);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDefCommand2577);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


            FOLLOWPUSH(FOLLOW_datatypesDef_in_datatypesDefCommand2581);
            datatypesDef(ctx, isCo, dnames, arities, cmd);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDefCommand2586);
            if  (HASEXCEPTION())
            {
                goto ruledatatypesDefCommandEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypesDefCommandEx; /* Prevent compiler warnings */
    ruledatatypesDefCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypesDefCommand */

/**
 * $ANTLR start datatypesDef
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1034:1: datatypesDef[bool isCo,\n const std::vector<std::string>& dnames,\n const std::vector<int>& arities,\n std::unique_ptr<cvc5::parser::Command>* cmd] : ( LPAREN_TOK ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ ) RPAREN_TOK )+ ;
 */
static void
datatypesDef(pSmt2Parser ctx, bool isCo, const std::vector<std::string>& dnames, const std::vector<int>& arities, std::unique_ptr<cvc5::parser::Command>* cmd)
{

      std::vector<cvc5::DatatypeDecl> dts;
      std::string name;
      std::vector<cvc5::Sort> params;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1043:3: ( ( LPAREN_TOK ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ ) RPAREN_TOK )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1043:5: ( LPAREN_TOK ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ ) RPAREN_TOK )+
        {
            {
                 PARSER_STATE->pushScope();
                      // Declare the datatypes that are currently being defined as unresolved
                      // types. If we do not know the arity of the datatype yet, we wait to
                      // define it until parsing the preamble of its body, which may optionally
                      // involve `par`. This is limited to the case of single datatypes defined
                      // via declare-datatype, and hence no datatype body is parsed without
                      // having all types declared. This ensures we can parse datatypes with
                      // nested recursion, e.g. datatypes D having a subfield type
                      // (Array Int D).
                      for (unsigned i=0, dsize=dnames.size(); i<dsize; i++)
                      {
                        if( arities[i]<0 )
                        {
                          // do not know the arity yet
                          continue;
                        }
                        unsigned arity = static_cast<unsigned>(arities[i]);
                        PARSER_STATE->mkUnresolvedType(dnames[i], arity);
                      }
                    
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1063:5: ( LPAREN_TOK ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ ) RPAREN_TOK )+
            {
                int cnt35=0;

                for (;;)
                {
                    int alt35=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            		{
            			alt35=1;
            		}
            	    break;

            	}

            	switch (alt35)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1063:7: LPAREN_TOK ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ ) RPAREN_TOK
            	        {
            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDef2615);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypesDefEx;
            	            }


            	            {

            	                      params.clear();
            	                      Trace("parser-dt") << "Processing datatype #" << dts.size() << std::endl;
            	                      if( dts.size()>=dnames.size() ){
            	                        PARSER_STATE->parseError("Too many datatypes defined in this block.");
            	                      }
            	                    
            	            }


            	            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1070:5: ( PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK | ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ )
            	            {
            	                int alt34=2;
            	                switch ( LA(1) )
            	                {
            	                case PAR_TOK:
            	                	{
            	                		alt34=1;
            	                	}
            	                    break;
            	                case LPAREN_TOK:
            	                	{
            	                		alt34=2;
            	                	}
            	                    break;

            	                default:
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                    EXCEPTION->message      = (void *)"";
            	                    EXCEPTION->decisionNum  = 34;
            	                    EXCEPTION->state        = 0;


            	                    goto ruledatatypesDefEx;

            	                }

            	                switch (alt34)
            	                {
            	            	case 1:
            	            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1070:7: PAR_TOK LPAREN_TOK ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )* RPAREN_TOK LPAREN_TOK ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+ RPAREN_TOK
            	            	    {
            	            	         MATCHT(PAR_TOK, &FOLLOW_PAR_TOK_in_datatypesDef2625);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruledatatypesDefEx;
            	            	        }


            	            	        {
            	            	             PARSER_STATE->pushScope(); 
            	            	        }


            	            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDef2629);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruledatatypesDefEx;
            	            	        }


            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1071:7: ( symbol[name,CHECK_UNDECLARED,SYM_SORT] )*

            	            	        for (;;)
            	            	        {
            	            	            int alt31=2;
            	            	            switch ( LA(1) )
            	            	            {
            	            	            case QUOTED_SYMBOL:
            	            	            case SIMPLE_SYMBOL:
            	            	            case UNTERMINATED_QUOTED_SYMBOL:
            	            	            	{
            	            	            		alt31=1;
            	            	            	}
            	            	                break;

            	            	            }

            	            	            switch (alt31)
            	            	            {
            	            	        	case 1:
            	            	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1071:9: symbol[name,CHECK_UNDECLARED,SYM_SORT]
            	            	        	    {
            	            	        	        FOLLOWPUSH(FOLLOW_symbol_in_datatypesDef2639);
            	            	        	        symbol(ctx, name, CHECK_UNDECLARED, SYM_SORT);

            	            	        	        FOLLOWPOP();
            	            	        	        if  (HASEXCEPTION())
            	            	        	        {
            	            	        	            goto ruledatatypesDefEx;
            	            	        	        }


            	            	        	        {

            	            	        	                      params.push_back( PARSER_STATE->mkSort(name)); 
            	            	        	        }


            	            	        	    }
            	            	        	    break;

            	            	        	default:
            	            	        	    goto loop31;	/* break out of the loop */
            	            	        	    break;
            	            	            }
            	            	        }
            	            	        loop31: ; /* Jump out to here if this rule does not match */


            	            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDef2667);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruledatatypesDefEx;
            	            	        }


            	            	        {

            	            	                    // if the arity was fixed by prelude and is not equal to the number of parameters
            	            	                    if( arities[dts.size()]>=0 && static_cast<int>(params.size())!=arities[dts.size()] ){
            	            	                      PARSER_STATE->parseError("Wrong number of parameters for datatype.");
            	            	                    }
            	            	                    if (arities[dts.size()]<0)
            	            	                    {
            	            	                      // now declare it as an unresolved type
            	            	                      PARSER_STATE->mkUnresolvedType(dnames[dts.size()], params.size());
            	            	                    }
            	            	                    Trace("parser-dt") << params.size() << " parameters for " << dnames[dts.size()] << std::endl;
            	            	                    dts.push_back(SOLVER->mkDatatypeDecl(dnames[dts.size()], params, isCo));
            	            	                  
            	            	        }


            	            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDef2677);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruledatatypesDefEx;
            	            	        }


            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1089:7: ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+
            	            	        {
            	            	            int cnt32=0;

            	            	            for (;;)
            	            	            {
            	            	                int alt32=2;
            	            	        	switch ( LA(1) )
            	            	        	{
            	            	        	case LPAREN_TOK:
            	            	        		{
            	            	        			alt32=1;
            	            	        		}
            	            	        	    break;

            	            	        	}

            	            	        	switch (alt32)
            	            	        	{
            	            	        	    case 1:
            	            	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1089:9: LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK
            	            	        	        {
            	            	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDef2687);
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	            FOLLOWPUSH(FOLLOW_constructorDef_in_datatypesDef2689);
            	            	        	            constructorDef(ctx, dts.back());

            	            	        	            FOLLOWPOP();
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDef2692);
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	        }
            	            	        	        break;

            	            	        	    default:

            	            	        		if ( cnt32 >= 1 )
            	            	        		{
            	            	        		    goto loop32;
            	            	        		}
            	            	        		/* mismatchedSetEx()
            	            	        		 */
            	            	        		CONSTRUCTEX();
            	            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            	        		goto ruledatatypesDefEx;
            	            	        	}
            	            	        	cnt32++;
            	            	            }
            	            	            loop32: ;	/* Jump to here if this rule does not match */
            	            	        }

            	            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDef2703);
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruledatatypesDefEx;
            	            	        }


            	            	        {
            	            	             PARSER_STATE->popScope(); 
            	            	        }


            	            	    }
            	            	    break;
            	            	case 2:
            	            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1091:7: ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+
            	            	    {
            	            	        {
            	            	             // if the arity was fixed by prelude and is not equal to 0
            	            	                    if( arities[dts.size()]>0 ){
            	            	                      PARSER_STATE->parseError("No parameters given for datatype.");
            	            	                    }
            	            	                    else if (arities[dts.size()]<0)
            	            	                    {
            	            	                      // now declare it as an unresolved type
            	            	                      PARSER_STATE->mkUnresolvedType(dnames[dts.size()], 0);
            	            	                    }
            	            	                    Trace("parser-dt") << params.size() << " parameters for " << dnames[dts.size()] << std::endl;
            	            	                    dts.push_back(SOLVER->mkDatatypeDecl(dnames[dts.size()],
            	            	                                                         params,
            	            	                                                         isCo));
            	            	                  
            	            	        }


            	            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1105:7: ( LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK )+
            	            	        {
            	            	            int cnt33=0;

            	            	            for (;;)
            	            	            {
            	            	                int alt33=2;
            	            	        	switch ( LA(1) )
            	            	        	{
            	            	        	case LPAREN_TOK:
            	            	        		{
            	            	        			alt33=1;
            	            	        		}
            	            	        	    break;

            	            	        	}

            	            	        	switch (alt33)
            	            	        	{
            	            	        	    case 1:
            	            	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1105:9: LPAREN_TOK constructorDef[dts.back()] RPAREN_TOK
            	            	        	        {
            	            	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypesDef2723);
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	            FOLLOWPUSH(FOLLOW_constructorDef_in_datatypesDef2725);
            	            	        	            constructorDef(ctx, dts.back());

            	            	        	            FOLLOWPOP();
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDef2728);
            	            	        	            if  (HASEXCEPTION())
            	            	        	            {
            	            	        	                goto ruledatatypesDefEx;
            	            	        	            }


            	            	        	        }
            	            	        	        break;

            	            	        	    default:

            	            	        		if ( cnt33 >= 1 )
            	            	        		{
            	            	        		    goto loop33;
            	            	        		}
            	            	        		/* mismatchedSetEx()
            	            	        		 */
            	            	        		CONSTRUCTEX();
            	            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            	        		goto ruledatatypesDefEx;
            	            	        	}
            	            	        	cnt33++;
            	            	            }
            	            	            loop33: ;	/* Jump to here if this rule does not match */
            	            	        }

            	            	    }
            	            	    break;

            	                }
            	            }

            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypesDef2743);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypesDefEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt35 >= 1 )
            		{
            		    goto loop35;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledatatypesDefEx;
            	}
            	cnt35++;
                }
                loop35: ;	/* Jump to here if this rule does not match */
            }

            {

                    if (dts.size() != dnames.size())
                    {
                      PARSER_STATE->parseError("Wrong number of datatypes provided.");
                    }
                    PARSER_STATE->popScope();
                    cmd->reset(new DatatypeDeclarationCommand(
                        PARSER_STATE->bindMutualDatatypeTypes(dts, true)));
                  
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypesDefEx; /* Prevent compiler warnings */
    ruledatatypesDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypesDef */

/**
 * $ANTLR start simpleSymbolicExprNoKeyword
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1120:1: simpleSymbolicExprNoKeyword[std::string& s] : ( INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | FIELD_LITERAL | symbol[s, CHECK_NONE, SYM_VERBATIM] | str[s, false] |tok= ( ASSERT_TOK | CHECK_SAT_TOK | CHECK_SAT_ASSUMING_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_ASSUMPTIONS_TOK | GET_UNSAT_CORE_TOK | GET_DIFFICULTY_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | SIMPLIFY_TOK ) );
 */
static void
simpleSymbolicExprNoKeyword(pSmt2Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    tok;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL7;
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL8;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL9;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL10;
    pANTLR3_COMMON_TOKEN    FIELD_LITERAL11;

    /* Initialize rule variables
     */

    tok       = NULL;
    INTEGER_LITERAL7       = NULL;
    DECIMAL_LITERAL8       = NULL;
    HEX_LITERAL9       = NULL;
    BINARY_LITERAL10       = NULL;
    FIELD_LITERAL11       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1121:3: ( INTEGER_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | BINARY_LITERAL | FIELD_LITERAL | symbol[s, CHECK_NONE, SYM_VERBATIM] | str[s, false] |tok= ( ASSERT_TOK | CHECK_SAT_TOK | CHECK_SAT_ASSUMING_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_ASSUMPTIONS_TOK | GET_UNSAT_CORE_TOK | GET_DIFFICULTY_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | SIMPLIFY_TOK ) )

            ANTLR3_UINT32 alt36;

            alt36=8;

            switch ( LA(1) )
            {
            case INTEGER_LITERAL:
            	{
            		alt36=1;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt36=2;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt36=3;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt36=4;
            	}
                break;
            case FIELD_LITERAL:
            	{
            		alt36=5;
            	}
                break;
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt36=6;
            	}
                break;
            case STRING_LITERAL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt36=7;
            	}
                break;
            case ASSERT_TOK:
            case CHECK_SAT_ASSUMING_TOK:
            case CHECK_SAT_TOK:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_SORT_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_DIFFICULTY_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_ASSUMPTIONS_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case POP_TOK:
            case PUSH_TOK:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLIFY_TOK:
            	{
            		alt36=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 36;
                EXCEPTION->state        = 0;


                goto rulesimpleSymbolicExprNoKeywordEx;

            }

            switch (alt36)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1121:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL7 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_simpleSymbolicExprNoKeyword2768);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(INTEGER_LITERAL7); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1123:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL8 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_simpleSymbolicExprNoKeyword2780);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(DECIMAL_LITERAL8); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1125:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL9 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_simpleSymbolicExprNoKeyword2792);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(HEX_LITERAL9); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1127:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL10 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_simpleSymbolicExprNoKeyword2804);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(BINARY_LITERAL10); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1129:5: FIELD_LITERAL
        	    {
        	        FIELD_LITERAL11 = (pANTLR3_COMMON_TOKEN) MATCHT(FIELD_LITERAL, &FOLLOW_FIELD_LITERAL_in_simpleSymbolicExprNoKeyword2816);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(FIELD_LITERAL11); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1131:5: symbol[s, CHECK_NONE, SYM_VERBATIM]
        	    {
        	        FOLLOWPUSH(FOLLOW_symbol_in_simpleSymbolicExprNoKeyword2828);
        	        symbol(ctx, s, CHECK_NONE, SYM_VERBATIM);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1132:5: str[s, false]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_simpleSymbolicExprNoKeyword2835);
        	        str(ctx, s, false);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1133:5: tok= ( ASSERT_TOK | CHECK_SAT_TOK | CHECK_SAT_ASSUMING_TOK | DECLARE_FUN_TOK | DECLARE_SORT_TOK | DEFINE_FUN_TOK | DEFINE_FUN_REC_TOK | DEFINE_FUNS_REC_TOK | DEFINE_SORT_TOK | GET_VALUE_TOK | GET_ASSIGNMENT_TOK | GET_ASSERTIONS_TOK | GET_PROOF_TOK | GET_UNSAT_ASSUMPTIONS_TOK | GET_UNSAT_CORE_TOK | GET_DIFFICULTY_TOK | EXIT_TOK | RESET_TOK | RESET_ASSERTIONS_TOK | SET_LOGIC_TOK | SET_INFO_TOK | GET_INFO_TOK | SET_OPTION_TOK | GET_OPTION_TOK | PUSH_TOK | POP_TOK | DECLARE_DATATYPES_TOK | GET_MODEL_TOK | ECHO_TOK | SIMPLIFY_TOK )
        	    {
        	        tok=(pANTLR3_COMMON_TOKEN)LT(1);

        	        if ( LA(1) == ASSERT_TOK || ((LA(1) >= CHECK_SAT_ASSUMING_TOK) && (LA(1) <= CHECK_SAT_TOK)) || LA(1) == DECLARE_DATATYPES_TOK || LA(1) == DECLARE_FUN_TOK || LA(1) == DECLARE_SORT_TOK || ((LA(1) >= DEFINE_FUNS_REC_TOK) && (LA(1) <= DEFINE_SORT_TOK)) || LA(1) == ECHO_TOK || LA(1) == EXIT_TOK || ((LA(1) >= GET_ASSERTIONS_TOK) && (LA(1) <= GET_INFO_TOK)) || ((LA(1) >= GET_MODEL_TOK) && (LA(1) <= GET_PROOF_TOK)) || ((LA(1) >= GET_UNSAT_ASSUMPTIONS_TOK) && (LA(1) <= GET_VALUE_TOK)) || ((LA(1) >= POP_TOK) && (LA(1) <= PUSH_TOK)) || ((LA(1) >= RESET_ASSERTIONS_TOK) && (LA(1) <= RESET_TOK)) || ((LA(1) >= SET_INFO_TOK) && (LA(1) <= SET_OPTION_TOK)) || LA(1) == SIMPLIFY_TOK )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            goto rulesimpleSymbolicExprNoKeywordEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(tok); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleSymbolicExprNoKeywordEx; /* Prevent compiler warnings */
    rulesimpleSymbolicExprNoKeywordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleSymbolicExprNoKeyword */

/**
 * $ANTLR start keyword
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1145:1: keyword[std::string& s] : KEYWORD ;
 */
static void
keyword(pSmt2Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    KEYWORD12;

    /* Initialize rule variables
     */

    KEYWORD12       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1146:3: ( KEYWORD )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1146:5: KEYWORD
        {
            KEYWORD12 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_keyword3046);
            if  (HASEXCEPTION())
            {
                goto rulekeywordEx;
            }


            {
                 s = AntlrInput::tokenText(KEYWORD12); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeywordEx; /* Prevent compiler warnings */
    rulekeywordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyword */

/**
 * $ANTLR start simpleSymbolicExpr
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1150:1: simpleSymbolicExpr[std::string& s] : ( simpleSymbolicExprNoKeyword[s] | KEYWORD );
 */
static void
simpleSymbolicExpr(pSmt2Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    KEYWORD13;

    /* Initialize rule variables
     */

    KEYWORD13       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1151:3: ( simpleSymbolicExprNoKeyword[s] | KEYWORD )

            ANTLR3_UINT32 alt37;

            alt37=2;

            switch ( LA(1) )
            {
            case ASSERT_TOK:
            case BINARY_LITERAL:
            case CHECK_SAT_ASSUMING_TOK:
            case CHECK_SAT_TOK:
            case DECIMAL_LITERAL:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_SORT_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case FIELD_LITERAL:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_DIFFICULTY_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_ASSUMPTIONS_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case POP_TOK:
            case PUSH_TOK:
            case QUOTED_SYMBOL:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            case STRING_LITERAL:
            case UNTERMINATED_QUOTED_SYMBOL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt37=1;
            	}
                break;
            case KEYWORD:
            	{
            		alt37=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto rulesimpleSymbolicExprEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1151:5: simpleSymbolicExprNoKeyword[s]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExprNoKeyword_in_simpleSymbolicExpr3066);
        	        simpleSymbolicExprNoKeyword(ctx, s);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1152:5: KEYWORD
        	    {
        	        KEYWORD13 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_simpleSymbolicExpr3073);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesimpleSymbolicExprEx;
        	        }


        	        {
        	             s = AntlrInput::tokenText(KEYWORD13); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesimpleSymbolicExprEx; /* Prevent compiler warnings */
    rulesimpleSymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simpleSymbolicExpr */

/**
 * $ANTLR start symbolicExpr
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1155:1: symbolicExpr[cvc5::Term& sexpr] : ( simpleSymbolicExpr[s] | LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK );
 */
static void
symbolicExpr(pSmt2Parser ctx, cvc5::Term& sexpr)
{

      std::string s;
      std::vector<cvc5::Term> children;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1160:3: ( simpleSymbolicExpr[s] | LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK )

            ANTLR3_UINT32 alt39;

            alt39=2;

            switch ( LA(1) )
            {
            case ASSERT_TOK:
            case BINARY_LITERAL:
            case CHECK_SAT_ASSUMING_TOK:
            case CHECK_SAT_TOK:
            case DECIMAL_LITERAL:
            case DECLARE_DATATYPES_TOK:
            case DECLARE_FUN_TOK:
            case DECLARE_SORT_TOK:
            case DEFINE_FUNS_REC_TOK:
            case DEFINE_FUN_REC_TOK:
            case DEFINE_FUN_TOK:
            case DEFINE_SORT_TOK:
            case ECHO_TOK:
            case EXIT_TOK:
            case FIELD_LITERAL:
            case GET_ASSERTIONS_TOK:
            case GET_ASSIGNMENT_TOK:
            case GET_DIFFICULTY_TOK:
            case GET_INFO_TOK:
            case GET_MODEL_TOK:
            case GET_OPTION_TOK:
            case GET_PROOF_TOK:
            case GET_UNSAT_ASSUMPTIONS_TOK:
            case GET_UNSAT_CORE_TOK:
            case GET_VALUE_TOK:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case KEYWORD:
            case POP_TOK:
            case PUSH_TOK:
            case QUOTED_SYMBOL:
            case RESET_ASSERTIONS_TOK:
            case RESET_TOK:
            case SET_INFO_TOK:
            case SET_LOGIC_TOK:
            case SET_OPTION_TOK:
            case SIMPLE_SYMBOL:
            case SIMPLIFY_TOK:
            case STRING_LITERAL:
            case UNTERMINATED_QUOTED_SYMBOL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt39=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt39=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulesymbolicExprEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1160:5: simpleSymbolicExpr[s]
        	    {
        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExpr_in_symbolicExpr3094);
        	        simpleSymbolicExpr(ctx, s);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	        {
        	             sexpr = SOLVER->mkVar(SOLVER->getBooleanSort(), s); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1162:5: LPAREN_TOK ( symbolicExpr[sexpr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_symbolicExpr3107);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1163:5: ( symbolicExpr[sexpr] )*

        	        for (;;)
        	        {
        	            int alt38=2;
        	            switch ( LA(1) )
        	            {
        	            case ASSERT_TOK:
        	            case BINARY_LITERAL:
        	            case CHECK_SAT_ASSUMING_TOK:
        	            case CHECK_SAT_TOK:
        	            case DECIMAL_LITERAL:
        	            case DECLARE_DATATYPES_TOK:
        	            case DECLARE_FUN_TOK:
        	            case DECLARE_SORT_TOK:
        	            case DEFINE_FUNS_REC_TOK:
        	            case DEFINE_FUN_REC_TOK:
        	            case DEFINE_FUN_TOK:
        	            case DEFINE_SORT_TOK:
        	            case ECHO_TOK:
        	            case EXIT_TOK:
        	            case FIELD_LITERAL:
        	            case GET_ASSERTIONS_TOK:
        	            case GET_ASSIGNMENT_TOK:
        	            case GET_DIFFICULTY_TOK:
        	            case GET_INFO_TOK:
        	            case GET_MODEL_TOK:
        	            case GET_OPTION_TOK:
        	            case GET_PROOF_TOK:
        	            case GET_UNSAT_ASSUMPTIONS_TOK:
        	            case GET_UNSAT_CORE_TOK:
        	            case GET_VALUE_TOK:
        	            case HEX_LITERAL:
        	            case INTEGER_LITERAL:
        	            case KEYWORD:
        	            case LPAREN_TOK:
        	            case POP_TOK:
        	            case PUSH_TOK:
        	            case QUOTED_SYMBOL:
        	            case RESET_ASSERTIONS_TOK:
        	            case RESET_TOK:
        	            case SET_INFO_TOK:
        	            case SET_LOGIC_TOK:
        	            case SET_OPTION_TOK:
        	            case SIMPLE_SYMBOL:
        	            case SIMPLIFY_TOK:
        	            case STRING_LITERAL:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            case UNTERMINATED_STRING_LITERAL:
        	            	{
        	            		alt38=1;
        	            	}
        	                break;

        	            }

        	            switch (alt38)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1163:7: symbolicExpr[sexpr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_symbolicExpr_in_symbolicExpr3115);
        	        	        symbolicExpr(ctx, sexpr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolicExprEx;
        	        	        }


        	        	        {
        	        	             children.push_back(sexpr); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop38;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop38: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_symbolicExpr3123);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolicExprEx;
        	        }


        	        {
        	             sexpr = SOLVER->mkTerm(cvc5::SEXPR, children); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesymbolicExprEx; /* Prevent compiler warnings */
    rulesymbolicExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbolicExpr */

/**
 * $ANTLR start term
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1171:1: term[cvc5::Term& expr, cvc5::Term& expr2] : ( termNonVariable[expr, expr2] | qualIdentifier[p] );
 */
static void
term(pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& expr2)
{
    /* Initialize rule variables
     */


      cvc5::Kind kind = cvc5::NULL_TERM;
      cvc5::Term f;
      std::string name;
      cvc5::Sort type;
      ParseOp p;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1179:3: ( termNonVariable[expr, expr2] | qualIdentifier[p] )

            ANTLR3_UINT32 alt40;

            alt40=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case ATTRIBUTE_TOK:
            		case EXISTS_TOK:
            		case FORALL_TOK:
            		case HO_LAMBDA_TOK:
            		case LET_TOK:
            		case LPAREN_TOK:
            		case MATCH_TOK:
            		case QUOTED_SYMBOL:
            		case SET_COMPREHENSION_TOK:
            		case SIMPLE_SYMBOL:
            		case UNTERMINATED_QUOTED_SYMBOL:
            			{
            				alt40=1;
            			}
            		    break;
            		case INDEX_TOK:
            			{
            				alt40=1;
            			}
            		    break;
            		case AS_TOK:
            			{
            				alt40=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 40;
            		    EXCEPTION->state        = 1;


            		    goto ruletermEx;

            		}

            	}
                break;
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FIELD_LITERAL:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case STRING_LITERAL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt40=1;
            	}
                break;
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt40=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 40;
                EXCEPTION->state        = 0;


                goto ruletermEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1179:3: termNonVariable[expr, expr2]
        	    {
        	        FOLLOWPUSH(FOLLOW_termNonVariable_in_term3148);
        	        termNonVariable(ctx, expr, expr2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1183:5: qualIdentifier[p]
        	    {
        	        FOLLOWPUSH(FOLLOW_qualIdentifier_in_term3160);
        	        qualIdentifier(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }


        	        {

        	                  expr = PARSER_STATE->parseOpToExpr(p);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start termNonVariable
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1194:1: termNonVariable[cvc5::Term& expr, cvc5::Term& expr2] : ( LPAREN_TOK quantOp[kind] boundVarList[bvl] term[f, f2] RPAREN_TOK | LPAREN_TOK SET_COMPREHENSION_TOK boundVarList[bvl] term[f, f2] term[f, f2] RPAREN_TOK | LPAREN_TOK qualIdentifier[p] termList[args,expr] RPAREN_TOK | LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[expr, f2] RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK | LPAREN_TOK MATCH_TOK term[expr, f2] LPAREN_TOK ( LPAREN_TOK LPAREN_TOK term[f, f2] ( symbol[name,CHECK_NONE,SYM_VARIABLE] )* RPAREN_TOK term[f3, f2] RPAREN_TOK | LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[f3, f2] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK | LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr] )+ RPAREN_TOK | LPAREN_TOK HO_LAMBDA_TOK boundVarList[bvl] term[f, f2] RPAREN_TOK | termAtomic[atomTerm] );
 */
static void
termNonVariable(pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& expr2)
{
    /* Initialize rule variables
     */


      Trace("parser") << "term: " << AntlrInput::tokenText(LT(1)) << std::endl;
      cvc5::Kind kind = cvc5::NULL_TERM;
      std::string name;
      std::vector<cvc5::Term> args;
      std::vector< std::pair<std::string, cvc5::Sort> > sortedVarNames;
      cvc5::Term bvl;
      cvc5::Term f, f2, f3;
      std::string attr;
      cvc5::Term attexpr;
      std::vector<cvc5::Term> patexprs;
      std::vector<cvc5::Term> matchcases;
      std::unordered_set<std::string> names;
      std::vector< std::pair<std::string, cvc5::Term> > binders;
      cvc5::Sort type;
      cvc5::Sort type2;
      cvc5::Term atomTerm;
      ParseOp p;
      std::vector<cvc5::Sort> argTypes;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1215:3: ( LPAREN_TOK quantOp[kind] boundVarList[bvl] term[f, f2] RPAREN_TOK | LPAREN_TOK SET_COMPREHENSION_TOK boundVarList[bvl] term[f, f2] term[f, f2] RPAREN_TOK | LPAREN_TOK qualIdentifier[p] termList[args,expr] RPAREN_TOK | LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[expr, f2] RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK | LPAREN_TOK MATCH_TOK term[expr, f2] LPAREN_TOK ( LPAREN_TOK LPAREN_TOK term[f, f2] ( symbol[name,CHECK_NONE,SYM_VARIABLE] )* RPAREN_TOK term[f3, f2] RPAREN_TOK | LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[f3, f2] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK | LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr] )+ RPAREN_TOK | LPAREN_TOK HO_LAMBDA_TOK boundVarList[bvl] term[f, f2] RPAREN_TOK | termAtomic[atomTerm] )

            ANTLR3_UINT32 alt45;

            alt45=8;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case SET_COMPREHENSION_TOK:
            			{
            				alt45=2;
            			}
            		    break;
            		case LET_TOK:
            			{
            				alt45=4;
            			}
            		    break;
            		case MATCH_TOK:
            			{
            				alt45=5;
            			}
            		    break;
            		case ATTRIBUTE_TOK:
            			{
            				alt45=6;
            			}
            		    break;
            		case HO_LAMBDA_TOK:
            			{
            				alt45=7;
            			}
            		    break;
            		case INDEX_TOK:
            			{
            				alt45=8;
            			}
            		    break;
            		case EXISTS_TOK:
            		case FORALL_TOK:
            			{
            				alt45=1;
            			}
            		    break;
            		case LPAREN_TOK:
            		case QUOTED_SYMBOL:
            		case SIMPLE_SYMBOL:
            		case UNTERMINATED_QUOTED_SYMBOL:
            			{
            				alt45=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 45;
            		    EXCEPTION->state        = 1;


            		    goto ruletermNonVariableEx;

            		}

            	}
                break;
            case BINARY_LITERAL:
            case DECIMAL_LITERAL:
            case FIELD_LITERAL:
            case HEX_LITERAL:
            case INTEGER_LITERAL:
            case STRING_LITERAL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt45=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 45;
                EXCEPTION->state        = 0;


                goto ruletermNonVariableEx;

            }

            switch (alt45)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1215:5: LPAREN_TOK quantOp[kind] boundVarList[bvl] term[f, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3188);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_quantOp_in_termNonVariable3190);
        	        quantOp(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  PARSER_STATE->pushScope();
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_boundVarList_in_termNonVariable3203);
        	        boundVarList(ctx, bvl);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3210);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3213);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  args.push_back(bvl);

        	                  PARSER_STATE->popScope();
        	                  args.push_back(f);
        	                  if(! f2.isNull()){
        	                    args.push_back(f2);
        	                  }
        	                  expr = MK_TERM(kind, args);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1231:5: LPAREN_TOK SET_COMPREHENSION_TOK boundVarList[bvl] term[f, f2] term[f, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3225);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(SET_COMPREHENSION_TOK, &FOLLOW_SET_COMPREHENSION_TOK_in_termNonVariable3227);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_boundVarList_in_termNonVariable3239);
        	        boundVarList(ctx, bvl);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  args.push_back(bvl);
        	                
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3252);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             args.push_back(f); 
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3261);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  args.push_back(f);
        	                  expr = MK_TERM(cvc5::SET_COMPREHENSION, args);
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1243:5: LPAREN_TOK qualIdentifier[p] termList[args,expr] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3276);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_qualIdentifier_in_termNonVariable3278);
        	        qualIdentifier(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_termList_in_termNonVariable3285);
        	        termList(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3288);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  expr = PARSER_STATE->applyParseOp(p, args);
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1249:5: LPAREN_TOK LET_TOK LPAREN_TOK ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[expr, f2] RPAREN_TOK )+ RPAREN_TOK term[expr, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3306);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_termNonVariable3314);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1252:7: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[expr, f2] RPAREN_TOK )+
        	        {
        	            int cnt41=0;

        	            for (;;)
        	            {
        	                int alt41=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt41=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt41)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1252:9: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[expr, f2] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3334);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_termNonVariable3336);
        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_term_in_termNonVariable3347);
        	        	            term(ctx, expr, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3358);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {
        	        	                 if(names.count(name) == 1) {
        	        	                            std::stringstream ss;
        	        	                            ss << "warning: symbol `" << name << "' bound multiple times by let;"
        	        	                               << " the last binding will be used, shadowing earlier ones";
        	        	                            PARSER_STATE->warning(ss.str());
        	        	                          } else {
        	        	                            names.insert(name);
        	        	                          }
        	        	                          binders.push_back(std::make_pair(name, expr)); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt41 >= 1 )
        	        		{
        	        		    goto loop41;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermNonVariableEx;
        	        	}
        	        	cnt41++;
        	            }
        	            loop41: ;	/* Jump to here if this rule does not match */
        	        }

        	        {
        	             // now implement these bindings
        	                  for (const std::pair<std::string, cvc5::Term>& binder : binders)
        	                  {
        	                    {
        	                      PARSER_STATE->defineVar(binder.first, binder.second);
        	                    }
        	                  }
        	                
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3401);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3407);
        	        term(ctx, expr, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3414);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1279:5: LPAREN_TOK MATCH_TOK term[expr, f2] LPAREN_TOK ( LPAREN_TOK LPAREN_TOK term[f, f2] ( symbol[name,CHECK_NONE,SYM_VARIABLE] )* RPAREN_TOK term[f3, f2] RPAREN_TOK | LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[f3, f2] RPAREN_TOK )+ RPAREN_TOK RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3432);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(MATCH_TOK, &FOLLOW_MATCH_TOK_in_termNonVariable3434);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3436);
        	        term(ctx, expr, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  if( !expr.getSort().isDatatype() ){
        	                    PARSER_STATE->parseError("Cannot match on non-datatype term.");
        	                  }
        	                
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3445);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1285:5: ( LPAREN_TOK LPAREN_TOK term[f, f2] ( symbol[name,CHECK_NONE,SYM_VARIABLE] )* RPAREN_TOK term[f3, f2] RPAREN_TOK | LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[f3, f2] RPAREN_TOK )+
        	        {
        	            int cnt43=0;

        	            for (;;)
        	            {
        	                int alt43=3;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			switch ( LA(2) )
        	        			{
        	        			case LPAREN_TOK:
        	        				{
        	        					alt43=1;
        	        				}
        	        			    break;
        	        			case QUOTED_SYMBOL:
        	        			case SIMPLE_SYMBOL:
        	        			case UNTERMINATED_QUOTED_SYMBOL:
        	        				{
        	        					alt43=2;
        	        				}
        	        			    break;

        	        			}

        	        		}
        	        	    break;

        	        	}

        	        	switch (alt43)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1287:7: LPAREN_TOK LPAREN_TOK term[f, f2] ( symbol[name,CHECK_NONE,SYM_VARIABLE] )* RPAREN_TOK term[f3, f2] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3466);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3468);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_term_in_termNonVariable3470);
        	        	            term(ctx, f, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {

        	        	                          args.clear();
        	        	                          PARSER_STATE->pushScope();
        	        	                          // f should be a constructor
        	        	                          type = f.getSort();
        	        	                          Trace("parser-dt") << "Pattern head : " << f << " " << type << std::endl;
        	        	                          if (!type.isDatatypeConstructor())
        	        	                          {
        	        	                            PARSER_STATE->parseError("Pattern must be application of a constructor or a variable.");
        	        	                          }
        	        	                          cvc5::Datatype dt =
        	        	                              type.getDatatypeConstructorCodomainSort().getDatatype();
        	        	                          if (dt.isParametric())
        	        	                          {
        	        	                            // lookup constructor by name
        	        	                            cvc5::DatatypeConstructor dc = dt.getConstructor(f.toString());
        	        	                            cvc5::Term scons = dc.getInstantiatedTerm(expr.getSort());
        	        	                            // take the type of the specialized constructor instead
        	        	                            type = scons.getSort();
        	        	                          }
        	        	                          argTypes = type.getDatatypeConstructorDomainSorts();
        	        	                        
        	        	            }


        	        	            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1310:9: ( symbol[name,CHECK_NONE,SYM_VARIABLE] )*

        	        	            for (;;)
        	        	            {
        	        	                int alt42=2;
        	        	                switch ( LA(1) )
        	        	                {
        	        	                case QUOTED_SYMBOL:
        	        	                case SIMPLE_SYMBOL:
        	        	                case UNTERMINATED_QUOTED_SYMBOL:
        	        	                	{
        	        	                		alt42=1;
        	        	                	}
        	        	                    break;

        	        	                }

        	        	                switch (alt42)
        	        	                {
        	        	            	case 1:
        	        	            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1310:11: symbol[name,CHECK_NONE,SYM_VARIABLE]
        	        	            	    {
        	        	            	        FOLLOWPUSH(FOLLOW_symbol_in_termNonVariable3494);
        	        	            	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            	        FOLLOWPOP();
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruletermNonVariableEx;
        	        	            	        }


        	        	            	        {

        	        	            	                        if (args.size() >= argTypes.size())
        	        	            	                        {
        	        	            	                          PARSER_STATE->parseError("Too many arguments for pattern.");
        	        	            	                        }
        	        	            	                        //make of proper type
        	        	            	                        cvc5::Term arg = PARSER_STATE->bindBoundVar(name, argTypes[args.size()]);
        	        	            	                        args.push_back( arg );
        	        	            	                      
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	            	default:
        	        	            	    goto loop42;	/* break out of the loop */
        	        	            	    break;
        	        	                }
        	        	            }
        	        	            loop42: ; /* Jump out to here if this rule does not match */


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3518);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_term_in_termNonVariable3520);
        	        	            term(ctx, f3, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {

        	        	                          // make the match case
        	        	                          std::vector<cvc5::Term> cargs;
        	        	                          cargs.push_back(f);
        	        	                          cargs.insert(cargs.end(),args.begin(),args.end());
        	        	                          cvc5::Term c = MK_TERM(cvc5::APPLY_CONSTRUCTOR,cargs);
        	        	                          cvc5::Term bvla = MK_TERM(cvc5::VARIABLE_LIST,args);
        	        	                          cvc5::Term mc = MK_TERM(cvc5::MATCH_BIND_CASE, bvla, c, f3);
        	        	                          matchcases.push_back(mc);
        	        	                          // now, pop the scope
        	        	                          PARSER_STATE->popScope();
        	        	                        
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3533);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1334:9: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] term[f3, f2] RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3550);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_symbol_in_termNonVariable3552);
        	        	            symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {

        	        	                          if (PARSER_STATE->isDeclared(name,SYM_VARIABLE))
        	        	                          {
        	        	                            f = PARSER_STATE->getVariable(name);
        	        	                            type = f.getSort();
        	        	                            if (!type.isDatatypeConstructor() ||
        	        	                                !type.getDatatypeConstructorDomainSorts().empty())
        	        	                            {
        	        	                              PARSER_STATE->parseError("Must apply constructors of arity greater than 0 to arguments in pattern.");
        	        	                            }
        	        	                            // make nullary constructor application
        	        	                            f = MK_TERM(cvc5::APPLY_CONSTRUCTOR, f);
        	        	                          }
        	        	                          else
        	        	                          {
        	        	                            // it has the type of the head expr
        	        	                            f = PARSER_STATE->bindBoundVar(name, expr.getSort());
        	        	                          }
        	        	                        
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_term_in_termNonVariable3565);
        	        	            term(ctx, f3, f2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {

        	        	                          cvc5::Term mc;
        	        	                          if (f.getKind() == cvc5::VARIABLE)
        	        	                          {
        	        	                            cvc5::Term bvlf = MK_TERM(cvc5::VARIABLE_LIST, f);
        	        	                            mc = MK_TERM(cvc5::MATCH_BIND_CASE, bvlf, f, f3);
        	        	                          }
        	        	                          else
        	        	                          {
        	        	                            mc = MK_TERM(cvc5::MATCH_CASE, f, f3);
        	        	                          }
        	        	                          matchcases.push_back(mc);
        	        	                        
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3578);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt43 >= 1 )
        	        		{
        	        		    goto loop43;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermNonVariableEx;
        	        	}
        	        	cnt43++;
        	            }
        	            loop43: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3591);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3593);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  //now, make the match
        	                  if (matchcases.empty())
        	                  {
        	                    PARSER_STATE->parseError("Must have at least one case in match.");
        	                  }
        	                  std::vector<cvc5::Term> mchildren;
        	                  mchildren.push_back(expr);
        	                  mchildren.insert(mchildren.end(), matchcases.begin(), matchcases.end());
        	                  expr = MK_TERM(cvc5::MATCH, mchildren);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1381:5: LPAREN_TOK ATTRIBUTE_TOK term[expr, f2] ( attribute[expr, attexpr] )+ RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3609);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(ATTRIBUTE_TOK, &FOLLOW_ATTRIBUTE_TOK_in_termNonVariable3611);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3613);
        	        term(ctx, expr, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1382:5: ( attribute[expr, attexpr] )+
        	        {
        	            int cnt44=0;

        	            for (;;)
        	            {
        	                int alt44=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
        	        	case ATTRIBUTE_INST_LEVEL:
        	        	case ATTRIBUTE_NAMED_TOK:
        	        	case ATTRIBUTE_NO_PATTERN_TOK:
        	        	case ATTRIBUTE_PATTERN_TOK:
        	        	case ATTRIBUTE_POOL_TOK:
        	        	case ATTRIBUTE_QUANTIFIER_ID_TOK:
        	        	case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
        	        	case KEYWORD:
        	        		{
        	        			alt44=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt44)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1382:7: attribute[expr, attexpr]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_attribute_in_termNonVariable3622);
        	        	            attribute(ctx, expr, attexpr);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermNonVariableEx;
        	        	            }


        	        	            {
        	        	                 if( ! attexpr.isNull()) {
        	        	                          patexprs.push_back( attexpr );
        	        	                        }
        	        	                      
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt44 >= 1 )
        	        		{
        	        		    goto loop44;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermNonVariableEx;
        	        	}
        	        	cnt44++;
        	            }
        	            loop44: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3640);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  if(! patexprs.empty()) {
        	                    if( !f2.isNull() && f2.getKind()==cvc5::INST_PATTERN_LIST ){
        	                      for( size_t i=0; i<f2.getNumChildren(); i++ ){
        	                        patexprs.push_back( f2[i] );
        	                      }
        	                    }
        	                    expr2 = MK_TERM(cvc5::INST_PATTERN_LIST, patexprs);
        	                  } else {
        	                    expr2 = f2;
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1401:5: LPAREN_TOK HO_LAMBDA_TOK boundVarList[bvl] term[f, f2] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termNonVariable3658);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(HO_LAMBDA_TOK, &FOLLOW_HO_LAMBDA_TOK_in_termNonVariable3660);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        FOLLOWPUSH(FOLLOW_boundVarList_in_termNonVariable3672);
        	        boundVarList(ctx, bvl);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_termNonVariable3679);
        	        term(ctx, f, f2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termNonVariable3682);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {

        	                  args.push_back(bvl);
        	                  args.push_back(f);
        	                  PARSER_STATE->popScope();
        	                  expr = MK_TERM(cvc5::LAMBDA, args);
        	                
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1412:5: termAtomic[atomTerm]
        	    {
        	        FOLLOWPUSH(FOLLOW_termAtomic_in_termNonVariable3700);
        	        termAtomic(ctx, atomTerm);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermNonVariableEx;
        	        }


        	        {
        	             expr = atomTerm; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermNonVariableEx; /* Prevent compiler warnings */
    ruletermNonVariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termNonVariable */

/**
 * $ANTLR start qualIdentifier
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1467:1: qualIdentifier[cvc5::ParseOp& p] : ( identifier[p] | LPAREN_TOK AS_TOK identifier[p] sortSymbol[type] RPAREN_TOK );
 */
static void
qualIdentifier(pSmt2Parser ctx, cvc5::ParseOp& p)
{
    /* Initialize rule variables
     */


      cvc5::Sort type;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1471:3: ( identifier[p] | LPAREN_TOK AS_TOK identifier[p] sortSymbol[type] RPAREN_TOK )

            ANTLR3_UINT32 alt46;

            alt46=2;

            switch ( LA(1) )
            {
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt46=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case INDEX_TOK:
            			{
            				alt46=1;
            			}
            		    break;
            		case AS_TOK:
            			{
            				alt46=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 46;
            		    EXCEPTION->state        = 4;


            		    goto rulequalIdentifierEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 46;
                EXCEPTION->state        = 0;


                goto rulequalIdentifierEx;

            }

            switch (alt46)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1471:3: identifier[p]
        	    {
        	        FOLLOWPUSH(FOLLOW_identifier_in_qualIdentifier3723);
        	        identifier(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1472:5: LPAREN_TOK AS_TOK identifier[p] sortSymbol[type] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_qualIdentifier3730);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	         MATCHT(AS_TOK, &FOLLOW_AS_TOK_in_qualIdentifier3732);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_qualIdentifier3734);
        	        identifier(ctx, p);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_qualIdentifier3737);
        	        sortSymbol(ctx, type);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_qualIdentifier3740);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequalIdentifierEx;
        	        }


        	        {

        	                  PARSER_STATE->parseOpApplyTypeAscription(p, type);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulequalIdentifierEx; /* Prevent compiler warnings */
    rulequalIdentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end qualIdentifier */

/**
 * $ANTLR start identifier
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1486:1: identifier[cvc5::ParseOp& p] : ( functionName[p.d_name, CHECK_NONE] | LPAREN_TOK INDEX_TOK ( TESTER_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | UPDATE_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | functionName[opName, CHECK_NONE] nonemptyNumeralList[numerals] ) RPAREN_TOK );
 */
static void
identifier(pSmt2Parser ctx, cvc5::ParseOp& p)
{
    /* Initialize rule variables
     */


      cvc5::Term f;
      cvc5::Term f2;
      std::vector<uint32_t> numerals;
      std::string opName;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1493:3: ( functionName[p.d_name, CHECK_NONE] | LPAREN_TOK INDEX_TOK ( TESTER_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | UPDATE_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | functionName[opName, CHECK_NONE] nonemptyNumeralList[numerals] ) RPAREN_TOK )

            ANTLR3_UINT32 alt48;

            alt48=2;

            switch ( LA(1) )
            {
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt48=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt48=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 48;
                EXCEPTION->state        = 0;


                goto ruleidentifierEx;

            }

            switch (alt48)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1493:3: functionName[p.d_name, CHECK_NONE]
        	    {
        	        FOLLOWPUSH(FOLLOW_functionName_in_identifier3765);
        	        functionName(ctx, p.d_name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleidentifierEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1497:5: LPAREN_TOK INDEX_TOK ( TESTER_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | UPDATE_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | functionName[opName, CHECK_NONE] nonemptyNumeralList[numerals] ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_identifier3777);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleidentifierEx;
        	        }


        	         MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_identifier3779);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleidentifierEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1498:5: ( TESTER_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | UPDATE_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE] | functionName[opName, CHECK_NONE] nonemptyNumeralList[numerals] )
        	        {
        	            int alt47=3;
        	            switch ( LA(1) )
        	            {
        	            case TESTER_TOK:
        	            	{
        	            		alt47=1;
        	            	}
        	                break;
        	            case UPDATE_TOK:
        	            	{
        	            		alt47=2;
        	            	}
        	                break;
        	            case QUOTED_SYMBOL:
        	            case SIMPLE_SYMBOL:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            	{
        	            		alt47=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 47;
        	                EXCEPTION->state        = 0;


        	                goto ruleidentifierEx;

        	            }

        	            switch (alt47)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1498:7: TESTER_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE]
        	        	    {
        	        	         MATCHT(TESTER_TOK, &FOLLOW_TESTER_TOK_in_identifier3787);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_symbol_in_identifier3789);
        	        	        symbol(ctx, opName, CHECK_NONE, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        {

        	        	                    // operator is resolved after parsing to handle overloading
        	        	                    p.d_kind = APPLY_TESTER;
        	        	                    p.d_name = opName;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1504:7: UPDATE_TOK symbol[opName,CHECK_NONE,SYM_VARIABLE]
        	        	    {
        	        	         MATCHT(UPDATE_TOK, &FOLLOW_UPDATE_TOK_in_identifier3806);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_symbol_in_identifier3808);
        	        	        symbol(ctx, opName, CHECK_NONE, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        {

        	        	                    // operator is resolved after parsing to handle overloading
        	        	                    p.d_kind = APPLY_UPDATER;
        	        	                    p.d_name = opName;
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1510:7: functionName[opName, CHECK_NONE] nonemptyNumeralList[numerals]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_functionName_in_identifier3825);
        	        	        functionName(ctx, opName, CHECK_NONE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_nonemptyNumeralList_in_identifier3828);
        	        	        nonemptyNumeralList(ctx, numerals);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleidentifierEx;
        	        	        }


        	        	        {

        	        	                    cvc5::Kind k = PARSER_STATE->getIndexedOpKind(opName);
        	        	                    if (k == cvc5::UNDEFINED_KIND)
        	        	                    {
        	        	                      // We don't know which kind to use until we know the type of the
        	        	                      // arguments. This case handles to_fp, tuple.select and tuple.update
        	        	                      p.d_name = opName;
        	        	                      p.d_indices = numerals;
        	        	                      p.d_kind = cvc5::UNDEFINED_KIND;
        	        	                    }
        	        	                    else
        	        	                    {
        	        	                      p.d_op = SOLVER->mkOp(k, numerals);
        	        	                    }
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_identifier3849);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleidentifierEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start termAtomic
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1534:1: termAtomic[cvc5::Term& atomTerm] : ( INTEGER_LITERAL | DECIMAL_LITERAL | LPAREN_TOK INDEX_TOK ( CHAR_TOK HEX_LITERAL | FMF_CARD_TOK sortSymbol[t] INTEGER_LITERAL |sym= SIMPLE_SYMBOL nonemptyNumeralList[numerals] ) RPAREN_TOK | HEX_LITERAL | BINARY_LITERAL | FIELD_LITERAL | str[s, true] );
 */
static void
termAtomic(pSmt2Parser ctx, cvc5::Term& atomTerm)
{
    pANTLR3_COMMON_TOKEN    sym;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL14;
    pANTLR3_COMMON_TOKEN    DECIMAL_LITERAL15;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL16;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL17;
    pANTLR3_COMMON_TOKEN    HEX_LITERAL18;
    pANTLR3_COMMON_TOKEN    BINARY_LITERAL19;
    pANTLR3_COMMON_TOKEN    FIELD_LITERAL20;

    /* Initialize rule variables
     */


      cvc5::Sort t;
      std::string s;
      std::vector<uint32_t> numerals;

    sym       = NULL;
    INTEGER_LITERAL14       = NULL;
    DECIMAL_LITERAL15       = NULL;
    HEX_LITERAL16       = NULL;
    INTEGER_LITERAL17       = NULL;
    HEX_LITERAL18       = NULL;
    BINARY_LITERAL19       = NULL;
    FIELD_LITERAL20       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1541:3: ( INTEGER_LITERAL | DECIMAL_LITERAL | LPAREN_TOK INDEX_TOK ( CHAR_TOK HEX_LITERAL | FMF_CARD_TOK sortSymbol[t] INTEGER_LITERAL |sym= SIMPLE_SYMBOL nonemptyNumeralList[numerals] ) RPAREN_TOK | HEX_LITERAL | BINARY_LITERAL | FIELD_LITERAL | str[s, true] )

            ANTLR3_UINT32 alt50;

            alt50=7;

            switch ( LA(1) )
            {
            case INTEGER_LITERAL:
            	{
            		alt50=1;
            	}
                break;
            case DECIMAL_LITERAL:
            	{
            		alt50=2;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt50=3;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt50=4;
            	}
                break;
            case BINARY_LITERAL:
            	{
            		alt50=5;
            	}
                break;
            case FIELD_LITERAL:
            	{
            		alt50=6;
            	}
                break;
            case STRING_LITERAL:
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt50=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 50;
                EXCEPTION->state        = 0;


                goto ruletermAtomicEx;

            }

            switch (alt50)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1541:5: INTEGER_LITERAL
        	    {
        	        INTEGER_LITERAL14 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_termAtomic3876);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {

        	                  std::string intStr = AntlrInput::tokenText(INTEGER_LITERAL14);
        	                  atomTerm = PARSER_STATE->mkRealOrIntFromNumeral(intStr);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1546:5: DECIMAL_LITERAL
        	    {
        	        DECIMAL_LITERAL15 = (pANTLR3_COMMON_TOKEN) MATCHT(DECIMAL_LITERAL, &FOLLOW_DECIMAL_LITERAL_in_termAtomic3888);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {

        	                  std::string realStr = AntlrInput::tokenText(DECIMAL_LITERAL15);
        	                  atomTerm = SOLVER->mkReal(realStr);
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1554:5: LPAREN_TOK INDEX_TOK ( CHAR_TOK HEX_LITERAL | FMF_CARD_TOK sortSymbol[t] INTEGER_LITERAL |sym= SIMPLE_SYMBOL nonemptyNumeralList[numerals] ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_termAtomic3907);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	         MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_termAtomic3909);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1555:5: ( CHAR_TOK HEX_LITERAL | FMF_CARD_TOK sortSymbol[t] INTEGER_LITERAL |sym= SIMPLE_SYMBOL nonemptyNumeralList[numerals] )
        	        {
        	            int alt49=3;
        	            switch ( LA(1) )
        	            {
        	            case CHAR_TOK:
        	            	{
        	            		alt49=1;
        	            	}
        	                break;
        	            case FMF_CARD_TOK:
        	            	{
        	            		alt49=2;
        	            	}
        	                break;
        	            case SIMPLE_SYMBOL:
        	            	{
        	            		alt49=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 49;
        	                EXCEPTION->state        = 0;


        	                goto ruletermAtomicEx;

        	            }

        	            switch (alt49)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1555:7: CHAR_TOK HEX_LITERAL
        	        	    {
        	        	         MATCHT(CHAR_TOK, &FOLLOW_CHAR_TOK_in_termAtomic3917);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        HEX_LITERAL16 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_termAtomic3919);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        {

        	        	                    std::string hexStr = AntlrInput::tokenTextSubstr(HEX_LITERAL16, 2);
        	        	                    atomTerm = PARSER_STATE->mkCharConstant(hexStr);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1560:7: FMF_CARD_TOK sortSymbol[t] INTEGER_LITERAL
        	        	    {
        	        	         MATCHT(FMF_CARD_TOK, &FOLLOW_FMF_CARD_TOK_in_termAtomic3935);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_sortSymbol_in_termAtomic3937);
        	        	        sortSymbol(ctx, t);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        INTEGER_LITERAL17 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_termAtomic3940);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        {

        	        	                    uint32_t ubound = AntlrInput::tokenToUnsigned(INTEGER_LITERAL17);
        	        	                    atomTerm = SOLVER->mkCardinalityConstraint(t, ubound);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1565:7: sym= SIMPLE_SYMBOL nonemptyNumeralList[numerals]
        	        	    {
        	        	        sym = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_termAtomic3958);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_nonemptyNumeralList_in_termAtomic3960);
        	        	        nonemptyNumeralList(ctx, numerals);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAtomicEx;
        	        	        }


        	        	        {

        	        	                    atomTerm =
        	        	                      PARSER_STATE->mkIndexedConstant(AntlrInput::tokenText(sym),
        	        	                                                      numerals);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_termAtomic3981);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1575:5: HEX_LITERAL
        	    {
        	        HEX_LITERAL18 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_termAtomic3991);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {

        	                  Assert(AntlrInput::tokenText(HEX_LITERAL18).find("#x") == 0);
        	                  std::string hexStr = AntlrInput::tokenTextSubstr(HEX_LITERAL18, 2);
        	                  atomTerm = SOLVER->mkBitVector(hexStr.size() * 4, hexStr, 16);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1581:5: BINARY_LITERAL
        	    {
        	        BINARY_LITERAL19 = (pANTLR3_COMMON_TOKEN) MATCHT(BINARY_LITERAL, &FOLLOW_BINARY_LITERAL_in_termAtomic4003);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {

        	                  Assert(AntlrInput::tokenText(BINARY_LITERAL19).find("#b") == 0);
        	                  std::string binStr = AntlrInput::tokenTextSubstr(BINARY_LITERAL19, 2);
        	                  atomTerm = SOLVER->mkBitVector(binStr.size(), binStr, 2);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1587:5: FIELD_LITERAL
        	    {
        	        FIELD_LITERAL20 = (pANTLR3_COMMON_TOKEN) MATCHT(FIELD_LITERAL, &FOLLOW_FIELD_LITERAL_in_termAtomic4015);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {

        	                  Assert(AntlrInput::tokenText(FIELD_LITERAL20).find("#f") == 0);
        	                  size_t mPos = AntlrInput::tokenText(FIELD_LITERAL20).find("m");
        	                  Assert(mPos > 2);
        	                  std::string ffValStr = AntlrInput::tokenTextSubstr(FIELD_LITERAL20, 2, mPos - 2);
        	                  std::string ffModStr = AntlrInput::tokenTextSubstr(FIELD_LITERAL20, mPos + 1);
        	                  Sort ffSort = SOLVER->mkFiniteFieldSort(ffModStr);
        	                  atomTerm = SOLVER->mkFiniteFieldElem(ffValStr, ffSort);
        	                
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1599:5: str[s, true]
        	    {
        	        FOLLOWPUSH(FOLLOW_str_in_termAtomic4031);
        	        str(ctx, s, true);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAtomicEx;
        	        }


        	        {
        	             atomTerm = SOLVER->mkString(s, true); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermAtomicEx; /* Prevent compiler warnings */
    ruletermAtomicEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termAtomic */

/**
 * $ANTLR start attribute
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1605:1: attribute[cvc5::Term& expr, cvc5::Term& retExpr] : ( KEYWORD ( simpleSymbolicExprNoKeyword[s] )? | ( ATTRIBUTE_PATTERN_TOK | ATTRIBUTE_POOL_TOK | ATTRIBUTE_INST_ADD_TO_POOL_TOK | ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK ) LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK | ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2] |tok= ( ATTRIBUTE_INST_LEVEL ) INTEGER_LITERAL |tok= ( ATTRIBUTE_QUANTIFIER_ID_TOK ) symbol[s,CHECK_UNDECLARED,SYM_VARIABLE] | ATTRIBUTE_NAMED_TOK symbol[s,CHECK_UNDECLARED,SYM_VARIABLE] );
 */
static void
attribute(pSmt2Parser ctx, cvc5::Term& expr, cvc5::Term& retExpr)
{
    pANTLR3_COMMON_TOKEN    tok;
    pANTLR3_COMMON_TOKEN    KEYWORD21;
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL22;

    /* Initialize rule variables
     */


      cvc5::Term sexpr;
      std::string s;
      cvc5::Term patexpr;
      std::vector<cvc5::Term> patexprs;
      cvc5::Term e2;
      cvc5::Kind k;

    tok       = NULL;
    KEYWORD21       = NULL;
    INTEGER_LITERAL22       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1614:3: ( KEYWORD ( simpleSymbolicExprNoKeyword[s] )? | ( ATTRIBUTE_PATTERN_TOK | ATTRIBUTE_POOL_TOK | ATTRIBUTE_INST_ADD_TO_POOL_TOK | ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK ) LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK | ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2] |tok= ( ATTRIBUTE_INST_LEVEL ) INTEGER_LITERAL |tok= ( ATTRIBUTE_QUANTIFIER_ID_TOK ) symbol[s,CHECK_UNDECLARED,SYM_VARIABLE] | ATTRIBUTE_NAMED_TOK symbol[s,CHECK_UNDECLARED,SYM_VARIABLE] )

            ANTLR3_UINT32 alt54;

            alt54=6;

            switch ( LA(1) )
            {
            case KEYWORD:
            	{
            		alt54=1;
            	}
                break;
            case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
            case ATTRIBUTE_PATTERN_TOK:
            case ATTRIBUTE_POOL_TOK:
            case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
            	{
            		alt54=2;
            	}
                break;
            case ATTRIBUTE_NO_PATTERN_TOK:
            	{
            		alt54=3;
            	}
                break;
            case ATTRIBUTE_INST_LEVEL:
            	{
            		alt54=4;
            	}
                break;
            case ATTRIBUTE_QUANTIFIER_ID_TOK:
            	{
            		alt54=5;
            	}
                break;
            case ATTRIBUTE_NAMED_TOK:
            	{
            		alt54=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 54;
                EXCEPTION->state        = 0;


                goto ruleattributeEx;

            }

            switch (alt54)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1614:5: KEYWORD ( simpleSymbolicExprNoKeyword[s] )?
        	    {
        	        KEYWORD21 = (pANTLR3_COMMON_TOKEN) MATCHT(KEYWORD, &FOLLOW_KEYWORD_in_attribute4055);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1614:13: ( simpleSymbolicExprNoKeyword[s] )?
        	        {
        	            int alt51=2;
        	            switch ( LA(1) )
        	            {
        	                case ASSERT_TOK:
        	                case BINARY_LITERAL:
        	                case CHECK_SAT_ASSUMING_TOK:
        	                case CHECK_SAT_TOK:
        	                case DECIMAL_LITERAL:
        	                case DECLARE_DATATYPES_TOK:
        	                case DECLARE_FUN_TOK:
        	                case DECLARE_SORT_TOK:
        	                case DEFINE_FUNS_REC_TOK:
        	                case DEFINE_FUN_REC_TOK:
        	                case DEFINE_FUN_TOK:
        	                case DEFINE_SORT_TOK:
        	                case ECHO_TOK:
        	                case EXIT_TOK:
        	                case FIELD_LITERAL:
        	                case GET_ASSERTIONS_TOK:
        	                case GET_ASSIGNMENT_TOK:
        	                case GET_DIFFICULTY_TOK:
        	                case GET_INFO_TOK:
        	                case GET_MODEL_TOK:
        	                case GET_OPTION_TOK:
        	                case GET_PROOF_TOK:
        	                case GET_UNSAT_ASSUMPTIONS_TOK:
        	                case GET_UNSAT_CORE_TOK:
        	                case GET_VALUE_TOK:
        	                case HEX_LITERAL:
        	                case INTEGER_LITERAL:
        	                case POP_TOK:
        	                case PUSH_TOK:
        	                case QUOTED_SYMBOL:
        	                case RESET_ASSERTIONS_TOK:
        	                case RESET_TOK:
        	                case SET_INFO_TOK:
        	                case SET_LOGIC_TOK:
        	                case SET_OPTION_TOK:
        	                case SIMPLE_SYMBOL:
        	                case SIMPLIFY_TOK:
        	                case STRING_LITERAL:
        	                case UNTERMINATED_QUOTED_SYMBOL:
        	                case UNTERMINATED_STRING_LITERAL:
        	                	{
        	                		alt51=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt51)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1614:15: simpleSymbolicExprNoKeyword[s]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_simpleSymbolicExprNoKeyword_in_attribute4059);
        	        	        simpleSymbolicExprNoKeyword(ctx, s);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	                PARSER_STATE->attributeNotSupported(AntlrInput::tokenText(KEYWORD21));
        	              
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1618:5: ( ATTRIBUTE_PATTERN_TOK | ATTRIBUTE_POOL_TOK | ATTRIBUTE_INST_ADD_TO_POOL_TOK | ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK ) LPAREN_TOK ( term[patexpr, e2] )+ RPAREN_TOK
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1618:5: ( ATTRIBUTE_PATTERN_TOK | ATTRIBUTE_POOL_TOK | ATTRIBUTE_INST_ADD_TO_POOL_TOK | ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK )
        	        {
        	            int alt52=4;
        	            switch ( LA(1) )
        	            {
        	            case ATTRIBUTE_PATTERN_TOK:
        	            	{
        	            		alt52=1;
        	            	}
        	                break;
        	            case ATTRIBUTE_POOL_TOK:
        	            	{
        	            		alt52=2;
        	            	}
        	                break;
        	            case ATTRIBUTE_INST_ADD_TO_POOL_TOK:
        	            	{
        	            		alt52=3;
        	            	}
        	                break;
        	            case ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK:
        	            	{
        	            		alt52=4;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 52;
        	                EXCEPTION->state        = 0;


        	                goto ruleattributeEx;

        	            }

        	            switch (alt52)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1618:7: ATTRIBUTE_PATTERN_TOK
        	        	    {
        	        	         MATCHT(ATTRIBUTE_PATTERN_TOK, &FOLLOW_ATTRIBUTE_PATTERN_TOK_in_attribute4075);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	        {
        	        	             k = cvc5::INST_PATTERN; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1619:7: ATTRIBUTE_POOL_TOK
        	        	    {
        	        	         MATCHT(ATTRIBUTE_POOL_TOK, &FOLLOW_ATTRIBUTE_POOL_TOK_in_attribute4087);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	        {
        	        	             k = cvc5::INST_POOL; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1620:7: ATTRIBUTE_INST_ADD_TO_POOL_TOK
        	        	    {
        	        	         MATCHT(ATTRIBUTE_INST_ADD_TO_POOL_TOK, &FOLLOW_ATTRIBUTE_INST_ADD_TO_POOL_TOK_in_attribute4100);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	        {
        	        	             k = cvc5::INST_ADD_TO_POOL; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1621:7: ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK
        	        	    {
        	        	         MATCHT(ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK, &FOLLOW_ATTRIBUTE_SKOLEM_ADD_TO_POOL_TOK_in_attribute4113);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattributeEx;
        	        	        }


        	        	        {
        	        	             k = cvc5::SKOLEM_ADD_TO_POOL; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_attribute4126);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1624:5: ( term[patexpr, e2] )+
        	        {
        	            int cnt53=0;

        	            for (;;)
        	            {
        	                int alt53=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case BINARY_LITERAL:
        	        	case DECIMAL_LITERAL:
        	        	case FIELD_LITERAL:
        	        	case HEX_LITERAL:
        	        	case INTEGER_LITERAL:
        	        	case LPAREN_TOK:
        	        	case QUOTED_SYMBOL:
        	        	case SIMPLE_SYMBOL:
        	        	case STRING_LITERAL:
        	        	case UNTERMINATED_QUOTED_SYMBOL:
        	        	case UNTERMINATED_STRING_LITERAL:
        	        		{
        	        			alt53=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt53)
        	        	{
        	        	    case 1:
        	        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1624:7: term[patexpr, e2]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_term_in_attribute4134);
        	        	            term(ctx, patexpr, e2);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleattributeEx;
        	        	            }


        	        	            {
        	        	                 patexprs.push_back( patexpr ); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt53 >= 1 )
        	        		{
        	        		    goto loop53;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleattributeEx;
        	        	}
        	        	cnt53++;
        	            }
        	            loop53: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_attribute4152);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  retExpr = MK_TERM(k, patexprs);
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1630:5: ATTRIBUTE_NO_PATTERN_TOK term[patexpr, e2]
        	    {
        	         MATCHT(ATTRIBUTE_NO_PATTERN_TOK, &FOLLOW_ATTRIBUTE_NO_PATTERN_TOK_in_attribute4164);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_term_in_attribute4166);
        	        term(ctx, patexpr, e2);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  retExpr = MK_TERM(cvc5::INST_NO_PATTERN, patexpr);
        	                
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1634:5: tok= ( ATTRIBUTE_INST_LEVEL ) INTEGER_LITERAL
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1634:9: ( ATTRIBUTE_INST_LEVEL )
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1634:11: ATTRIBUTE_INST_LEVEL
        	        {
        	             MATCHT(ATTRIBUTE_INST_LEVEL, &FOLLOW_ATTRIBUTE_INST_LEVEL_in_attribute4183);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleattributeEx;
        	            }


        	        }


        	        INTEGER_LITERAL22 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_attribute4187);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  std::stringstream sIntLit;
        	                  sIntLit << INTEGER_LITERAL22;
        	                  cvc5::Term keyword = SOLVER->mkString("quant-inst-max-level");
        	                  cvc5::Term n = SOLVER->mkInteger(sIntLit.str());
        	                  retExpr = MK_TERM(cvc5::INST_ATTRIBUTE, keyword, n);
        	                
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1642:5: tok= ( ATTRIBUTE_QUANTIFIER_ID_TOK ) symbol[s,CHECK_UNDECLARED,SYM_VARIABLE]
        	    {
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1642:9: ( ATTRIBUTE_QUANTIFIER_ID_TOK )
        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1642:11: ATTRIBUTE_QUANTIFIER_ID_TOK
        	        {
        	             MATCHT(ATTRIBUTE_QUANTIFIER_ID_TOK, &FOLLOW_ATTRIBUTE_QUANTIFIER_ID_TOK_in_attribute4203);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleattributeEx;
        	            }


        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_attribute4207);
        	        symbol(ctx, s, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  cvc5::Term keyword = SOLVER->mkString("qid");
        	                  // must create a variable whose name is the name of the quantified
        	                  // formula, not a string.
        	                  cvc5::Term name = SOLVER->mkConst(SOLVER->getBooleanSort(), s);
        	                  retExpr = MK_TERM(cvc5::INST_ATTRIBUTE, keyword, name);
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1650:5: ATTRIBUTE_NAMED_TOK symbol[s,CHECK_UNDECLARED,SYM_VARIABLE]
        	    {
        	         MATCHT(ATTRIBUTE_NAMED_TOK, &FOLLOW_ATTRIBUTE_NAMED_TOK_in_attribute4220);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_symbol_in_attribute4222);
        	        symbol(ctx, s, CHECK_UNDECLARED, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattributeEx;
        	        }


        	        {

        	                  Trace("parser") << "Named: " << s << " for " << expr << std::endl;
        	                  PARSER_STATE->notifyNamedExpression(expr, s);
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start termList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1665:1: termList[std::vector<cvc5::Term>& formulas, cvc5::Term& expr] : ( term[expr, expr2] )+ ;
 */
static void
termList(pSmt2Parser ctx, std::vector<cvc5::Term>& formulas, cvc5::Term& expr)
{

      cvc5::Term expr2;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1669:3: ( ( term[expr, expr2] )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1669:5: ( term[expr, expr2] )+
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1669:5: ( term[expr, expr2] )+
            {
                int cnt55=0;

                for (;;)
                {
                    int alt55=2;
            	switch ( LA(1) )
            	{
            	case BINARY_LITERAL:
            	case DECIMAL_LITERAL:
            	case FIELD_LITERAL:
            	case HEX_LITERAL:
            	case INTEGER_LITERAL:
            	case LPAREN_TOK:
            	case QUOTED_SYMBOL:
            	case SIMPLE_SYMBOL:
            	case STRING_LITERAL:
            	case UNTERMINATED_QUOTED_SYMBOL:
            	case UNTERMINATED_STRING_LITERAL:
            		{
            			alt55=1;
            		}
            	    break;

            	}

            	switch (alt55)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1669:7: term[expr, expr2]
            	        {
            	            FOLLOWPUSH(FOLLOW_term_in_termList4254);
            	            term(ctx, expr, expr2);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletermListEx;
            	            }


            	            {
            	                 formulas.push_back(expr); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt55 >= 1 )
            		{
            		    goto loop55;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletermListEx;
            	}
            	cnt55++;
                }
                loop55: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletermListEx; /* Prevent compiler warnings */
    ruletermListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termList */

/**
 * $ANTLR start str
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1676:1: str[std::string& s, bool unescape] : ( STRING_LITERAL | UNTERMINATED_STRING_LITERAL EOF );
 */
static void
str(pSmt2Parser ctx, std::string& s, bool unescape)
{
    pANTLR3_COMMON_TOKEN    STRING_LITERAL23;

    /* Initialize rule variables
     */

    STRING_LITERAL23       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1677:3: ( STRING_LITERAL | UNTERMINATED_STRING_LITERAL EOF )

            ANTLR3_UINT32 alt56;

            alt56=2;

            switch ( LA(1) )
            {
            case STRING_LITERAL:
            	{
            		alt56=1;
            	}
                break;
            case UNTERMINATED_STRING_LITERAL:
            	{
            		alt56=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 56;
                EXCEPTION->state        = 0;


                goto rulestrEx;

            }

            switch (alt56)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1677:5: STRING_LITERAL
        	    {
        	        STRING_LITERAL23 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_str4276);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestrEx;
        	        }


        	        {

        	                  s = AntlrInput::tokenText(STRING_LITERAL23);
        	                  if (unescape)
        	                  {
        	                    /* strip off the quotes */
        	                    s = s.substr(1, s.size() - 2);
        	                    for (size_t i = 0; i < s.size(); i++)
        	                    {
        	                      if ((unsigned)s[i] > 127 && !isprint(s[i]))
        	                      {
        	                        PARSER_STATE->parseError(
        	                            "Extended/unprintable characters are not "
        	                            "part of SMT-LIB, and they must be encoded "
        	                            "as escape sequences");
        	                      }
        	                    }
        	                    char* p_orig = strdup(s.c_str());
        	                    char *p = p_orig, *q = p_orig;
        	                    while (*q != '\0')
        	                    {
        	                      if (*q == '"')
        	                      {
        	                        // Handle SMT-LIB >=2.5 standard escape '""'.
        	                        ++q;
        	                        Assert(*q == '"');
        	                      }
        	                      *p++ = *q++;
        	                    }
        	                    *p = '\0';
        	                    s = p_orig;
        	                    free(p_orig);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1711:5: UNTERMINATED_STRING_LITERAL EOF
        	    {
        	         MATCHT(UNTERMINATED_STRING_LITERAL, &FOLLOW_UNTERMINATED_STRING_LITERAL_in_str4288);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestrEx;
        	        }


        	         MATCHT(EOF, &FOLLOW_EOF_in_str4290);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestrEx;
        	        }


        	        {
        	             PARSER_STATE->unexpectedEOF("unterminated string literal"); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestrEx; /* Prevent compiler warnings */
    rulestrEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end str */

/**
 * $ANTLR start quantOp
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1715:1: quantOp[cvc5::Kind& kind] : ( EXISTS_TOK | FORALL_TOK );
 */
static void
quantOp(pSmt2Parser ctx, cvc5::Kind& kind)
{
    /* Initialize rule variables
     */


      Trace("parser") << "quant: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1719:3: ( EXISTS_TOK | FORALL_TOK )

            ANTLR3_UINT32 alt57;

            alt57=2;

            switch ( LA(1) )
            {
            case EXISTS_TOK:
            	{
            		alt57=1;
            	}
                break;
            case FORALL_TOK:
            	{
            		alt57=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 57;
                EXCEPTION->state        = 0;


                goto rulequantOpEx;

            }

            switch (alt57)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1719:5: EXISTS_TOK
        	    {
        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_quantOp4315);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequantOpEx;
        	        }


        	        {
        	             kind= cvc5::EXISTS; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1720:5: FORALL_TOK
        	    {
        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_quantOp4326);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequantOpEx;
        	        }


        	        {
        	             kind= cvc5::FORALL; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulequantOpEx; /* Prevent compiler warnings */
    rulequantOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end quantOp */

/**
 * $ANTLR start functionName
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1727:1: functionName[std::string& name, cvc5::parser::DeclarationCheck check] : symbol[name,check,SYM_VARIABLE] ;
 */
static void
functionName(pSmt2Parser ctx, std::string& name, cvc5::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1728:3: ( symbol[name,check,SYM_VARIABLE] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1728:5: symbol[name,check,SYM_VARIABLE]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_functionName4347);
            symbol(ctx, name, check, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionNameEx; /* Prevent compiler warnings */
    rulefunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionName */

/**
 * $ANTLR start sortList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1735:1: sortList[std::vector<cvc5::Sort>& sorts] : ( sortSymbol[t] )* ;
 */
static void
sortList(pSmt2Parser ctx, std::vector<cvc5::Sort>& sorts)
{

      cvc5::Sort t;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1739:3: ( ( sortSymbol[t] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1739:5: ( sortSymbol[t] )*
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1739:5: ( sortSymbol[t] )*

            for (;;)
            {
                int alt58=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                case QUOTED_SYMBOL:
                case SIMPLE_SYMBOL:
                case UNTERMINATED_QUOTED_SYMBOL:
                	{
                		alt58=1;
                	}
                    break;

                }

                switch (alt58)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1739:7: sortSymbol[t]
            	    {
            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortList4371);
            	        sortSymbol(ctx, t);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortListEx;
            	        }


            	        {
            	             sorts.push_back(t); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop58;	/* break out of the loop */
            	    break;
                }
            }
            loop58: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortListEx; /* Prevent compiler warnings */
    rulesortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortList */

/**
 * $ANTLR start nonemptySortList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1742:1: nonemptySortList[std::vector<cvc5::Sort>& sorts] : ( sortSymbol[t] )+ ;
 */
static void
nonemptySortList(pSmt2Parser ctx, std::vector<cvc5::Sort>& sorts)
{

      cvc5::Sort t;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1746:3: ( ( sortSymbol[t] )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1746:5: ( sortSymbol[t] )+
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1746:5: ( sortSymbol[t] )+
            {
                int cnt59=0;

                for (;;)
                {
                    int alt59=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            	case QUOTED_SYMBOL:
            	case SIMPLE_SYMBOL:
            	case UNTERMINATED_QUOTED_SYMBOL:
            		{
            			alt59=1;
            		}
            	    break;

            	}

            	switch (alt59)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1746:7: sortSymbol[t]
            	        {
            	            FOLLOWPUSH(FOLLOW_sortSymbol_in_nonemptySortList4398);
            	            sortSymbol(ctx, t);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenonemptySortListEx;
            	            }


            	            {
            	                 sorts.push_back(t); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt59 >= 1 )
            		{
            		    goto loop59;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenonemptySortListEx;
            	}
            	cnt59++;
                }
                loop59: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenonemptySortListEx; /* Prevent compiler warnings */
    rulenonemptySortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nonemptySortList */

/**
 * $ANTLR start sortedVarList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1753:1: sortedVarList[std::vector<std::pair<std::string, cvc5::Sort> >& sortedVars] : ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] RPAREN_TOK )* ;
 */
static void
sortedVarList(pSmt2Parser ctx, std::vector<std::pair<std::string, cvc5::Sort> >& sortedVars)
{

      std::string name;
      cvc5::Sort t;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1758:3: ( ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] RPAREN_TOK )* )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1758:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] RPAREN_TOK )*
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1758:5: ( LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] RPAREN_TOK )*

            for (;;)
            {
                int alt60=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt60=1;
                	}
                    break;

                }

                switch (alt60)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1758:7: LPAREN_TOK symbol[name,CHECK_NONE,SYM_VARIABLE] sortSymbol[t] RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sortedVarList4427);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_symbol_in_sortedVarList4429);
            	        symbol(ctx, name, CHECK_NONE, SYM_VARIABLE);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortedVarList4438);
            	        sortSymbol(ctx, t);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sortedVarList4441);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortedVarListEx;
            	        }


            	        {
            	             sortedVars.push_back(make_pair(name, t)); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop60;	/* break out of the loop */
            	    break;
                }
            }
            loop60: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortedVarListEx; /* Prevent compiler warnings */
    rulesortedVarListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortedVarList */

/**
 * $ANTLR start boundVarList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1768:1: boundVarList[cvc5::Term& expr] : LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK ;
 */
static void
boundVarList(pSmt2Parser ctx, cvc5::Term& expr)
{

      std::vector<std::pair<std::string, cvc5::Sort>> sortedVarNames;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1772:2: ( LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1772:4: LPAREN_TOK sortedVarList[sortedVarNames] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_boundVarList4476);
            if  (HASEXCEPTION())
            {
                goto ruleboundVarListEx;
            }


            FOLLOWPUSH(FOLLOW_sortedVarList_in_boundVarList4478);
            sortedVarList(ctx, sortedVarNames);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboundVarListEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_boundVarList4481);
            if  (HASEXCEPTION())
            {
                goto ruleboundVarListEx;
            }


            {

                     std::vector<cvc5::Term> args =
                         PARSER_STATE->bindBoundVars(sortedVarNames);
                     expr = MK_TERM(cvc5::VARIABLE_LIST, args);
                   
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboundVarListEx; /* Prevent compiler warnings */
    ruleboundVarListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end boundVarList */

/**
 * $ANTLR start sortName
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1784:1: sortName[std::string& name, cvc5::parser::DeclarationCheck check] : symbol[name,check,SYM_SORT] ;
 */
static void
sortName(pSmt2Parser ctx, std::string& name, cvc5::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1785:3: ( symbol[name,check,SYM_SORT] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1785:5: symbol[name,check,SYM_SORT]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_sortName4501);
            symbol(ctx, name, check, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortNameEx; /* Prevent compiler warnings */
    rulesortNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortName */

/**
 * $ANTLR start sortSymbol
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1788:1: sortSymbol[cvc5::Sort& t] : ( sortName[name,CHECK_NONE] | LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralStringList[numerals] | sortList[args] ) RPAREN_TOK );
 */
static void
sortSymbol(pSmt2Parser ctx, cvc5::Sort& t)
{

      std::string name;
      std::vector<cvc5::Sort> args;
      std::vector<std::string> numerals;
      bool indexed = false;

    /* Initialize rule variables
     */

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1795:3: ( sortName[name,CHECK_NONE] | LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralStringList[numerals] | sortList[args] ) RPAREN_TOK )

            ANTLR3_UINT32 alt63;

            alt63=2;

            switch ( LA(1) )
            {
            case QUOTED_SYMBOL:
            case SIMPLE_SYMBOL:
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt63=1;
            	}
                break;
            case LPAREN_TOK:
            	{
            		alt63=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 63;
                EXCEPTION->state        = 0;


                goto rulesortSymbolEx;

            }

            switch (alt63)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1795:5: sortName[name,CHECK_NONE]
        	    {
        	        FOLLOWPUSH(FOLLOW_sortName_in_sortSymbol4521);
        	        sortName(ctx, name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	                  t = PARSER_STATE->getSort(name);
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1799:5: LPAREN_TOK ( INDEX_TOK |) symbol[name,CHECK_NONE,SYM_SORT] ( nonemptyNumeralStringList[numerals] | sortList[args] ) RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_sortSymbol4534);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1799:16: ( INDEX_TOK |)
        	        {
        	            int alt61=2;
        	            switch ( LA(1) )
        	            {
        	            case INDEX_TOK:
        	            	{
        	            		alt61=1;
        	            	}
        	                break;
        	            case QUOTED_SYMBOL:
        	            case SIMPLE_SYMBOL:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            	{
        	            		alt61=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 61;
        	                EXCEPTION->state        = 0;


        	                goto rulesortSymbolEx;

        	            }

        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1799:17: INDEX_TOK
        	        	    {
        	        	         MATCHT(INDEX_TOK, &FOLLOW_INDEX_TOK_in_sortSymbol4537);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {
        	        	            indexed = true;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1799:47: 
        	        	    {
        	        	        {
        	        	            indexed = false;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_symbol_in_sortSymbol4550);
        	        symbol(ctx, name, CHECK_NONE, SYM_SORT);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1801:5: ( nonemptyNumeralStringList[numerals] | sortList[args] )
        	        {
        	            int alt62=2;
        	            switch ( LA(1) )
        	            {
        	            case INTEGER_LITERAL:
        	            	{
        	            		alt62=1;
        	            	}
        	                break;
        	            case LPAREN_TOK:
        	            case QUOTED_SYMBOL:
        	            case RPAREN_TOK:
        	            case SIMPLE_SYMBOL:
        	            case UNTERMINATED_QUOTED_SYMBOL:
        	            	{
        	            		alt62=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 62;
        	                EXCEPTION->state        = 0;


        	                goto rulesortSymbolEx;

        	            }

        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1801:7: nonemptyNumeralStringList[numerals]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_nonemptyNumeralStringList_in_sortSymbol4559);
        	        	        nonemptyNumeralStringList(ctx, numerals);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {

        	        	                    if (!indexed)
        	        	                    {
        	        	                      std::stringstream ss;
        	        	                      ss << "SMT-LIB requires use of an indexed sort here, e.g. (_ " << name
        	        	                         << " ...)";
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    t = PARSER_STATE->getIndexedSort(name, numerals);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1812:7: sortList[args]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_sortList_in_sortSymbol4576);
        	        	        sortList(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesortSymbolEx;
        	        	        }


        	        	        {
        	        	             if( indexed ) {
        	        	                      std::stringstream ss;
        	        	                      ss << "Unexpected use of indexing operator `_' before `" << name
        	        	                         << "', try leaving it out";
        	        	                      PARSER_STATE->parseError(ss.str());
        	        	                    }
        	        	                    t = PARSER_STATE->getParametricSort(name, args);
        	        	                  
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_sortSymbol4593);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesortSymbolEx; /* Prevent compiler warnings */
    rulesortSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortSymbol */

/**
 * $ANTLR start symbolList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1828:1: symbolList[std::vector<std::string>& names,\n cvc5::parser::DeclarationCheck check,\n cvc5::parser::SymbolType type] : ( symbol[id,check,type] )* ;
 */
static void
symbolList(pSmt2Parser ctx, std::vector<std::string>& names, cvc5::parser::DeclarationCheck check, cvc5::parser::SymbolType type)
{

      std::string id;

    /* Initialize rule variables
     */

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1834:3: ( ( symbol[id,check,type] )* )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1834:5: ( symbol[id,check,type] )*
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1834:5: ( symbol[id,check,type] )*

            for (;;)
            {
                int alt64=2;
                switch ( LA(1) )
                {
                case QUOTED_SYMBOL:
                case SIMPLE_SYMBOL:
                case UNTERMINATED_QUOTED_SYMBOL:
                	{
                		alt64=1;
                	}
                    break;

                }

                switch (alt64)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1834:7: symbol[id,check,type]
            	    {
            	        FOLLOWPUSH(FOLLOW_symbol_in_symbolList4616);
            	        symbol(ctx, id, check, type);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolListEx;
            	        }


            	        {
            	             names.push_back(id); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop64;	/* break out of the loop */
            	    break;
                }
            }
            loop64: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesymbolListEx; /* Prevent compiler warnings */
    rulesymbolListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbolList */

/**
 * $ANTLR start symbol
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1843:1: symbol[std::string& id,\n cvc5::parser::DeclarationCheck check,\n cvc5::parser::SymbolType type] : ( SIMPLE_SYMBOL | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' ) );
 */
static void
symbol(pSmt2Parser ctx, std::string& id, cvc5::parser::DeclarationCheck check, cvc5::parser::SymbolType type)
{
    pANTLR3_COMMON_TOKEN    SIMPLE_SYMBOL24;
    pANTLR3_COMMON_TOKEN    QUOTED_SYMBOL25;

    /* Initialize rule variables
     */

    SIMPLE_SYMBOL24       = NULL;
    QUOTED_SYMBOL25       = NULL;

    {
        {
            //  /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1846:3: ( SIMPLE_SYMBOL | QUOTED_SYMBOL | UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' ) )

            ANTLR3_UINT32 alt66;

            alt66=3;

            switch ( LA(1) )
            {
            case SIMPLE_SYMBOL:
            	{
            		alt66=1;
            	}
                break;
            case QUOTED_SYMBOL:
            	{
            		alt66=2;
            	}
                break;
            case UNTERMINATED_QUOTED_SYMBOL:
            	{
            		alt66=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 66;
                EXCEPTION->state        = 0;


                goto rulesymbolEx;

            }

            switch (alt66)
            {
        	case 1:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1846:5: SIMPLE_SYMBOL
        	    {
        	        SIMPLE_SYMBOL24 = (pANTLR3_COMMON_TOKEN) MATCHT(SIMPLE_SYMBOL, &FOLLOW_SIMPLE_SYMBOL_in_symbol4638);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        {
        	             id = AntlrInput::tokenText(SIMPLE_SYMBOL24);
        	                  if(!PARSER_STATE->isAbstractValue(id)) {
        	                    // if an abstract value, SolverEngine handles declaration
        	                    PARSER_STATE->checkDeclaration(id, check, type);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1853:5: QUOTED_SYMBOL
        	    {
        	        QUOTED_SYMBOL25 = (pANTLR3_COMMON_TOKEN) MATCHT(QUOTED_SYMBOL, &FOLLOW_QUOTED_SYMBOL_in_symbol4650);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        {
        	             id = AntlrInput::tokenText(QUOTED_SYMBOL25);
        	                  if (type != SymbolType::SYM_VERBATIM)
        	                  {
        	                    /* strip off the quotes */
        	                    id = id.substr(1, id.size() - 2);
        	                  }
        	                  if(!PARSER_STATE->isAbstractValue(id)) {
        	                    // if an abstract value, SolverEngine handles declaration
        	                    PARSER_STATE->checkDeclaration(id, check, type);
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1865:5: UNTERMINATED_QUOTED_SYMBOL ( EOF | '\\\\' )
        	    {
        	         MATCHT(UNTERMINATED_QUOTED_SYMBOL, &FOLLOW_UNTERMINATED_QUOTED_SYMBOL_in_symbol4662);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolEx;
        	        }


        	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1866:5: ( EOF | '\\\\' )
        	        {
        	            int alt65=2;
        	            switch ( LA(1) )
        	            {
        	            case EOF:
        	            	{
        	            		alt65=1;
        	            	}
        	                break;
        	            case 105:
        	            	{
        	            		alt65=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 65;
        	                EXCEPTION->state        = 0;


        	                goto rulesymbolEx;

        	            }

        	            switch (alt65)
        	            {
        	        	case 1:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1866:7: EOF
        	        	    {
        	        	         MATCHT(EOF, &FOLLOW_EOF_in_symbol4670);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->unexpectedEOF("unterminated |quoted| symbol"); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1868:7: '\\\\'
        	        	    {
        	        	         MATCHT(105, &FOLLOW_105_in_symbol4686);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolEx;
        	        	        }


        	        	        {
        	        	             PARSER_STATE->unexpectedEOF("backslash not permitted in |quoted| "
        	        	                                                "symbol"); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesymbolEx; /* Prevent compiler warnings */
    rulesymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end symbol */

/**
 * $ANTLR start nonemptyNumeralList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1879:1: nonemptyNumeralList[std::vector<uint32_t>& numerals] : ( INTEGER_LITERAL )+ ;
 */
static void
nonemptyNumeralList(pSmt2Parser ctx, std::vector<uint32_t>& numerals)
{
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL26;

    /* Initialize rule variables
     */

    INTEGER_LITERAL26       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1880:3: ( ( INTEGER_LITERAL )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1880:5: ( INTEGER_LITERAL )+
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1880:5: ( INTEGER_LITERAL )+
            {
                int cnt67=0;

                for (;;)
                {
                    int alt67=2;
            	switch ( LA(1) )
            	{
            	case INTEGER_LITERAL:
            		{
            			alt67=1;
            		}
            	    break;

            	}

            	switch (alt67)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1880:7: INTEGER_LITERAL
            	        {
            	            INTEGER_LITERAL26 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralList4718);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenonemptyNumeralListEx;
            	            }


            	            {
            	                 numerals.push_back(AntlrInput::tokenToUnsigned(INTEGER_LITERAL26)); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt67 >= 1 )
            		{
            		    goto loop67;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenonemptyNumeralListEx;
            	}
            	cnt67++;
                }
                loop67: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenonemptyNumeralListEx; /* Prevent compiler warnings */
    rulenonemptyNumeralListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nonemptyNumeralList */

/**
 * $ANTLR start nonemptyNumeralStringList
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1889:1: nonemptyNumeralStringList[std::vector<std::string>& numeralStrings] : ( INTEGER_LITERAL )+ ;
 */
static void
nonemptyNumeralStringList(pSmt2Parser ctx, std::vector<std::string>& numeralStrings)
{
    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL27;

    /* Initialize rule variables
     */

    INTEGER_LITERAL27       = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1890:3: ( ( INTEGER_LITERAL )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1890:5: ( INTEGER_LITERAL )+
        {
            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1890:5: ( INTEGER_LITERAL )+
            {
                int cnt68=0;

                for (;;)
                {
                    int alt68=2;
            	switch ( LA(1) )
            	{
            	case INTEGER_LITERAL:
            		{
            			alt68=1;
            		}
            	    break;

            	}

            	switch (alt68)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1890:7: INTEGER_LITERAL
            	        {
            	            INTEGER_LITERAL27 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_nonemptyNumeralStringList4751);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenonemptyNumeralStringListEx;
            	            }


            	            {
            	                 numeralStrings.push_back(AntlrInput::tokenText(INTEGER_LITERAL27)); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt68 >= 1 )
            		{
            		    goto loop68;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenonemptyNumeralStringListEx;
            	}
            	cnt68++;
                }
                loop68: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenonemptyNumeralStringListEx; /* Prevent compiler warnings */
    rulenonemptyNumeralStringListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end nonemptyNumeralStringList */

/**
 * $ANTLR start datatypeDef
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1898:1: datatypeDef[bool isCo, std::vector<cvc5::DatatypeDecl>& datatypes,\n std::vector< cvc5::Sort >& params] : symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+ ;
 */
static void
datatypeDef(pSmt2Parser ctx, bool isCo, std::vector<cvc5::DatatypeDecl>& datatypes, std::vector< cvc5::Sort >& params)
{
    /* Initialize rule variables
     */


      std::string id;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1907:3: ( symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+ )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1907:5: symbol[id,CHECK_NONE,SYM_SORT] ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+
        {
            FOLLOWPUSH(FOLLOW_symbol_in_datatypeDef4793);
            symbol(ctx, id, CHECK_NONE, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledatatypeDefEx;
            }


            {
                 PARSER_STATE->pushScope(); 
            }


            {

                      datatypes.push_back(SOLVER->mkDatatypeDecl(id, params, isCo));
                    
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1911:5: ( LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK )+
            {
                int cnt69=0;

                for (;;)
                {
                    int alt69=2;
            	switch ( LA(1) )
            	{
            	case LPAREN_TOK:
            		{
            			alt69=1;
            		}
            	    break;

            	}

            	switch (alt69)
            	{
            	    case 1:
            	        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1911:7: LPAREN_TOK constructorDef[datatypes.back()] RPAREN_TOK
            	        {
            	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_datatypeDef4810);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	            FOLLOWPUSH(FOLLOW_constructorDef_in_datatypeDef4812);
            	            constructorDef(ctx, datatypes.back());

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_datatypeDef4815);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledatatypeDefEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt69 >= 1 )
            		{
            		    goto loop69;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledatatypeDefEx;
            	}
            	cnt69++;
                }
                loop69: ;	/* Jump to here if this rule does not match */
            }

            {
                 PARSER_STATE->popScope(); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledatatypeDefEx; /* Prevent compiler warnings */
    ruledatatypeDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end datatypeDef */

/**
 * $ANTLR start constructorDef
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1918:1: constructorDef[cvc5::DatatypeDecl& type] : symbol[id,CHECK_NONE,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )* ;
 */
static void
constructorDef(pSmt2Parser ctx, cvc5::DatatypeDecl& type)
{
    /* Initialize rule variables
     */


      std::string id;
      cvc5::DatatypeConstructorDecl* ctor = NULL;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1923:3: ( symbol[id,CHECK_NONE,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )* )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1923:5: symbol[id,CHECK_NONE,SYM_VARIABLE] ( LPAREN_TOK selector[*ctor] RPAREN_TOK )*
        {
            FOLLOWPUSH(FOLLOW_symbol_in_constructorDef4845);
            symbol(ctx, id, CHECK_NONE, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstructorDefEx;
            }


            {

                      ctor = new cvc5::DatatypeConstructorDecl(
                          SOLVER->mkDatatypeConstructorDecl(id));
                    
            }


            // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1928:5: ( LPAREN_TOK selector[*ctor] RPAREN_TOK )*

            for (;;)
            {
                int alt70=2;
                switch ( LA(1) )
                {
                case LPAREN_TOK:
                	{
                		alt70=1;
                	}
                    break;

                }

                switch (alt70)
                {
            	case 1:
            	    // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1928:7: LPAREN_TOK selector[*ctor] RPAREN_TOK
            	    {
            	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_constructorDef4860);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_selector_in_constructorDef4862);
            	        selector(ctx, *ctor);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_constructorDef4865);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleconstructorDefEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop70;	/* break out of the loop */
            	    break;
                }
            }
            loop70: ; /* Jump out to here if this rule does not match */


            {
                 // make the constructor
                      type.addConstructor(*ctor);
                      Trace("parser-idt") << "constructor: " << id.c_str() << std::endl;
                      delete ctor;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructorDefEx; /* Prevent compiler warnings */
    ruleconstructorDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end constructorDef */

/**
 * $ANTLR start selector
 * /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1936:1: selector[cvc5::DatatypeConstructorDecl& ctor] : symbol[id,CHECK_NONE,SYM_SORT] sortSymbol[t] ;
 */
static void
selector(pSmt2Parser ctx, cvc5::DatatypeConstructorDecl& ctor)
{
    /* Initialize rule variables
     */


      std::string id;
      cvc5::Sort t, t2;

    {
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1941:3: ( symbol[id,CHECK_NONE,SYM_SORT] sortSymbol[t] )
        // /home/aaa/fp-solver/cvc5/src/parser/smt2/Smt2.g:1941:5: symbol[id,CHECK_NONE,SYM_SORT] sortSymbol[t]
        {
            FOLLOWPUSH(FOLLOW_symbol_in_selector4893);
            symbol(ctx, id, CHECK_NONE, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }


            FOLLOWPUSH(FOLLOW_sortSymbol_in_selector4896);
            sortSymbol(ctx, t);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectorEx;
            }


            {

                      ctor.addSelector(id, t);
                      Trace("parser-idt") << "selector: " << id.c_str()
                                          << " of type " << t << std::endl;
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleselectorEx; /* Prevent compiler warnings */
    ruleselectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end selector */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
