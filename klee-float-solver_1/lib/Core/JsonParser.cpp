//===-- UserSearcher.cpp --------------------------------------------------===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#include "Executor.h"

#include "klee/Core/JsonParser.h"
#include "llvm/Support/CommandLine.h"

#include <sys/stat.h>
#include "json-c/json.h"
#include <gmpxx.h>
#include <gmp.h>

using namespace llvm;
using namespace klee;

namespace klee{
llvm::cl::OptionCategory
    JsonInfoCat("Json config file path",
                "These options specify the location of the "
                "JSON config file generated by fdse-gen.");

cl::opt<std::string> JsonConfigPath(
    "json-config-path",
    cl::desc("JSON config file path generated by fdse-gen."),
    cl::init(""),
    cl::cat(JsonInfoCat));

} // namespace

std::set<std::string> basicTypeSet {
    "byte","_Bool","bool",
    "char","signed char","unsigned char",
    "short","unsigned short",
    "int","unsigned","unsigned int",
    "long","unsigned long",
    "float","double",
    "wchar_t","size_t"
};

int klee::getSizeFromType(const std::string& typeName){
  if (typeName == "byte" || typeName == "_Bool"||
      typeName == "bool" || typeName == "char" ||
      typeName == "signed char" || typeName == "unsigned char")
    return 1;
  else if (typeName == "short" || typeName == "unsigned short" )
    return 2;
  else if (typeName == "int" || typeName == "unsigned"||
           typeName == "unsigned int"|| typeName == "float"||
           typeName == "wchar_t")
    return 4;
  else if (typeName == "long" || typeName == "unsigned long"||
           typeName == "double"|| typeName == "size_t" )
    return 8;
  else if (typeName.find('i') == 0){
    std::string bitStr = typeName.substr(1);
    return std::stoi(bitStr) / 8;
  }
  return 0;
}


bool klee::matchObjDeclVarName(const std::string &objName,
                               const std::string &declName,
                               bool isArray){
  if (declName.find(objName) != 0)
    return false;
  if (isArray){
    // if var in smt-lib is Array, means ackermann not simplified it,
    // so the suffix of declName don't have "_ack!", but only digital
    int pos = declName.find(objName);
    if (pos == 0){
      std::string sub = declName.substr(objName.length());
      bool match = true;
      for (auto const &c : sub)
        if(!isdigit(c))
          match = false;
      return match;
    }
    return false;
  }
  int pos = declName.find("_ack!");
  std::string sub = declName.substr(0,pos);
  bool res = sub == objName;
  return res;
}

void klee::getDataBytes(double drealVal,
                        const std::string& varType,
                        std::vector<unsigned char> &data){
    int varBits = getSizeFromType(varType);

    unsigned char *p = (unsigned char *) &drealVal;
    if (varType == "i8") {
        char res = (char) drealVal;
//    p = (unsigned char *) &res;
        data.push_back(static_cast<unsigned char>(res));
    } else if (varType == "i32") {
        int res = (int) drealVal;
//    p = (unsigned char *) &res;
        for (int i = 0; i < 4; ++i) {
            unsigned char byte = (res >> (8 * i)) & 0xFF;
            data.push_back(byte);
        }
    } else if (varType == "i64") {
        long res = (long) drealVal;
//    p = (unsigned char *) &res;
        for (int i = 0; i < 8; ++i) {
            unsigned char byte = (res >> (8 * i)) & 0xFF;
            data.push_back(byte);
        }
    } else if (varType == "float") {
        float res = (float) drealVal;
//    p = (unsigned char *) &res;
        unsigned char *p = reinterpret_cast<unsigned char*>(&res);
        for (int i = 0; i < 4; ++i) {
            data.push_back(p[i]);
        }
    } else if (varType == "double") {
        double res = (double) drealVal;
//    p = (unsigned char *) &res;
        unsigned char *p = reinterpret_cast<unsigned char*>(&res);
        for (int i = 0; i < 8; ++i) {
            data.push_back(p[i]);
        }
    } else{
        // default case for "model_version"
        int res = (int) drealVal;
//    p = (unsigned char *) &res;
        for (int i = 0; i < 4; ++i) {
            unsigned char byte = (res >> (8 * i)) & 0xFF;
            data.push_back(byte);
        }
    }

//  for (int i = 0; i < varBits; i++){
//      int t = (int) *p++;
//      llvm::errs()<<t<<"\n";
//      data.push_back(t);
//  }

}

//add by yx
void klee::getDataBytes(std::string strVal,
                        const std::string& varType,
                        std::vector<unsigned char> &data){
  int varBits = getSizeFromType(varType);

  std::string intStr = "";

  for(int i=0; i<strVal.size(); i++){
    if(strVal[i]=='_'){
      break;
    }
    intStr += strVal[i];
  }

  mpz_class decimal_num = mpz_class(intStr,10);
  mpz_class binary_num;

//  long drealVal = std::stol(strVal);
//  unsigned char *p = (unsigned char *) &drealVal;
  if (varType == "i8") {
    mpz_ui_pow_ui(binary_num.get_mpz_t(), 2, 8); // 初始化二进制数为2的64次方
  } else if (varType == "i32") {
    mpz_ui_pow_ui(binary_num.get_mpz_t(), 2, 32); // 初始化二进制数为2的64次方
  } else if (varType == "i64") {
    mpz_ui_pow_ui(binary_num.get_mpz_t(), 2, 64); // 初始化二进制数为2的64次方
  } else if (varType == "float") {
    mpz_ui_pow_ui(binary_num.get_mpz_t(), 2, 32); // 初始化二进制数为2的64次方
  } else if (varType == "double") {
    mpz_ui_pow_ui(binary_num.get_mpz_t(), 2, 64); // 初始化二进制数为2的64次方
  } else{
    // default case for "model_version"
    long drealVal = std::stol(strVal);
    unsigned char *p = (unsigned char *) &drealVal;
    for (int i = 0; i < varBits; i++)
      data.push_back((int) *p++);
  }

  mpz_class tmp(decimal_num);
  int bit_count = 0;
  while (tmp > 0) {
    if (tmp % 2 == 1) {
      binary_num += mpz_class(1) << bit_count;
    }
    tmp /= 2;
    bit_count++;
  }

  const std::string dataStr = binary_num.get_str(2);

  for(int i=dataStr.size()-1; i>0;){
    int byteData = 0;
    int base = 1;
    int j=0;
    while(j++<8){
      byteData += (dataStr[i--]-'0')*base;
      base<<=1;
    }
    data.push_back(byteData);
  }

//  for (int i = 0; i < varBits; i++)
//    data.push_back((int) *p++);
}

bool isFloatFromType(const std::string& typeName){
  if (typeName == "float" || typeName == "double")
    return true;
  return false;
}

std::string removePrefixStr(const std::string &typeName,
                            const std::string &pattern){
  if (typeName.find(pattern) != std::string::npos)
    return typeName.substr(pattern.length());
  return typeName;
}

bool checkBasicType(const std::string &typeName){
  if (typeName.find('*') != std::string::npos)
    return false;
  std::string basicTypeName = removePrefixStr(typeName,"const ");
  if (basicTypeSet.find(basicTypeName) != basicTypeSet.end())
    return true;
  return false;
}

std::vector<std::string> strSplit(
    const std::string &str,
    const std::string &pattern){
  std::vector<std::string> resVec;
  if (str.empty()) return resVec;

  std::string strs = str + pattern;

  size_t pos = strs.find(pattern);
  size_t size = strs.size();

  while (pos != std::string::npos){
    std::string x = strs.substr(0,pos);
    if (x != " ")
      resVec.push_back(x);
    strs = strs.substr(pos + pattern.size(), size);
    pos = strs.find(pattern);
  }
  return resVec;
}

void klee::parseJsonConfig(std::vector<std::string> &linkLibs,
                           std::vector<std::string> &noMainObj,
                           std::vector<FunctionTypeInfo> &funcType) {
  struct stat buffer{};
  if (stat(JsonConfigPath.c_str(), &buffer) != 0){
    llvm::errs()<<"Please check --json-config-path option, where json config file does not exist!\n";
    //exit(0);
    return ;
  }

  struct json_object *json_file = json_object_from_file(JsonConfigPath.c_str());

  struct json_object *json_linkLibs =
      json_object_object_get(json_file,"project_linked_libs");
  linkLibs = strSplit(json_object_get_string(json_linkLibs)," ");

  struct json_object *json_noMainObj =
      json_object_object_get(json_file,"project_no_main_obj_file");
  noMainObj = strSplit(json_object_get_string(json_noMainObj)," ");

  struct json_object *json_funcTypePath =
      json_object_object_get(json_file,"project_function_type_json_file");
  std::string funcTypePath = json_object_get_string(json_funcTypePath);
  if (stat(funcTypePath.c_str(), &buffer) != 0){
    llvm::errs()<<"Please check 'project_function_type_json_file' in json config file,"
                  " where function type json file does not exist!\n";
    exit(0);
  }

  struct json_object *json_func_type_file = json_object_from_file(funcTypePath.c_str());

  // Get all type definition info, check if use basic type as another name
  struct json_object *typedefInfo = json_object_object_get(json_func_type_file,
                                                         "TypedefInfo");
  int typedefNum = json_object_array_length(typedefInfo);
  for (int i = 0; i<typedefNum; i++){
    struct json_object *typeDef = json_object_array_get_idx(typedefInfo,i);
    struct json_object *typeDefBefore =
        json_object_object_get(typeDef,"TypeBefore");
    struct json_object *typeDefAfter =
        json_object_object_get(typeDef,"TypeAfter");
    std::string typeBeforeName = json_object_get_string(typeDefBefore);
    std::string typeAfterName = json_object_get_string(typeDefAfter);

    // get the redefined type corresponding to basic type
    if (checkBasicType(typeBeforeName))
      basicTypeSet.insert(typeAfterName);
  }

  // Get all function info, and check the function type whether basic.
  // The definition of 'Basic Function' is all arguments and return variable
  // are basic type. (bool/char/int/......)
  struct json_object *funcsInfo = json_object_object_get(json_func_type_file,
                                                        "FunctionInfo");
  int funcNum = json_object_array_length(funcsInfo);
  for (int i = 0; i<funcNum; i++){
    bool basicFuncFlag = true;
    struct json_object *func = json_object_array_get_idx(funcsInfo,i);
    struct json_object *json_func_name =
        json_object_object_get(func,"FunctionName");
    std::string funcName = json_object_get_string(json_func_name);

    // we don't care main function
    if (funcName == "main") continue;

    struct json_object *json_ret_type =
        json_object_object_get(func,"ReturnType");
    std::string retType = json_object_get_string(json_ret_type);

    // remove "const " transfer to basic type
    retType = removePrefixStr(retType,"const ");
    if (!checkBasicType(retType)) basicFuncFlag = false;

    int retSize = getSizeFromType(retType);

    ParameterTypeInfo retPara = ParameterTypeInfo(retType,retSize,
                                                  isFloatFromType(retType));

    struct json_object *paramsInfo = json_object_object_get(func,"ParamInfo");
    int paramNum = json_object_array_length(paramsInfo);
    std::vector<ParameterTypeInfo> paramInfoList;
    for (int j = 0; j<paramNum; j++){
      struct json_object *param = json_object_array_get_idx(paramsInfo,j);
      struct json_object *param_type = json_object_object_get(param,"ParamType");
      struct json_object *param_size = json_object_object_get(param,"ParamSize");
      std::string paraType = json_object_get_string(param_type);
      int paraSize = json_object_get_int(param_size);

      // remove "const " transfer to basic type
      paraType = removePrefixStr(paraType,"const ");

      // check each argument whether basic
      if (basicFuncFlag && !checkBasicType(paraType)) basicFuncFlag = false;

      //errs()<<"[zgf dbg] paraType:"<<paraType<<"  paraSize:"<<paraSize<<"\n";
      paramInfoList.emplace_back(paraType,paraSize,isFloatFromType(paraType));
    }

    if (basicFuncFlag)
      funcType.emplace_back(funcName,retPara,paramInfoList);
  }
}

void klee::buildFloatCFType(
    const std::vector<std::string> &basicComplexFuncSet,
    std::vector<FunctionTypeInfo> &funcType){
  ParameterTypeInfo f32Ty = ParameterTypeInfo("float",4,true);
  ParameterTypeInfo f64Ty = ParameterTypeInfo("double",8, true);

  ParameterTypeInfo int32Ty = ParameterTypeInfo("int",4,false);

  std::vector<ParameterTypeInfo> f32Args = {f32Ty};
  std::vector<ParameterTypeInfo> f64Args = {f64Ty};

  for(const auto &basicComplexFunc : basicComplexFuncSet){
    // use "atan2" to divide one para function and two para function
    if (basicComplexFunc == "atan2"){
      f32Args.push_back(f32Ty);
      f64Args.push_back(f64Ty);
    }

    // push back float/double function model, use which one is decided by
    // SMT-LIB bitWidth
    funcType.emplace_back(basicComplexFunc,f32Ty,f32Args);
    funcType.emplace_back(basicComplexFunc,f64Ty,f64Args);
  }

  // special handle "double ldexp(double ,int )"
  std::vector<ParameterTypeInfo> ldexpArgs = {f64Ty,int32Ty};
  funcType.emplace_back("ldexp",f64Ty, ldexpArgs);
}

void klee::buildFPCheckType(std::vector<FunctionTypeInfo> &funcType){
  ParameterTypeInfo boolTy = ParameterTypeInfo("bool",1, false);
  ParameterTypeInfo f32Ty = ParameterTypeInfo("float",4, true);
  ParameterTypeInfo f64Ty = ParameterTypeInfo("double",8, true);
  std::vector<ParameterTypeInfo> f32Args = {f32Ty,f32Ty};
  std::vector<ParameterTypeInfo> f64Args = {f64Ty,f64Ty};

  funcType.emplace_back("FPCHECK_FADD_OVERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FSUB_OVERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FMUL_OVERFLOW",boolTy,f64Args);

  funcType.emplace_back("FPCHECK_FADD_UNDERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FSUB_UNDERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FMUL_UNDERFLOW",boolTy,f64Args);

  funcType.emplace_back("FPCHECK_FDIV_OVERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FDIV_UNDERFLOW",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FDIV_INVALID",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FDIV_ZERO",boolTy,f64Args);

  funcType.emplace_back("FPCHECK_INVALID_SQRT",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_INVALID_LOG",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_INVALID_POW",boolTy,f64Args);

  funcType.emplace_back("FPCHECK_FADD_OVERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FSUB_OVERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FMUL_OVERFLOW",boolTy,f32Args);

  funcType.emplace_back("FPCHECK_FADD_UNDERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FSUB_UNDERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FMUL_UNDERFLOW",boolTy,f32Args);

  funcType.emplace_back("FPCHECK_FDIV_OVERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FDIV_UNDERFLOW",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FDIV_INVALID",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FDIV_ZERO",boolTy,f32Args);

  funcType.emplace_back("FPCHECK_FINVALID_SQRT",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FINVALID_LOG",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FINVALID_POW",boolTy,f32Args);

  funcType.emplace_back("FPCHECK_FINVALID_SQRT",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FINVALID_LOG",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FINVALID_POW",boolTy,f64Args);

  funcType.emplace_back("FPCHECK_FADD_ACCURACY",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FSUB_ACCURACY",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FMUL_ACCURACY",boolTy,f32Args);
  funcType.emplace_back("FPCHECK_FDIV_ACCURACY",boolTy,f32Args);

  funcType.emplace_back("FPCHECK_FADD_ACCURACY",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FSUB_ACCURACY",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FMUL_ACCURACY",boolTy,f64Args);
  funcType.emplace_back("FPCHECK_FDIV_ACCURACY",boolTy,f64Args);
}
